/* generated from model Automata */
/* generated by template core.Interface*/

/* (c) https://github.com/MontiCore/monticore */
package automata._symboltable;

/* generated by template core.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.monticore.ast.ASTNode;
import de.monticore.ast.Comment;
import de.se_rwth.commons.SourcePosition;
import de.monticore.symboltable.*;


 public  interface IAutomataScope extends IAutomataScopeTOP {
   
   default public List<automata._symboltable.StateSymbol> resolveStateDownMany(boolean foundSymbols, String name, de.monticore.symboltable.modifiers.AccessModifier modifier, java.util.function.Predicate<automata._symboltable.StateSymbol> predicate) {
     
     if (!isStateSymbolsAlreadyResolved()) {
       setStateSymbolsAlreadyResolved(true);
     }
     else {
       return new ArrayList<>();
     }
     
     // 1. Conduct search locally in the current scope
     final List<automata._symboltable.StateSymbol> resolved = this.resolveStateLocallyMany(foundSymbols, name, modifier, predicate);
     
     foundSymbols = foundSymbols | resolved.size() > 0;

     final String resolveCall = "resolveDownMany(\"" + name + "\", \"" + "StateSymbol"
         + "\") in scope \"" + (isPresentName() ? getName() : "") + "\"";
     Log.trace("START " + resolveCall + ". Found #" + resolved.size() + " (local)", "");
     // If no matching symbols have been found...
     if (resolved.isEmpty()) {
       // 2. Continue search in sub scopes and ...
       for (automata._symboltable.IAutomataScope subScope : getSubScopes()) {
         List<automata._symboltable.StateSymbol> resolvedFromSub = new ArrayList<automata._symboltable.StateSymbol>();
         // continue with default behavior as long as a qualified name with
         // multiple part is present
         if (getNameParts(name).toList().size() > 1) {
           resolvedFromSub = subScope
               .continueAsStateSubScope(foundSymbols, name, modifier, predicate);
         } else {
           // otherwise, perform deep resolving with symbol name over all
           // subscopes recursively
           resolvedFromSub = subScope
               .resolveStateDownMany(foundSymbols, name, modifier, predicate);
         }
         foundSymbols = foundSymbols | resolved.size() > 0;
         // 3. unify results
         resolved.addAll(resolvedFromSub);
       }
     }
     Log.trace("END " + resolveCall + ". Found #" + resolved.size(), "");
     setStateSymbolsAlreadyResolved(false);
     return resolved;
   }
 }
