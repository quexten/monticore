/* (c) https://github.com/MontiCore/monticore */
package esolution1optinheritance._ast;

/* generated by template ast.AstImports*/

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Optional;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.monticore.ast.ASTNode;


 public class ASTT extends esolution1optinheritance._ast.ASTTTOP
 {
  
  // This attribute (inherited from D)
  // protected  Optional<d._ast.ASTS> b = Optional.empty();
  // needs to be with this attribute (inherited from esolution1optinheritance)
  // protected  Optional<esolution1optinheritance._ast.ASTS> kkk = Optional.empty();

  // Thus we adapt the setter for kkk:
  // (that also adapts the constructor)

  // constructors
  protected  ASTT () { }

  protected  ASTT ( esolution1optinheritance._ast.ASTS kkk ,
                    esolution1optinheritance._ast.ASTS c )
  {
    setKkk(kkk);
    setC(c);
  }


   protected  ASTT ( Optional<esolution1optinheritance._ast.ASTS> kkk ,
      esolution1optinheritance._ast.ASTS c )
  {
     if (kkk.isPresent()) {
       setKkk(kkk.get());
     } else {
       setKkkAbsent();
     }
    
    setC(c);
  }

  public void setKkk(esolution1optinheritance._ast.ASTS kkk) {
    super.setKkk(kkk);
    // does: this.kkk = Optional.ofNullable(kkk);
    // and additionally:  
    // (save, because this is an upcast)
    super.setB((d._ast.ASTS)kkk);
    // does: this.b = Optional.ofNullable(kkk);
  }


  public void setB(d._ast.ASTS b) { 
    super.setB(b); 
    // does: this.b = Optional.ofNullable(b);
    // // and additionally:
    // (quasi-save, because all objects of type d._ast.ASTS are actually of 
    //  type esolution1optinheritance._ast.ASTS)
    super.setKkk((esolution1optinheritance._ast.ASTS)b);
  } 

  // compares, clones, etc. should be working fine (relying on set)

  // Remark: we here store two optionals in sync.
  // In principle the same could be done for lists, but that 
  // potentially produces much more overhead.
  // Instead a lazy calculation of the second list on demand might be feasible
}
