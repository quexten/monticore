{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MontiCore - Language Workbench and Development Tool Framework MontiCore is a language workbench for the efficient development of domain-specific languages (DSLs). It processes an extended grammar format which defines the DSL and generates Java components for processing the DSL documents. Examples for these components are parsers, AST classes, symboltables or pretty printers. This enables a user to rapidly define a language and use it together with the MontiCore-framework to build domain specific tools. Some MontiCore advantages are the reusability of predefined language components, conservative extension and composition mechanisms, and an optimal integration of handwritten code into the generated tools. Its grammar languages are comfortable to use. Start here for developing with MontiCore. [HKR21] Katrin H\u00f6lldobler, Oliver Kautz, Bernhard Rumpe: MontiCore Language Workbench and Library Handbook: Edition 2021. Shaker, 2021. A Teaser for MontiCore To show a little of MontiCore's capabilities, the following (incomplete) grammar might help: grammar MyStatemachine extends Automata, // MontiCore grammar MCBasicTypes, SetExpressions, MCCommonLiterals { start Automaton; // overriding a nonterminal (to add optional conditions): Transition = from:Name@State \":\" Expression? \"->\" to:Name@State; // add new variants of expressions LogicalNotExpr implements Expression = \"!\" Expression; XorExpr implements Expression = left:Expression \"xor\" right:Expression; scope LetExpr implements Expression = \"let\" (VarDeclaration || \",\")+ \"in\" Expression; symbol VarDeclaration = MCType? Name \"=\" Expression ; } The grammar language has a variety of mechanisms to define new nonterminals using constants \"!\" , brackets (..) , optionals ? , lists * , repetitions (..||..)+ , etc. The grammar builds an extended version of Statemachines reusing existing grammar components, here Automata , MCBasicTypes , SetExpressions and MCCommonLiterals . The grammar has 5 productions introducing 4 new nonterminals and overrides Transition , which is inherited from Automata . Transition additionally has an optional Expression? as firing condition. LogicalNotExpr , XorExpr , and LetExpr extend the already existing Expression nonterminal and add new forms of expressions. LetExpr introduces a new local variable, which is visible only in that scope (indicated by keyword). VarDeclaration defines the new place to define symbols (that have a Name ). There is an extensive infrastructure to manage the definition of names, visibility, etc. MontiCore compiles the above grammar into 78 classes with in total 18629 lines of code that define the complete frontend and a larger part of the backend of a statemachine processor. We now can write statemachines like: statemachine PingPong { // MyStatemachine state Ping, Pong; Ping : (speed > 14km/h && !missedBall) -> Pong } MontiCore provides versions of expressions that use SI Units like 240km/h or 14.2 m/s^2 , but also Java expressions like 2_000_000 and other variants including appropriate type checks. We include these forms of expressions by importing their grammars. Please note that in both cases (extension and overwriting existing nonterminals), we do not touch nor copy/paste the predefined grammars, but achieve an out-of-the-box reuse. Out-of-the-box reuse also includes reuse of predefined typechecks, code generation, etc. They only need to be extended to the added variants. Please also note that PlusExpr is mutually left-recursive. -- Yes, that works in MontiCore 6. Quick Start $ cd /usr/local $ wget www.monticore.de/download/aut.tar.gz $ tar -xf aut.tar.gz $ cd mc-workspace $ wget www.monticore.de/download/monticore-cli.jar $ java -jar monticore-cli.jar -g Automata.mc4 -hcp hwc/ -mp monticore-cli.jar $ javac -cp monticore-cli.jar -sourcepath \"src/;out/;hwc/\" src/automata/AutomataTool.java $ java -cp \"src/;out/;hwc/;monticore-cli.jar\" automata.AutomataTool example/PingPong.aut PingPong.autsym MontiCore has a Relaxed 3-Level License Informal summary: The MontiCore Language Workbench deals with three levels of code (MontiCore LWB, tool derivates, product code). Each has its own licenses: (1) Product code generated by a MontiCore tool derivate is absolutely free for each form of use including commercial use without any license restriction. (2) Tool derivates created using the MontiCore language workbench mention that it is built using MontiCore. There is no other restriction. (BSD 3 Clause license) (3) Adaptations of MontiCore should mention MontiCore and results published back into this repository (LGPL license). For details see Licenses . More Information about MontiCore MontiCore handbook . The handbook describes how to use MontiCore as an out-of-the-box language workbench , but also as grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of core grammars . MontiCore concentrates on reuse. It therefore offers a set of predefined language components , usually identified through an appropriate component grammar allowing to define your own language as a composition of reusable assets efficiently. reusable assets are among others: several sets of literals , expressions , types , and statements , which are freely composable. List of languages . This is a list of languages that can be used out of the box. Some of them are in development, others rather stable. Several of these languages are inspired by the UML/P (see [Rum16,Rum17] ). These complete languages are usually composed of a number of language components. This project is freely available software; you can redistribute the MontiCore language workbench according to the rules described in the licensing section . If questions appear e.g. on building an interpreter, please contact monticore@se-rwth.de. Further Information see also MontiCore handbook MontiCore Reference Languages - Languages Built Using MontiCore Build MontiCore - How to Build MontiCore Getting Started - How to start using MontiCore Changelog - Release Notes FAQ - FAQ Licenses - MontiCore 3-Level License Project root: MontiCore @github List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore","title":"Home"},{"location":"#monticore-language-workbench-and-development-tool-framework","text":"MontiCore is a language workbench for the efficient development of domain-specific languages (DSLs). It processes an extended grammar format which defines the DSL and generates Java components for processing the DSL documents. Examples for these components are parsers, AST classes, symboltables or pretty printers. This enables a user to rapidly define a language and use it together with the MontiCore-framework to build domain specific tools. Some MontiCore advantages are the reusability of predefined language components, conservative extension and composition mechanisms, and an optimal integration of handwritten code into the generated tools. Its grammar languages are comfortable to use. Start here for developing with MontiCore. [HKR21] Katrin H\u00f6lldobler, Oliver Kautz, Bernhard Rumpe: MontiCore Language Workbench and Library Handbook: Edition 2021. Shaker, 2021.","title":"MontiCore - Language Workbench and Development Tool Framework"},{"location":"#a-teaser-for-monticore","text":"To show a little of MontiCore's capabilities, the following (incomplete) grammar might help: grammar MyStatemachine extends Automata, // MontiCore grammar MCBasicTypes, SetExpressions, MCCommonLiterals { start Automaton; // overriding a nonterminal (to add optional conditions): Transition = from:Name@State \":\" Expression? \"->\" to:Name@State; // add new variants of expressions LogicalNotExpr implements Expression = \"!\" Expression; XorExpr implements Expression = left:Expression \"xor\" right:Expression; scope LetExpr implements Expression = \"let\" (VarDeclaration || \",\")+ \"in\" Expression; symbol VarDeclaration = MCType? Name \"=\" Expression ; } The grammar language has a variety of mechanisms to define new nonterminals using constants \"!\" , brackets (..) , optionals ? , lists * , repetitions (..||..)+ , etc. The grammar builds an extended version of Statemachines reusing existing grammar components, here Automata , MCBasicTypes , SetExpressions and MCCommonLiterals . The grammar has 5 productions introducing 4 new nonterminals and overrides Transition , which is inherited from Automata . Transition additionally has an optional Expression? as firing condition. LogicalNotExpr , XorExpr , and LetExpr extend the already existing Expression nonterminal and add new forms of expressions. LetExpr introduces a new local variable, which is visible only in that scope (indicated by keyword). VarDeclaration defines the new place to define symbols (that have a Name ). There is an extensive infrastructure to manage the definition of names, visibility, etc. MontiCore compiles the above grammar into 78 classes with in total 18629 lines of code that define the complete frontend and a larger part of the backend of a statemachine processor. We now can write statemachines like: statemachine PingPong { // MyStatemachine state Ping, Pong; Ping : (speed > 14km/h && !missedBall) -> Pong } MontiCore provides versions of expressions that use SI Units like 240km/h or 14.2 m/s^2 , but also Java expressions like 2_000_000 and other variants including appropriate type checks. We include these forms of expressions by importing their grammars. Please note that in both cases (extension and overwriting existing nonterminals), we do not touch nor copy/paste the predefined grammars, but achieve an out-of-the-box reuse. Out-of-the-box reuse also includes reuse of predefined typechecks, code generation, etc. They only need to be extended to the added variants. Please also note that PlusExpr is mutually left-recursive. -- Yes, that works in MontiCore 6.","title":"A Teaser for MontiCore"},{"location":"#quick-start","text":"$ cd /usr/local $ wget www.monticore.de/download/aut.tar.gz $ tar -xf aut.tar.gz $ cd mc-workspace $ wget www.monticore.de/download/monticore-cli.jar $ java -jar monticore-cli.jar -g Automata.mc4 -hcp hwc/ -mp monticore-cli.jar $ javac -cp monticore-cli.jar -sourcepath \"src/;out/;hwc/\" src/automata/AutomataTool.java $ java -cp \"src/;out/;hwc/;monticore-cli.jar\" automata.AutomataTool example/PingPong.aut PingPong.autsym","title":"Quick Start"},{"location":"#monticore-has-a-relaxed-3-level-license","text":"Informal summary: The MontiCore Language Workbench deals with three levels of code (MontiCore LWB, tool derivates, product code). Each has its own licenses: (1) Product code generated by a MontiCore tool derivate is absolutely free for each form of use including commercial use without any license restriction. (2) Tool derivates created using the MontiCore language workbench mention that it is built using MontiCore. There is no other restriction. (BSD 3 Clause license) (3) Adaptations of MontiCore should mention MontiCore and results published back into this repository (LGPL license). For details see Licenses .","title":"MontiCore has a Relaxed 3-Level License"},{"location":"#more-information-about-monticore","text":"MontiCore handbook . The handbook describes how to use MontiCore as an out-of-the-box language workbench , but also as grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of core grammars . MontiCore concentrates on reuse. It therefore offers a set of predefined language components , usually identified through an appropriate component grammar allowing to define your own language as a composition of reusable assets efficiently. reusable assets are among others: several sets of literals , expressions , types , and statements , which are freely composable. List of languages . This is a list of languages that can be used out of the box. Some of them are in development, others rather stable. Several of these languages are inspired by the UML/P (see [Rum16,Rum17] ). These complete languages are usually composed of a number of language components. This project is freely available software; you can redistribute the MontiCore language workbench according to the rules described in the licensing section . If questions appear e.g. on building an interpreter, please contact monticore@se-rwth.de.","title":"More Information about MontiCore"},{"location":"#further-information","text":"see also MontiCore handbook MontiCore Reference Languages - Languages Built Using MontiCore Build MontiCore - How to Build MontiCore Getting Started - How to start using MontiCore Changelog - Release Notes FAQ - FAQ Licenses - MontiCore 3-Level License Project root: MontiCore @github List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore","title":"Further Information"},{"location":"00.org/Explanations/CHANGELOG/","text":"Release Notes MontiCore 7.3.0 to be released Additions add cocos for lexical mode add coco for Expression add cocos for JavaLight new methods putSymbolDeSer, putXYSymbolDeSer and loadFileForModelNamed (GlobalScope Interface) new method getToken (MCParser) use CD4C in 02experiment.configTemplate Changes rename generated classes XYCLI -> XYTool MontiCore 7.2.0 released: 13.09.2021 Changes Several modes can now be specified in a grammar (for further explanations see ANTLR ). For the grammars, one file is now generated for lexer rules and one for the parser rules. delete deprecated classes: ModelPath , IterablePath , ModelCoordinate , ModelCoordinateImpl , ModelCoordinates , and FileFinder The symbol table now stores for productions whether a production is left-recursive. In the log class the dependency to ch.qos.logback:logback-core was removed MontiCore 7.1.0 released: 05.07.2021 Additions introduced language-specific CLI generation New class MCPath that manages a set of path entries. The class is used, e.g., for realizing symbol paths, model paths, handcoded paths, and template paths. MCPath replaces the classes IterablePath and ModelPath . Different modes can now be defined for lexical tokens in grammar. The corresponding generator will only be available in the next version. Changes the methods serialize and deserialize of the class XDeSer were moved to the class XSymbols2Json The following classes are marked as deprecated and will be removed in the near future: ModelPath , IterablePath , ModelCoordinate , ModelCoordinateImpl , ModelCoordinates , and FileFinder Fixes MontiCore 7.0.0 released: 08.04.2021 Additions resolveXSubKinds(..) resolves for local symbols of all subkinds of a symbol kind X. This method is used by the implementation of the resolveXLocally(..) method. It enables proper handling of symbol kind hierarchies during symbol resolution beyond the borders of a language. new annotation @NonConservative for productions add configTemplate (-cf) mechanism to add a freemarker template for customizing the generation processed add two predefined groovy hook points (-gh1 and -gh2) in the monticore_standard.groovy for injecting custom groovy scripts into the workflow Changes move grammars OCLExpressions and SetExpressions into OCL-project for further development DefsTypeBasic was moved to test. There are now only methods for creating symbols. Use the BasicSymbolsMill to create the basic data types like int, ... deserialize(String) method of scope DeSer classes is realized as default implementation in IDeSer interface deserialize(String) method of symbol DeSer classes is realized as default implementation in ISymbolDeSer interface deserializeAddons() and serializeAddons() methods of scopes are realized as empty default implementation in IDeSer interface If deserialization encounters a symbol kind for which no DeSer is contained in the symbol Deser map in global scopes, a warning is produced instead of an error Boolean isShadowing property of scopes is only serialized if its value is \"true\". Deserialization assumes a default value of \"false\" if the property is not contained in a serialized scope deserialize(String) method of symbol DeSers do not produce errors if the serialized kind deviates from the symbol kind that the DeSer is originally engineered for The TypeCheck was reworked The interface ITypesCalculator was renamed to IDerive and can now be used similar to the ISynthesize interface no SymbolSurrogates are created anymore by the TypeCheck. The Synthesize-Classes will now log an error if a type cannot be resolved SymTypeExpressions now have the method printFullName to print their full name The class TypeCheck now needs one IDerive and one ISynthesize for its constructor instead of only one of them The class DeriveSymTypeOfBSCommonExpressions , which does not pay attention to modifiers like static or private , can now be used as an alternative for the class DeriveSymTypeOfCommonExpressions Fixes Symbols with hierarchical symbol kinds are not serialized multiple times anymore. MontiCore 6.7.0 released: 26.01.2021 Additions Add new CLI for the MontiCore generator engine Changes The context conditions use the new traverser infrastructure. This leads to small changes in the api. The return value of the method addCoCo is void. Attribute fileExt in GlobalScopes now refers to a regular expression for file extensions of symbol table files. The default value of the attribute is \"*sym\", which usually includes symbol files of all MontiCore languages. Attention: If your language used the \"setFileExt\" method in previous versions of MontiCore to set the file extension of the model file (e.g., to \"aut\"), this will cause problems now as the symbol files of the language have differen file extensions (e.g., \"autsym). To fix this, it is sufficient to remove all invocations of \"setFileExt\" from the handwritten source code. For scopes, artifact scopes, and global scopes: Moved abstract methods that do not have a language- specific name or (argument, return) type from language-specific interface to MontiCore-runtime interfaces new experiment \"strules\" demonstrating the use of symbolrules and scoperules deserialize methods in SymTypeExpressionDeSers do not have an enclosingScope argument anymore. Internally, it uses the singleton global scope instead. renamed serializeAdditionalSSymbolAttributes in Symbols2Json class to serializeAddons and moved to scope and symbol DeSers. XScopeDeSer is renamed to XDeSer In Symbols2Json classes: now implementss Visitor2 new attribute \"XTraverser traverser\" with getter and setter Removed attribute \"realThis\" with getter and setter New constructor with two arguments XTraverser and JsonPrinter New zero args constructor Removed constructor with single JsonPrinter argument New attributes of all known symbol DeSers and current scope DeSers New method \"protected void init()\", initializing the DeSer attributes with the GlobalScope and the traverser with symbols2json of inherited languages adjusted store method to use traverser visit methods for symbols delegate to serialize method of the symbol DeSer visit and endVisit methods for scope interface and artifact scope interface print object stub and delegate serialization to scope DeSers DeSers do not have an attribute of Symbols2Json class anymore, instead it is passed as argument in the serialize methods Default values of built-in types that occur in attributes of symbolrules or scoperules are omitted during serialization and deserialization. The defaults are as follows: Boolean : false String : \"\" Numeric types: 0 (and 0L and 0.0 and 0.0f) For symbolrule and scoperule attributes with non-built-in data type, no Log.error is thrown at execution time of the serialize method call anymore. Instead, these methods (and then, their classes as well) are generated abstract to yield compilation errors instead. New interface IDeSer that all symbol and scope DeSers implement. GlobalScopes manage a map with all relevant DeSers. The map maps the serialized (symbol or scope) kind to the DeSer that (de)serialized this kind. This mechanism can be used to exchange the DeSer for a specific kind of symbol or scope. Scope DeSers have new serialize methods without Symbols2Json argment that can be used for for serializing (artifact) scopes for, e.g., unit tests removed the generation of XPhasedSymbolTableCreatorDelegator classes Experiments now use ScopesGenitor-infrastructure instead of SymbolTableCreator-infrastructure Fixes The initMe and reset methods of the mill now initialize and reset all attributes properly The CD4Analysis keywords ordered , composition , association , targetimport and classdiagram can be used in grammars again MontiCore 6.6.0 released: 03.12.2020 Additions The mill of a language now provides a method parser() to get the parser of the language mill initialization allows to reconfigure the mill to provide a parser for a sublanguage parser delegator XForYParser are generated that extend a parser of a super language and delegate to the parser of the current language Due to multiple inheritance, delegation and subclasses are used in combination experiments now showcase the use of traversers add coco (checks if additional attributes are declared twice) added built-in primitive types to the mills of grammars that extend the grammar BasicSymbols. Add to Mill by executing BasicSymbolsMill.initializePrimitives() Changes The generated parser uses the builder instead of the factory. This means that in grammars the variable _aNode is no longer available. Use instead _builder . Multiple renamings and signature changes regarding the deser infrastructure renamed XSymbolTablePrinter to XSymbols2Json moved load and store methods form XScopeDeSer to XSymbols2Json removed enclosing scope as method argument of symbol deser methods, as global scope shall be used instead renamed deserializeAdditionalSSymbolAttributes to deserializeAddons renamed deserializeAdditionalXScopeAttributes and deserializeAdditionalXScopeAttributes to deserializeAddons added the JSON printer as a parameter to the methods of XScopeDeSer , SSymbolDeSer und XSymbols2Json XScopeDeSer , SSymbolDeSer und XSymbols2Json are no longer available via the mill. The constructors can be used instead. Scope builder have been removed as they did not support multiple inheritance, scope creation methods of the mill should be used instead Shortened the name of the scope creation methods in the mill from xScope , xGlobalScope and xArtifactScope to scope , globalScope and artifactScope Shortened the name of the modelFileExtension attribute in the XGlobalScope class to fileExt renamed XScopeSkeletonCreator and XScopeSkeletonCreatorDelegator to XScopesGenitor and XScopesGenitorDelegator Deprecated the XPhasedSymbolTableCreatorDelegator , will be removed without replacement in a future release PrettyPrinters and other visitors in monticore-grammar now use the new Traverser infrastructure instead of the old Visitor infrastructure generated XScopeGenitor and XScopeGenitorDelegator now use the new Traverser infrastructure instead of the old Visitor infrastructure Changes to resolving if name of a topLevelSymbol in ArtifactScope = name of ArtifactScope: qualify symbols in spanned scopes of the topLevelSymbol like before with <topLevelSymbolName>.<symbolName> if name of a topLevelSymbol in ArtifactScope != name of ArtifactScope: qualify symbols in spanned scope of the topLevelSymbol with <ArtifactScopeName>.<topLevelSymbolName>.<symbolName> Traverser now support lists of Visitor2 interfaces instead of only one instance Rename accessor of Traverser from addXVisitor to add4X Methods returning referenced symbols save the symbols instead of the surroogates Fixes Traverser now properly delegate to handlers as intended ScopeSkeletonCreator now properly use the mill to create scope instances to ensure substitution via the mill pattern Fixed a bug where the SymbolSurrogates wrongly qualified their fullName The clear method of the GlobalScope now deletes all symbols stored in the GlobalScope Serializing symbolrule attributes of Strings now works properly MontiCore 6.6.0 released: 11.11.2020 Additions added an experiment hwDeSers showcasing serialization and deserialization added an experiment hooks showcasing hook point usage IncCheck provided by the MontiCore Gradle Plugin now considers local super grammar changes to trigger new generation Added new Traverser generation to replace the visitor infrastructure in a future release XTraverser XTraverserImplementation XVisitor2 XHandler Added new ScopeSkeletonCreator generation to replace the SymbolTableCreator in a future release and to enable a phased symboltable creation XScopeSkeletonCreator XScopeSkeletonCreatorDelegator XPhasedSymbolTableCreatorDelegator Added methods to directly obtain instances of the following classes in the mill (instead of their builders) XSymbolTableCreator XSymbolTableCreatorDelegator XScopeSkeletonCreator XScopeSkeletonCreatorDelegator XPhasedSymbolTableCreatorDelegator XScopeDeSer XSymbolDeSer XSymbolTablePrinter IXScope IXArtifactScope Changes MontiCore now uses Gradle as build tool some tasks have been introduced for the comfortable control of frequent activities, e.g., buildMC , assembleMC that can be found in the build.gradle relocated the EMF related subprojects: monticore-emf-grammar to monticore-grammar-emf monticore-emf-runtime to monticore-runtime-emf relocated integration tests and experiments: monticore-generator/it to monticore-test/it monticore-generator/it/experiments to monticore-test/01.experiments monticore-generator/it/02.experiments to monticore-test/02.experiments monticore-grammar/monticore-grammar-it to monticore-test/monticore-grammar-it Remove the generation of XModelloader . Languages should now use XScopeDeSer to load symbol tables instead. Removed the generation of the following builder classes (also from the Mill, see Additions for alternative solution) XSymbolTableCreatorBuilder XSymbolTableCreatorDelegatorBuilder XScopeDeSerBuilder XSymbolDeSerBuilder XSymbolTablePrinterBuilder renamed IXResolvingDelegate to IXResolver outsourced Type expressions for arrays to a separate grammar was FullGenericTypes , is now MCArrayTypes outsourced initialization for arrays to a separate grammar was MCVarDeclarationStatements , is now MCArrayStatements In a composed language, mills of super languages now provide scope instances (scope, global scope and artifact scope) for the composed language non-existing template paths now result in an error instead of a warning Set current visitor infrastructure to deprecated Integrate new visitor infrastructure (i.e., traverser) into XMill to enable re-usability of visitors via language inheritance Set SymbolTableCreator, SymbolTableCreatorDelegator and their builder to deprecated Integrate new ScopeSkeletonCreator, ScopeSkeletonCreatorDelegator and PhasedSymbolTableCreatorDelegator into Mill Added a method clear to the GlobalScope that clears its cache and its resolvers and empties its ModelPath Fixes Fixed that global variable changes in child templates were not changed in parents Fixed handling of optional names of symbols in symbol table creator Fixed an issue where surrogates hide symbol attributes MontiCore 6.4.0 released: 12.10.2020 Additions extended the generated incCheck files to contain information about local super grammars the sh-file is now able to trigger generation if local super grammars are changed the incCheck method provided by the plugin will support this behavior as well will only be available in the next release extended the mill to manage the global scope instance centrally added comfort methods for creating modifiers to the ModifierBuilder ModifierBuilder().PUBLIC() short for ModifierBuilder().setPublic(true) added MCShadowingJavaBlock to MCCommonStatements standard MCJavaBlock is no longer shadowing added a class diagram to the reports that represents the generated data structure for the given grammar (ast, symbol table visitors, etc.) added simple BreakStatement to MCCommonStatements added an include2 alias for the template controller method for including templates in conjunction with templates arguments Changes CLI does no longer check whether a generation is needed (this should be handled by the build tool) rephrased messages for non-conservative extension (added super grammar name) added a context condition to prevent list of names in nonterminal production marked as symbols might be supported in a future version of MontiCore moved XForYMills to a subpackage to reduce noise (subpackage: _auxiliary) deprecated the generated enum f\u00fcr constants will be removed without replacement in a future release moved EnhancedForControl production from JavaLight to MCCommonStatements as it is commonly used standard MCJavaBlock is no longer shadowing renamed BreakStatement in MCLowLevelStatements to LabelledBreakStatement ForStatement now spans a non-exporting, ordered scope shortened generated error codes to have 5 digits only renamed MethOrConstr to JavaMethod in JavaLight MontiCore Gradle plugin is no longer shipped as a fat jar Fixes Fixed error code calculation for generated error messages to no longer be random Fixed the report for involved files to contain handwritten files that were considered will only be available in the next release Fixed an issue where reports did not contain meaningful names for elements such as class diagram classes or interfaces MontiCore 6.3.0 released: 16.09.2020 Additions added @Override annotation for nonterminal production to state that this production overrides a super grammars' production overriding without annotation leads to a warning using the annotation for a production that does not override an existing nonterminal results in an error added a context condition to ensure that external production do not have ast rules added DiagramSymbol in BasicSymbols introduced generated interfaces for GlobalScope and ArtifactScope Changes serialization of symtype expression now serializes full name of symtype instead of simple name class ASTNodes is now deprecated and its usages in the generator are removed visitors no longer provide visit methods for concrete scope classes but their interfaces instead SymTypeExpression no longer use surrogates but TypeSymbol s instead reverted changes to appended s for list attributes made in previous release moved initialization of symbols to the endVisit method of the SymbolTableCreator Fixes Fixed missing sourcecode position for overriding warning Fixed an issue where the inheritance hierarchy was no considered correctly when overriding a nonterminal MontiCore 6.2.0 released: 21.07.2020 Additions added isFinal to OOType in OOSymbols extended the mill such that builder for DeSer related classes are provided by the mill added support for symbol usages in NonterminalSeperator example: Bar = (bla:Name@Foo || \",\" )+; added reports for the symbol table structure of the processed grammar added isReadOnly to Variable in BasicSymbols added isElliptic to Method in TypeSymbols added a context condition to warn if keywords consist of numbers only these numbers will be tokenized as keywords instead of numbers added splittoken to express that the listed tokens should be split and not handled as a single token example: splittoken \":::\"; results in three token : added nokeyword to express that the listed keywords should not be handled as tokens example: nokeyword \"automaton\", \"state\"; means that automaton and state should not be handled as keywords introduced symbol inheritance Changes renamed de.monticore.type.TypeSymbols to de.monticore.symbols.OOSymbols renamed de.monticore.type.BasicTypeSymbols to de.monticore.symbols.BasicSymbols reworked appended s for list attributes renamed SymbolLoader to SymbolSurrogate Surrogates are now subclasses of their corresponding symbols MCJavaBlock in MCCommonStatements now spans a shadowing, non-exporting, ordered scope MethodDeclaration and ConstructorDeclaration in JavaLight use MCJavaBlock instead of MCBlockStatement Label in MCLowLevelStatement now is a symbol VarDecl in MCVarDeclarationStatements no longer exists DeclaratorId now produces FieldSymbol s removed isParameter and isVariable from Field in TypeSymbols the language class is no longer generated moved creator expressions to JavaClassExpression moved PlusExpression and MinusExpression from AssignmentExpressions to CommonExpressions Fixes Fixed an issue where super and subtype comparison was wrong in type check Fixed handling of capital letters in grammar package * using capital letters now produces a warning * Fixed an issue were setAbsent methods in the generated SymbolBuilder where not properly overridden * Fixed that non-shadowing scopes where not handled as intended MontiCore 6.1.0 released: 07.05.2020 MontiCore 6.0.0 Uses CD4Analysis 1.5.0 replace get*opt methods with get* bugfixing MontiCore 5.4.0.1 Uses CD4Analysis 1.4.0 add generation of serializers for grammars add SymbolLoader remove SymbolReferences add DeSers for TypeSymbols improved TypeCheck replace getName methods with printType methods MontiCore 5.3.0 Uses CD4Analysis 1.3.20.2 new Generator based on Decorator-Pattern add Translation classes add grammar it-tests move TypesCalculator to TypeCheck, create derive classes and synthesize classes add TypeSymbols and SymTypeExpression structure added DeSers for SymTypeExpressions added keyword \"key\" for KeyTerminals MontiCore 5.2.0 add \"List\"-Suffix to attribute name MontiCore 5.1.0 Remove the dependency to JavaDSL, add JavaLight Uses CD4Analysis 1.3.19 added grammar TypeSymbols renamed SymbolDelegateList to SymbolResolvingDelegateList add methods for scoperule-attributes in interfaces add MCTypeVisitor to transform ASTTypes to TypeExpressions add Groovy Plugin add MontiCore Statements at de.monticore.statements MontiCore 5.0.6 The IncGen-reports are stored in the source code directory Removed MutableScope IncGen-Reports are stored Removed deprecated keyword ast (use astrule ) in *.mc4 Add visitors for symbol table Enable TOP mechanism for visitors add SymbolRules and ScopeRules renamed MCBasicLiterals to MCCommonLiterals, add MCLiteralsBasis move literals to package de.monticore.literals renamed ShiftExpressions to BitExpressions MontiCore 5.0.3 Use the following emf coordinates (MB): group: org.eclipse.emf version: 2.15.0 artifact: org.eclipse.emf.ecore | org.eclipse.emf.ecore.xmi | org.eclipse.emf.common The runtime environment may need the following dependency (group: org.eclipse.platform; artifacitId: org.eclipse.equinox.common; version: 3.10.0) splitted Types.mc4 in MCBasicTypes, MCCollectionTypes, MCSimpleGenericTypes and MCFullGenericTypes moved expressions to de.monticore.expressions and added expressions MontiCore 5.0.2 Generated by the MontiCore version 5.0.1 Uses JavaDSL 4.3.13, Cd4Analysis 1.3.16, se-commons 1.7.9 Introduce deprecated annotation in grammars (#2215) Serialization of symobls Add reporter IncGenCheckReporter Configuration of the report path Specific resolving methods in generated scope classes Bugfixes MontiCore 5.0.1 Generated by the MontiCore version 5.0.0 Uses JavaDSL 4.3.12, Cd4Analysis 1.3.13, se-commons 1.7.9 Bugfixes New methods defineHookPointWithDefault in GlobalExtensionManagement (MB) new method cmpToken in MCParser (MB) every (non-)terminal defined in an interface must be present in the implementing production (including Name and Usage Name) (CoCo) (BS) to ensure that any terminal (with a specific name) has to be implemented, use an empty string, e.g. interface Expression = operator=\"\"; new methods are generated for the referenced symbol and definition and the definition is saved in an attribute (generated wenn you write sth. like \"Name@Symbol\") (NP) coco that gives a warning if you do not extend conservative (NP) coco that attributes with the same usage Name have to reference the same symbol (NP) SpannedScope and Symbol Methods in ASTNode set to deprecated (NP) MontiCore 5.0.0 Generated by the MontiCore version 4.5.5.1 Uses JavaDSL 4.3.11, Cd4Analysis 1.3.13, se-commons 1.7.8 Changed name building for list attributes in grammars (x:Name* -> getXList) Changed api for GlobalExtensionMangament and TemplateController (see reference manual) New api for AST nodes (constructor, getter and setter for lists and optional attributes, ...) Builder classes for AST nodes are external now. Signatures are similar to those in the corresponding AST node, except those methods which set or add something, these return the Builder itself (which allows method chaining) Changed default script to noemf for the generation of MontiCore. If you want to use emf you can generate monticore-grammar and Java-DSL with the profile \"emf\". This profile also creates the emf jars. You are also able to test the integration-tests with the profile \u201cemf-it-tests\u201d, which contains extra tests for the generation with emf. Parsed grammars are not stored as class diagram anymore. CD is only stored as report. Removed deprecated method filter(ResolvingInfo resolvingInfo, List symbols) use filter(ResolvingInfo, Collection) instead Removed deprecated method filter(ResolvingInfo resolvingInfo, String name, List symbols) use filter(ResolvingInfo, String, Map) instead Removed deprecated method create(Class symbolClass, SymbolKind symbolKind) use create(SymbolKind) instead Removed deprecated method getSymbols use getLocalSymbols instead Removed deprecated method resolve(SymbolPredicate predicate) use resolveMany(String, SymbolKind, Predicate) instead Removed deprecated method define use add instead Removed deprecated method resolve(ResolvingInfo resolvingInfo, String name, SymbolKind kind, AccessModifier modifier) Removed deprecated method checkIfContinueWithEnclosing use checkIfContinueWithEnclosingScope instead Removed deprecated method addResolver use addFilter(String, ResolvingFilter) instead Removed deprecated method addTopScopeResolver use addDefaultFilter instead Removed deprecated method addTopScopeResolvers use addDefaultFilters instead Removed deprecated method getTopScopeResolvingFilters use getDefaultFilters instead Removed deprecated constructer CommonResolvingFilter(Class symbolClass, SymbolKind targetKind) use CommonResolvingFilter(SymbolKind) instead Removed deprecated method continueWithScope and continueWithEnclosingScope Removed class FaildLoadingSymbol Removed deprecated method putInScopeAndLinkWithAst use addToScopeAndLinkWithNode instead Removed deprecated constructer CommonModelingLanguage(String, String, SymbolKind) use CommonModelingLanguage(String, String) instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method getResolvers use getResolvingFilters instead Removed deprecated method loadAmbiguousModelAndCreateSymbolTable use loadModelsIntoScope instead Removed deprecated method loadAmbiguousModels use loadModels instead Removed deprecated method defineHookPoint(String) use glex.defineHookPoint instead Removed deprecated enum ParserExecution Removed deprecated method getParserTarget Removed deprecated method setParserTarget Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Changelog"},{"location":"00.org/Explanations/CHANGELOG/#release-notes","text":"","title":"Release Notes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-730","text":"to be released","title":"MontiCore 7.3.0"},{"location":"00.org/Explanations/CHANGELOG/#additions","text":"add cocos for lexical mode add coco for Expression add cocos for JavaLight new methods putSymbolDeSer, putXYSymbolDeSer and loadFileForModelNamed (GlobalScope Interface) new method getToken (MCParser) use CD4C in 02experiment.configTemplate","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes","text":"rename generated classes XYCLI -> XYTool","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-720","text":"released: 13.09.2021","title":"MontiCore 7.2.0"},{"location":"00.org/Explanations/CHANGELOG/#changes_1","text":"Several modes can now be specified in a grammar (for further explanations see ANTLR ). For the grammars, one file is now generated for lexer rules and one for the parser rules. delete deprecated classes: ModelPath , IterablePath , ModelCoordinate , ModelCoordinateImpl , ModelCoordinates , and FileFinder The symbol table now stores for productions whether a production is left-recursive. In the log class the dependency to ch.qos.logback:logback-core was removed","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-710","text":"released: 05.07.2021","title":"MontiCore 7.1.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_1","text":"introduced language-specific CLI generation New class MCPath that manages a set of path entries. The class is used, e.g., for realizing symbol paths, model paths, handcoded paths, and template paths. MCPath replaces the classes IterablePath and ModelPath . Different modes can now be defined for lexical tokens in grammar. The corresponding generator will only be available in the next version.","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_2","text":"the methods serialize and deserialize of the class XDeSer were moved to the class XSymbols2Json The following classes are marked as deprecated and will be removed in the near future: ModelPath , IterablePath , ModelCoordinate , ModelCoordinateImpl , ModelCoordinates , and FileFinder","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes","text":"","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-700","text":"released: 08.04.2021","title":"MontiCore 7.0.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_2","text":"resolveXSubKinds(..) resolves for local symbols of all subkinds of a symbol kind X. This method is used by the implementation of the resolveXLocally(..) method. It enables proper handling of symbol kind hierarchies during symbol resolution beyond the borders of a language. new annotation @NonConservative for productions add configTemplate (-cf) mechanism to add a freemarker template for customizing the generation processed add two predefined groovy hook points (-gh1 and -gh2) in the monticore_standard.groovy for injecting custom groovy scripts into the workflow","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_3","text":"move grammars OCLExpressions and SetExpressions into OCL-project for further development DefsTypeBasic was moved to test. There are now only methods for creating symbols. Use the BasicSymbolsMill to create the basic data types like int, ... deserialize(String) method of scope DeSer classes is realized as default implementation in IDeSer interface deserialize(String) method of symbol DeSer classes is realized as default implementation in ISymbolDeSer interface deserializeAddons() and serializeAddons() methods of scopes are realized as empty default implementation in IDeSer interface If deserialization encounters a symbol kind for which no DeSer is contained in the symbol Deser map in global scopes, a warning is produced instead of an error Boolean isShadowing property of scopes is only serialized if its value is \"true\". Deserialization assumes a default value of \"false\" if the property is not contained in a serialized scope deserialize(String) method of symbol DeSers do not produce errors if the serialized kind deviates from the symbol kind that the DeSer is originally engineered for The TypeCheck was reworked The interface ITypesCalculator was renamed to IDerive and can now be used similar to the ISynthesize interface no SymbolSurrogates are created anymore by the TypeCheck. The Synthesize-Classes will now log an error if a type cannot be resolved SymTypeExpressions now have the method printFullName to print their full name The class TypeCheck now needs one IDerive and one ISynthesize for its constructor instead of only one of them The class DeriveSymTypeOfBSCommonExpressions , which does not pay attention to modifiers like static or private , can now be used as an alternative for the class DeriveSymTypeOfCommonExpressions","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes_1","text":"Symbols with hierarchical symbol kinds are not serialized multiple times anymore.","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-670","text":"released: 26.01.2021","title":"MontiCore 6.7.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_3","text":"Add new CLI for the MontiCore generator engine","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_4","text":"The context conditions use the new traverser infrastructure. This leads to small changes in the api. The return value of the method addCoCo is void. Attribute fileExt in GlobalScopes now refers to a regular expression for file extensions of symbol table files. The default value of the attribute is \"*sym\", which usually includes symbol files of all MontiCore languages. Attention: If your language used the \"setFileExt\" method in previous versions of MontiCore to set the file extension of the model file (e.g., to \"aut\"), this will cause problems now as the symbol files of the language have differen file extensions (e.g., \"autsym). To fix this, it is sufficient to remove all invocations of \"setFileExt\" from the handwritten source code. For scopes, artifact scopes, and global scopes: Moved abstract methods that do not have a language- specific name or (argument, return) type from language-specific interface to MontiCore-runtime interfaces new experiment \"strules\" demonstrating the use of symbolrules and scoperules deserialize methods in SymTypeExpressionDeSers do not have an enclosingScope argument anymore. Internally, it uses the singleton global scope instead. renamed serializeAdditionalSSymbolAttributes in Symbols2Json class to serializeAddons and moved to scope and symbol DeSers. XScopeDeSer is renamed to XDeSer In Symbols2Json classes: now implementss Visitor2 new attribute \"XTraverser traverser\" with getter and setter Removed attribute \"realThis\" with getter and setter New constructor with two arguments XTraverser and JsonPrinter New zero args constructor Removed constructor with single JsonPrinter argument New attributes of all known symbol DeSers and current scope DeSers New method \"protected void init()\", initializing the DeSer attributes with the GlobalScope and the traverser with symbols2json of inherited languages adjusted store method to use traverser visit methods for symbols delegate to serialize method of the symbol DeSer visit and endVisit methods for scope interface and artifact scope interface print object stub and delegate serialization to scope DeSers DeSers do not have an attribute of Symbols2Json class anymore, instead it is passed as argument in the serialize methods Default values of built-in types that occur in attributes of symbolrules or scoperules are omitted during serialization and deserialization. The defaults are as follows: Boolean : false String : \"\" Numeric types: 0 (and 0L and 0.0 and 0.0f) For symbolrule and scoperule attributes with non-built-in data type, no Log.error is thrown at execution time of the serialize method call anymore. Instead, these methods (and then, their classes as well) are generated abstract to yield compilation errors instead. New interface IDeSer that all symbol and scope DeSers implement. GlobalScopes manage a map with all relevant DeSers. The map maps the serialized (symbol or scope) kind to the DeSer that (de)serialized this kind. This mechanism can be used to exchange the DeSer for a specific kind of symbol or scope. Scope DeSers have new serialize methods without Symbols2Json argment that can be used for for serializing (artifact) scopes for, e.g., unit tests removed the generation of XPhasedSymbolTableCreatorDelegator classes Experiments now use ScopesGenitor-infrastructure instead of SymbolTableCreator-infrastructure","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes_2","text":"The initMe and reset methods of the mill now initialize and reset all attributes properly The CD4Analysis keywords ordered , composition , association , targetimport and classdiagram can be used in grammars again","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-660","text":"released: 03.12.2020","title":"MontiCore 6.6.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_4","text":"The mill of a language now provides a method parser() to get the parser of the language mill initialization allows to reconfigure the mill to provide a parser for a sublanguage parser delegator XForYParser are generated that extend a parser of a super language and delegate to the parser of the current language Due to multiple inheritance, delegation and subclasses are used in combination experiments now showcase the use of traversers add coco (checks if additional attributes are declared twice) added built-in primitive types to the mills of grammars that extend the grammar BasicSymbols. Add to Mill by executing BasicSymbolsMill.initializePrimitives()","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_5","text":"The generated parser uses the builder instead of the factory. This means that in grammars the variable _aNode is no longer available. Use instead _builder . Multiple renamings and signature changes regarding the deser infrastructure renamed XSymbolTablePrinter to XSymbols2Json moved load and store methods form XScopeDeSer to XSymbols2Json removed enclosing scope as method argument of symbol deser methods, as global scope shall be used instead renamed deserializeAdditionalSSymbolAttributes to deserializeAddons renamed deserializeAdditionalXScopeAttributes and deserializeAdditionalXScopeAttributes to deserializeAddons added the JSON printer as a parameter to the methods of XScopeDeSer , SSymbolDeSer und XSymbols2Json XScopeDeSer , SSymbolDeSer und XSymbols2Json are no longer available via the mill. The constructors can be used instead. Scope builder have been removed as they did not support multiple inheritance, scope creation methods of the mill should be used instead Shortened the name of the scope creation methods in the mill from xScope , xGlobalScope and xArtifactScope to scope , globalScope and artifactScope Shortened the name of the modelFileExtension attribute in the XGlobalScope class to fileExt renamed XScopeSkeletonCreator and XScopeSkeletonCreatorDelegator to XScopesGenitor and XScopesGenitorDelegator Deprecated the XPhasedSymbolTableCreatorDelegator , will be removed without replacement in a future release PrettyPrinters and other visitors in monticore-grammar now use the new Traverser infrastructure instead of the old Visitor infrastructure generated XScopeGenitor and XScopeGenitorDelegator now use the new Traverser infrastructure instead of the old Visitor infrastructure Changes to resolving if name of a topLevelSymbol in ArtifactScope = name of ArtifactScope: qualify symbols in spanned scopes of the topLevelSymbol like before with <topLevelSymbolName>.<symbolName> if name of a topLevelSymbol in ArtifactScope != name of ArtifactScope: qualify symbols in spanned scope of the topLevelSymbol with <ArtifactScopeName>.<topLevelSymbolName>.<symbolName> Traverser now support lists of Visitor2 interfaces instead of only one instance Rename accessor of Traverser from addXVisitor to add4X Methods returning referenced symbols save the symbols instead of the surroogates","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes_3","text":"Traverser now properly delegate to handlers as intended ScopeSkeletonCreator now properly use the mill to create scope instances to ensure substitution via the mill pattern Fixed a bug where the SymbolSurrogates wrongly qualified their fullName The clear method of the GlobalScope now deletes all symbols stored in the GlobalScope Serializing symbolrule attributes of Strings now works properly","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-660_1","text":"released: 11.11.2020","title":"MontiCore 6.6.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_5","text":"added an experiment hwDeSers showcasing serialization and deserialization added an experiment hooks showcasing hook point usage IncCheck provided by the MontiCore Gradle Plugin now considers local super grammar changes to trigger new generation Added new Traverser generation to replace the visitor infrastructure in a future release XTraverser XTraverserImplementation XVisitor2 XHandler Added new ScopeSkeletonCreator generation to replace the SymbolTableCreator in a future release and to enable a phased symboltable creation XScopeSkeletonCreator XScopeSkeletonCreatorDelegator XPhasedSymbolTableCreatorDelegator Added methods to directly obtain instances of the following classes in the mill (instead of their builders) XSymbolTableCreator XSymbolTableCreatorDelegator XScopeSkeletonCreator XScopeSkeletonCreatorDelegator XPhasedSymbolTableCreatorDelegator XScopeDeSer XSymbolDeSer XSymbolTablePrinter IXScope IXArtifactScope","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_6","text":"MontiCore now uses Gradle as build tool some tasks have been introduced for the comfortable control of frequent activities, e.g., buildMC , assembleMC that can be found in the build.gradle relocated the EMF related subprojects: monticore-emf-grammar to monticore-grammar-emf monticore-emf-runtime to monticore-runtime-emf relocated integration tests and experiments: monticore-generator/it to monticore-test/it monticore-generator/it/experiments to monticore-test/01.experiments monticore-generator/it/02.experiments to monticore-test/02.experiments monticore-grammar/monticore-grammar-it to monticore-test/monticore-grammar-it Remove the generation of XModelloader . Languages should now use XScopeDeSer to load symbol tables instead. Removed the generation of the following builder classes (also from the Mill, see Additions for alternative solution) XSymbolTableCreatorBuilder XSymbolTableCreatorDelegatorBuilder XScopeDeSerBuilder XSymbolDeSerBuilder XSymbolTablePrinterBuilder renamed IXResolvingDelegate to IXResolver outsourced Type expressions for arrays to a separate grammar was FullGenericTypes , is now MCArrayTypes outsourced initialization for arrays to a separate grammar was MCVarDeclarationStatements , is now MCArrayStatements In a composed language, mills of super languages now provide scope instances (scope, global scope and artifact scope) for the composed language non-existing template paths now result in an error instead of a warning Set current visitor infrastructure to deprecated Integrate new visitor infrastructure (i.e., traverser) into XMill to enable re-usability of visitors via language inheritance Set SymbolTableCreator, SymbolTableCreatorDelegator and their builder to deprecated Integrate new ScopeSkeletonCreator, ScopeSkeletonCreatorDelegator and PhasedSymbolTableCreatorDelegator into Mill Added a method clear to the GlobalScope that clears its cache and its resolvers and empties its ModelPath","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes_4","text":"Fixed that global variable changes in child templates were not changed in parents Fixed handling of optional names of symbols in symbol table creator Fixed an issue where surrogates hide symbol attributes","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-640","text":"released: 12.10.2020","title":"MontiCore 6.4.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_6","text":"extended the generated incCheck files to contain information about local super grammars the sh-file is now able to trigger generation if local super grammars are changed the incCheck method provided by the plugin will support this behavior as well will only be available in the next release extended the mill to manage the global scope instance centrally added comfort methods for creating modifiers to the ModifierBuilder ModifierBuilder().PUBLIC() short for ModifierBuilder().setPublic(true) added MCShadowingJavaBlock to MCCommonStatements standard MCJavaBlock is no longer shadowing added a class diagram to the reports that represents the generated data structure for the given grammar (ast, symbol table visitors, etc.) added simple BreakStatement to MCCommonStatements added an include2 alias for the template controller method for including templates in conjunction with templates arguments","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_7","text":"CLI does no longer check whether a generation is needed (this should be handled by the build tool) rephrased messages for non-conservative extension (added super grammar name) added a context condition to prevent list of names in nonterminal production marked as symbols might be supported in a future version of MontiCore moved XForYMills to a subpackage to reduce noise (subpackage: _auxiliary) deprecated the generated enum f\u00fcr constants will be removed without replacement in a future release moved EnhancedForControl production from JavaLight to MCCommonStatements as it is commonly used standard MCJavaBlock is no longer shadowing renamed BreakStatement in MCLowLevelStatements to LabelledBreakStatement ForStatement now spans a non-exporting, ordered scope shortened generated error codes to have 5 digits only renamed MethOrConstr to JavaMethod in JavaLight MontiCore Gradle plugin is no longer shipped as a fat jar","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes_5","text":"Fixed error code calculation for generated error messages to no longer be random Fixed the report for involved files to contain handwritten files that were considered will only be available in the next release Fixed an issue where reports did not contain meaningful names for elements such as class diagram classes or interfaces","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-630","text":"released: 16.09.2020","title":"MontiCore 6.3.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_7","text":"added @Override annotation for nonterminal production to state that this production overrides a super grammars' production overriding without annotation leads to a warning using the annotation for a production that does not override an existing nonterminal results in an error added a context condition to ensure that external production do not have ast rules added DiagramSymbol in BasicSymbols introduced generated interfaces for GlobalScope and ArtifactScope","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_8","text":"serialization of symtype expression now serializes full name of symtype instead of simple name class ASTNodes is now deprecated and its usages in the generator are removed visitors no longer provide visit methods for concrete scope classes but their interfaces instead SymTypeExpression no longer use surrogates but TypeSymbol s instead reverted changes to appended s for list attributes made in previous release moved initialization of symbols to the endVisit method of the SymbolTableCreator","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes_6","text":"Fixed missing sourcecode position for overriding warning Fixed an issue where the inheritance hierarchy was no considered correctly when overriding a nonterminal","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-620","text":"released: 21.07.2020","title":"MontiCore 6.2.0"},{"location":"00.org/Explanations/CHANGELOG/#additions_8","text":"added isFinal to OOType in OOSymbols extended the mill such that builder for DeSer related classes are provided by the mill added support for symbol usages in NonterminalSeperator example: Bar = (bla:Name@Foo || \",\" )+; added reports for the symbol table structure of the processed grammar added isReadOnly to Variable in BasicSymbols added isElliptic to Method in TypeSymbols added a context condition to warn if keywords consist of numbers only these numbers will be tokenized as keywords instead of numbers added splittoken to express that the listed tokens should be split and not handled as a single token example: splittoken \":::\"; results in three token : added nokeyword to express that the listed keywords should not be handled as tokens example: nokeyword \"automaton\", \"state\"; means that automaton and state should not be handled as keywords introduced symbol inheritance","title":"Additions"},{"location":"00.org/Explanations/CHANGELOG/#changes_9","text":"renamed de.monticore.type.TypeSymbols to de.monticore.symbols.OOSymbols renamed de.monticore.type.BasicTypeSymbols to de.monticore.symbols.BasicSymbols reworked appended s for list attributes renamed SymbolLoader to SymbolSurrogate Surrogates are now subclasses of their corresponding symbols MCJavaBlock in MCCommonStatements now spans a shadowing, non-exporting, ordered scope MethodDeclaration and ConstructorDeclaration in JavaLight use MCJavaBlock instead of MCBlockStatement Label in MCLowLevelStatement now is a symbol VarDecl in MCVarDeclarationStatements no longer exists DeclaratorId now produces FieldSymbol s removed isParameter and isVariable from Field in TypeSymbols the language class is no longer generated moved creator expressions to JavaClassExpression moved PlusExpression and MinusExpression from AssignmentExpressions to CommonExpressions","title":"Changes"},{"location":"00.org/Explanations/CHANGELOG/#fixes_7","text":"Fixed an issue where super and subtype comparison was wrong in type check Fixed handling of capital letters in grammar package * using capital letters now produces a warning * Fixed an issue were setAbsent methods in the generated SymbolBuilder where not properly overridden * Fixed that non-shadowing scopes where not handled as intended","title":"Fixes"},{"location":"00.org/Explanations/CHANGELOG/#monticore-610","text":"released: 07.05.2020","title":"MontiCore 6.1.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-600","text":"Uses CD4Analysis 1.5.0 replace get*opt methods with get* bugfixing","title":"MontiCore 6.0.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-5401","text":"Uses CD4Analysis 1.4.0 add generation of serializers for grammars add SymbolLoader remove SymbolReferences add DeSers for TypeSymbols improved TypeCheck replace getName methods with printType methods","title":"MontiCore 5.4.0.1"},{"location":"00.org/Explanations/CHANGELOG/#monticore-530","text":"Uses CD4Analysis 1.3.20.2 new Generator based on Decorator-Pattern add Translation classes add grammar it-tests move TypesCalculator to TypeCheck, create derive classes and synthesize classes add TypeSymbols and SymTypeExpression structure added DeSers for SymTypeExpressions added keyword \"key\" for KeyTerminals","title":"MontiCore 5.3.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-520","text":"add \"List\"-Suffix to attribute name","title":"MontiCore 5.2.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-510","text":"Remove the dependency to JavaDSL, add JavaLight Uses CD4Analysis 1.3.19 added grammar TypeSymbols renamed SymbolDelegateList to SymbolResolvingDelegateList add methods for scoperule-attributes in interfaces add MCTypeVisitor to transform ASTTypes to TypeExpressions add Groovy Plugin add MontiCore Statements at de.monticore.statements","title":"MontiCore 5.1.0"},{"location":"00.org/Explanations/CHANGELOG/#monticore-506","text":"The IncGen-reports are stored in the source code directory Removed MutableScope IncGen-Reports are stored Removed deprecated keyword ast (use astrule ) in *.mc4 Add visitors for symbol table Enable TOP mechanism for visitors add SymbolRules and ScopeRules renamed MCBasicLiterals to MCCommonLiterals, add MCLiteralsBasis move literals to package de.monticore.literals renamed ShiftExpressions to BitExpressions","title":"MontiCore 5.0.6"},{"location":"00.org/Explanations/CHANGELOG/#monticore-503","text":"Use the following emf coordinates (MB): group: org.eclipse.emf version: 2.15.0 artifact: org.eclipse.emf.ecore | org.eclipse.emf.ecore.xmi | org.eclipse.emf.common The runtime environment may need the following dependency (group: org.eclipse.platform; artifacitId: org.eclipse.equinox.common; version: 3.10.0) splitted Types.mc4 in MCBasicTypes, MCCollectionTypes, MCSimpleGenericTypes and MCFullGenericTypes moved expressions to de.monticore.expressions and added expressions","title":"MontiCore 5.0.3"},{"location":"00.org/Explanations/CHANGELOG/#monticore-502","text":"Generated by the MontiCore version 5.0.1 Uses JavaDSL 4.3.13, Cd4Analysis 1.3.16, se-commons 1.7.9 Introduce deprecated annotation in grammars (#2215) Serialization of symobls Add reporter IncGenCheckReporter Configuration of the report path Specific resolving methods in generated scope classes Bugfixes","title":"MontiCore 5.0.2"},{"location":"00.org/Explanations/CHANGELOG/#monticore-501","text":"Generated by the MontiCore version 5.0.0 Uses JavaDSL 4.3.12, Cd4Analysis 1.3.13, se-commons 1.7.9 Bugfixes New methods defineHookPointWithDefault in GlobalExtensionManagement (MB) new method cmpToken in MCParser (MB) every (non-)terminal defined in an interface must be present in the implementing production (including Name and Usage Name) (CoCo) (BS) to ensure that any terminal (with a specific name) has to be implemented, use an empty string, e.g. interface Expression = operator=\"\"; new methods are generated for the referenced symbol and definition and the definition is saved in an attribute (generated wenn you write sth. like \"Name@Symbol\") (NP) coco that gives a warning if you do not extend conservative (NP) coco that attributes with the same usage Name have to reference the same symbol (NP) SpannedScope and Symbol Methods in ASTNode set to deprecated (NP)","title":"MontiCore 5.0.1"},{"location":"00.org/Explanations/CHANGELOG/#monticore-500","text":"Generated by the MontiCore version 4.5.5.1 Uses JavaDSL 4.3.11, Cd4Analysis 1.3.13, se-commons 1.7.8 Changed name building for list attributes in grammars (x:Name* -> getXList) Changed api for GlobalExtensionMangament and TemplateController (see reference manual) New api for AST nodes (constructor, getter and setter for lists and optional attributes, ...) Builder classes for AST nodes are external now. Signatures are similar to those in the corresponding AST node, except those methods which set or add something, these return the Builder itself (which allows method chaining) Changed default script to noemf for the generation of MontiCore. If you want to use emf you can generate monticore-grammar and Java-DSL with the profile \"emf\". This profile also creates the emf jars. You are also able to test the integration-tests with the profile \u201cemf-it-tests\u201d, which contains extra tests for the generation with emf. Parsed grammars are not stored as class diagram anymore. CD is only stored as report. Removed deprecated method filter(ResolvingInfo resolvingInfo, List symbols) use filter(ResolvingInfo, Collection) instead Removed deprecated method filter(ResolvingInfo resolvingInfo, String name, List symbols) use filter(ResolvingInfo, String, Map) instead Removed deprecated method create(Class symbolClass, SymbolKind symbolKind) use create(SymbolKind) instead Removed deprecated method getSymbols use getLocalSymbols instead Removed deprecated method resolve(SymbolPredicate predicate) use resolveMany(String, SymbolKind, Predicate) instead Removed deprecated method define use add instead Removed deprecated method resolve(ResolvingInfo resolvingInfo, String name, SymbolKind kind, AccessModifier modifier) Removed deprecated method checkIfContinueWithEnclosing use checkIfContinueWithEnclosingScope instead Removed deprecated method addResolver use addFilter(String, ResolvingFilter) instead Removed deprecated method addTopScopeResolver use addDefaultFilter instead Removed deprecated method addTopScopeResolvers use addDefaultFilters instead Removed deprecated method getTopScopeResolvingFilters use getDefaultFilters instead Removed deprecated constructer CommonResolvingFilter(Class symbolClass, SymbolKind targetKind) use CommonResolvingFilter(SymbolKind) instead Removed deprecated method continueWithScope and continueWithEnclosingScope Removed class FaildLoadingSymbol Removed deprecated method putInScopeAndLinkWithAst use addToScopeAndLinkWithNode instead Removed deprecated constructer CommonModelingLanguage(String, String, SymbolKind) use CommonModelingLanguage(String, String) instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method addResolver use addResolvingFilter instead Removed deprecated method getResolvers use getResolvingFilters instead Removed deprecated method loadAmbiguousModelAndCreateSymbolTable use loadModelsIntoScope instead Removed deprecated method loadAmbiguousModels use loadModels instead Removed deprecated method defineHookPoint(String) use glex.defineHookPoint instead Removed deprecated enum ParserExecution Removed deprecated method getParserTarget Removed deprecated method setParserTarget","title":"MontiCore 5.0.0"},{"location":"00.org/Explanations/CHANGELOG/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"00.org/Explanations/FAQ/","text":"FAQ for MontiCore Using Maven Eclipse shows me an error stating that my project configuration is not up-to-date. I get an error saying something about Lifecycle Mappings. Maven build fails because of a missing JDK path. Maven build for de.monticore.parent project fails in eclipse I have a very weird problem, seriously, very weird ... My .m2 folder does not exist. I get a strange error telling me that something is wrong with the UTF8 encoding. Changes I made on one module are not reflected in another module. Eclipse shows me an error stating that my project configuration is not up-to-date. Right-click that project and select Maven -> Update Project Configuration. I get an error saying something about Lifecycle Mappings. Install the m2e extensions mentioned in the developer tutorial. Maven build fails because of a missing JDK path. Change the installed runtime JREs to the installed JDK. Go to Window -> Preferences -> Installed JREs. Add the JDK path and select it to be the default one. Maven build for de.monticore.parent project fails in eclipse. Go to Window -> Preferences -> General -> Workspace. Disable \"Build automatically\" preference. I have a very weird problem, seriously, very weird ... Right-click that project and select Maven -> Update Project Configuration. My .m2 folder does not exist. Folders in Windows with a leading \".\" can only be created using the command line. Start the command line and type in \"mkdir .m2\" in your home folder. I get a strange error telling me that something is wrong with the UTF8 encoding. Change the UTF8 encoding by clicking on Window -> Preferences. Then, select the item as shown below and change the values accordingly. Changes I made on one module are not reflected in another module. Remember that all Maven modules are independent units. By default, they are not directly imported into each other. Instead, Maven resolves dependencies between projects by selecting packages (e.g.jar files) produced by these modules from your local Maven dependency repository. To make the latest version of a module available through this repository, you have to explicitly install it. If you execute an install on an aggregating POM-project, all child modules will be built with the current state of their depending projects as Maven always builds a hierarchy of modules in order of their mutual dependencies. However, if you are working in Eclipse, the workbench can import modules live. This feature is called \"Workspace resolution\" and is enabled by default for Eclipse automatic project builders. Nevertheless, if you build a module using a Run Configuration you have to explicitly activate \"Resolve Workspaces artifacts\". Further Information MontiCore project - MontiCore Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"FAQ"},{"location":"00.org/Explanations/FAQ/#faq-for-monticore","text":"","title":"FAQ for MontiCore"},{"location":"00.org/Explanations/FAQ/#using-maven","text":"Eclipse shows me an error stating that my project configuration is not up-to-date. I get an error saying something about Lifecycle Mappings. Maven build fails because of a missing JDK path. Maven build for de.monticore.parent project fails in eclipse I have a very weird problem, seriously, very weird ... My .m2 folder does not exist. I get a strange error telling me that something is wrong with the UTF8 encoding. Changes I made on one module are not reflected in another module. Eclipse shows me an error stating that my project configuration is not up-to-date. Right-click that project and select Maven -> Update Project Configuration. I get an error saying something about Lifecycle Mappings. Install the m2e extensions mentioned in the developer tutorial. Maven build fails because of a missing JDK path. Change the installed runtime JREs to the installed JDK. Go to Window -> Preferences -> Installed JREs. Add the JDK path and select it to be the default one. Maven build for de.monticore.parent project fails in eclipse. Go to Window -> Preferences -> General -> Workspace. Disable \"Build automatically\" preference. I have a very weird problem, seriously, very weird ... Right-click that project and select Maven -> Update Project Configuration. My .m2 folder does not exist. Folders in Windows with a leading \".\" can only be created using the command line. Start the command line and type in \"mkdir .m2\" in your home folder. I get a strange error telling me that something is wrong with the UTF8 encoding. Change the UTF8 encoding by clicking on Window -> Preferences. Then, select the item as shown below and change the values accordingly. Changes I made on one module are not reflected in another module. Remember that all Maven modules are independent units. By default, they are not directly imported into each other. Instead, Maven resolves dependencies between projects by selecting packages (e.g.jar files) produced by these modules from your local Maven dependency repository. To make the latest version of a module available through this repository, you have to explicitly install it. If you execute an install on an aggregating POM-project, all child modules will be built with the current state of their depending projects as Maven always builds a hierarchy of modules in order of their mutual dependencies. However, if you are working in Eclipse, the workbench can import modules live. This feature is called \"Workspace resolution\" and is enabled by default for Eclipse automatic project builders. Nevertheless, if you build a module using a Run Configuration you have to explicitly activate \"Resolve Workspaces artifacts\".","title":"Using Maven"},{"location":"00.org/Explanations/FAQ/#further-information","text":"MontiCore project - MontiCore Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"00.org/Explanations/StatusOfGrammars/","text":"MontiCore Grammar Status Plans - an Overview MontiCore uses grammars as primary mechanism to describe DSLs and DSL components. The extended grammar format allows to compose language components by (1) inheriting, (2) extending, (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable, can be extended with handwrittten code and most imprtandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . To improve understanding, what will happen with a grammar, we define the following set of stati and mention the status of each grammar, both in the explanation and in the grammar itself: Status of a Grammar MontiCore stable : Such a grammar is meant to be stable in the further development of MontiCore. The grammar is tested and assumed to be of high quality. It may rarely happen that smaller extensions are made in a conservative form, which means that (1) composition with any other grammars, (2) extensions and adaptations and (3) handwritten extensions will still work. Beta: In Stabilization : Such a grammar is in the process of becoming stable. One might already include the grammar, but some changes may still appear. (See task list for potential changes.) Alpha: Intention to become stable : Such a grammar is relatively fresh, but intended to become stable and useful. Changes may occur, e.g. when restructuring or bug fixing. Or it may be taken out of the process and become one of the following: Example : The grammar serves as working example, but will not have high priority on keeping the grammar up to date. One might use it as inspiration for their own developments. Deprecated : The grammar should not be used anymore, it is deprecated, and only there for compatibility. Normally a newer version of the content exists in other, often decomposed grammars, allowing to configure which part of the grammar to be used. Deprecated grammars are not listed in any overview. Marking the Status of Grammars A comment of the following form within the grammar defines this status: /* This is a MontiCore stable grammar. * Adaptations -- if any -- are conservative. */ /* Beta-version: This is intended to become a MontiCore stable grammar. */ /* Alpha-version: This is intended to become a MontiCore stable grammar. */ (but sometimes also omitted) Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"StatusOfGrammars"},{"location":"00.org/Explanations/StatusOfGrammars/#monticore-grammar-status-plans-an-overview","text":"MontiCore uses grammars as primary mechanism to describe DSLs and DSL components. The extended grammar format allows to compose language components by (1) inheriting, (2) extending, (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable, can be extended with handwrittten code and most imprtandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . To improve understanding, what will happen with a grammar, we define the following set of stati and mention the status of each grammar, both in the explanation and in the grammar itself:","title":"MontiCore Grammar Status Plans - an Overview"},{"location":"00.org/Explanations/StatusOfGrammars/#status-of-a-grammar","text":"MontiCore stable : Such a grammar is meant to be stable in the further development of MontiCore. The grammar is tested and assumed to be of high quality. It may rarely happen that smaller extensions are made in a conservative form, which means that (1) composition with any other grammars, (2) extensions and adaptations and (3) handwritten extensions will still work. Beta: In Stabilization : Such a grammar is in the process of becoming stable. One might already include the grammar, but some changes may still appear. (See task list for potential changes.) Alpha: Intention to become stable : Such a grammar is relatively fresh, but intended to become stable and useful. Changes may occur, e.g. when restructuring or bug fixing. Or it may be taken out of the process and become one of the following: Example : The grammar serves as working example, but will not have high priority on keeping the grammar up to date. One might use it as inspiration for their own developments. Deprecated : The grammar should not be used anymore, it is deprecated, and only there for compatibility. Normally a newer version of the content exists in other, often decomposed grammars, allowing to configure which part of the grammar to be used. Deprecated grammars are not listed in any overview.","title":"Status of a Grammar"},{"location":"00.org/Explanations/StatusOfGrammars/#marking-the-status-of-grammars","text":"A comment of the following form within the grammar defines this status: /* This is a MontiCore stable grammar. * Adaptations -- if any -- are conservative. */ /* Beta-version: This is intended to become a MontiCore stable grammar. */ /* Alpha-version: This is intended to become a MontiCore stable grammar. */ (but sometimes also omitted)","title":"Marking the Status of Grammars"},{"location":"00.org/Explanations/StatusOfGrammars/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"00.org/Licenses/LICENSE-BSD3CLAUSE/","text":"Copyright (c) MontiCore*, All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * belongs to RWTH and RIDT","title":"LICENSE BSD3CLAUSE"},{"location":"00.org/Licenses/LICENSE-LGPL/","text":"GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. Additional Definitions. As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License. \"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \"Combined Work\" is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\". The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. Exception to Section 3 of the GNU GPL. You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. Conveying Modified Versions. If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. Object Code Incorporating Material from Library Header Files. The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. Combined Works. You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0. Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1. Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 5d0, the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 5d1, you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) Combined Libraries. You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. Revised Versions of the GNU Lesser General Public License. The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"LICENSE LGPL"},{"location":"00.org/Licenses/LICENSE-LGPL/#gnu-lesser-general-public-license","text":"Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below. Additional Definitions. As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License. \"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below. An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library. A \"Combined Work\" is a work produced by combining or linking an Application with the Library. The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\". The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version. The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work. Exception to Section 3 of the GNU GPL. You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL. Conveying Modified Versions. If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version: a) under this License, provided that you make a good faith effort to ensure that, in the event an Application does not supply the function or data, the facility still operates, and performs whatever part of its purpose remains meaningful, or b) under the GNU GPL, with none of the additional permissions of this License applicable to that copy. Object Code Incorporating Material from Library Header Files. The object code form of an Application may incorporate material from a header file that is part of the Library. You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following: a) Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the object code with a copy of the GNU GPL and this license document. Combined Works. You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following: a) Give prominent notice with each copy of the Combined Work that the Library is used in it and that the Library and its use are covered by this License. b) Accompany the Combined Work with a copy of the GNU GPL and this license document. c) For a Combined Work that displays copyright notices during execution, include the copyright notice for the Library among these notices, as well as a reference directing the user to the copies of the GNU GPL and this license document. d) Do one of the following: 0. Convey the Minimal Corresponding Source under the terms of this License, and the Corresponding Application Code in a form suitable for, and under terms that permit, the user to recombine or relink the Application with a modified version of the Linked Version to produce a modified Combined Work, in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source. 1. Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. e) Provide Installation Information, but only if you would otherwise be required to provide such information under section 6 of the GNU GPL, and only to the extent that such information is necessary to install and execute a modified version of the Combined Work produced by recombining or relinking the Application with a modified version of the Linked Version. (If you use option 5d0, the Installation Information must accompany the Minimal Corresponding Source and Corresponding Application Code. If you use option 5d1, you must provide the Installation Information in the manner specified by section 6 of the GNU GPL for conveying Corresponding Source.) Combined Libraries. You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities, conveyed under the terms of this License. b) Give prominent notice with the combined library that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. Revised Versions of the GNU Lesser General Public License. The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation. If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.","title":"GNU LESSER GENERAL PUBLIC LICENSE"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/","text":"MontiCore 3-Level License Model MontiCore is a language workbench for an efficient development of domain-specific languages (DSLs). All the code available in these GitHub MontiCore projects is published under three levels of licenses as discussed below. For a full use of generated code in commercial and any other forms of projects, the finally generated code is, completely freely available, even though the main workbench itself has restrictions. License Overview The MontiCore Language Workbench deals with three levels of code: (Level 3) MontiCore : the main libary constituting the LWB, (Level 2) tool derivates that are to a large extent generated by the MontiCore LWB, and (Level 1) product code that is finally generated by tool derivates. This also includes analytical results, thus as results of consistency checks, code smells, test infrastructures, etc. Each level has its own and more relaxing license: (Level 1) Product code : when a MontiCore tool derivate is used to generate code, the generated code is absolutely free for each form of use including commercial use without any license and thus without any restriction from MontiCore itself. (Level 2) Tool derivate : when a tool is derived using the MontiCore language workbench, then the result falls under the BSD 3 Clause license (see BSD-3-Clause ). (Level 3) MontiCore : the main LWB components are published in GitHub under the LGPL license (see LGPL V3.0 ). As a consequence using MontiCore during development is rather flexible and the final products do not have any restriction. Please note that this license level model holds for the MontiCore LWB and all related projects published in GitHub. For artefacts available from other sources, different licenses may apply. E.g. developers of tools may impose their own form of restrictions i.e. licenses on their tools respectively the results generated by these tools. Artefacts directly made available from RWTH Aachen and not published in GitHub are for the concretely granted purpose only and are not do be made public at all. MontiCore 3-Level License on Files This repository for the MontiCore language workbench contains three kinds of artifacts: Java-files that are executed in the MontiCore LWB. They are under LGPL licence. Java-files that belong to the runtime environment (RTE) and are thus copied to the generated code. They are under BSD 3 Clause license. Templates executed during generation of tool code. They are also only under BSD 3 Clause license, because parts of them are copied to the generated code. MontiCore 3-Level License on Tool and Language Repositories Other MontiCore repositories contain complete or incomplete tools as well as MontiCore language components. They contains again three kinds of artifacts: Grammars that are used to define language components in the MontiCore LWB. They are under LGPL licence, but these can be extended by own grammars freely. Java-files that are executed in the tool (belonging to the tool RTE). They are under BSD 3 Clause license. Java-files that belong to the product runtime environment (RTE) are completely free without restriction. Templates executed by the tool during generation of product code. They are also are completely free without restriction, because parts of them are copied to the generated code. As a result , a tool derivate (level 2) does not contain any LGPL code , but only BSD 3 Clause code. Executing the tool derivate then produces completely free code (level 1). If questions appear e.g. on using MontiCore itself in a product or building an interpreter, please contact monticore@se-rwth.de. Underlying Licenses The MontiCore 3 Level license is built on: LGPL V3.0 BSD-3-Clause Please also note the general disclaimer from the BSD 3 Clause license on liability, etc. Included Software This product includes the following software, both having their own licenses, compatible with MontiCores licenses: AntLR FreeMarker Further Information see also MontiCore Reference Manual MontiCore project - MontiCore","title":"License"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-model","text":"MontiCore is a language workbench for an efficient development of domain-specific languages (DSLs). All the code available in these GitHub MontiCore projects is published under three levels of licenses as discussed below. For a full use of generated code in commercial and any other forms of projects, the finally generated code is, completely freely available, even though the main workbench itself has restrictions.","title":"MontiCore 3-Level License Model"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#license-overview","text":"The MontiCore Language Workbench deals with three levels of code: (Level 3) MontiCore : the main libary constituting the LWB, (Level 2) tool derivates that are to a large extent generated by the MontiCore LWB, and (Level 1) product code that is finally generated by tool derivates. This also includes analytical results, thus as results of consistency checks, code smells, test infrastructures, etc. Each level has its own and more relaxing license: (Level 1) Product code : when a MontiCore tool derivate is used to generate code, the generated code is absolutely free for each form of use including commercial use without any license and thus without any restriction from MontiCore itself. (Level 2) Tool derivate : when a tool is derived using the MontiCore language workbench, then the result falls under the BSD 3 Clause license (see BSD-3-Clause ). (Level 3) MontiCore : the main LWB components are published in GitHub under the LGPL license (see LGPL V3.0 ). As a consequence using MontiCore during development is rather flexible and the final products do not have any restriction. Please note that this license level model holds for the MontiCore LWB and all related projects published in GitHub. For artefacts available from other sources, different licenses may apply. E.g. developers of tools may impose their own form of restrictions i.e. licenses on their tools respectively the results generated by these tools. Artefacts directly made available from RWTH Aachen and not published in GitHub are for the concretely granted purpose only and are not do be made public at all.","title":"License Overview"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-on-files","text":"This repository for the MontiCore language workbench contains three kinds of artifacts: Java-files that are executed in the MontiCore LWB. They are under LGPL licence. Java-files that belong to the runtime environment (RTE) and are thus copied to the generated code. They are under BSD 3 Clause license. Templates executed during generation of tool code. They are also only under BSD 3 Clause license, because parts of them are copied to the generated code.","title":"MontiCore 3-Level License on Files"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#monticore-3-level-license-on-tool-and-language-repositories","text":"Other MontiCore repositories contain complete or incomplete tools as well as MontiCore language components. They contains again three kinds of artifacts: Grammars that are used to define language components in the MontiCore LWB. They are under LGPL licence, but these can be extended by own grammars freely. Java-files that are executed in the tool (belonging to the tool RTE). They are under BSD 3 Clause license. Java-files that belong to the product runtime environment (RTE) are completely free without restriction. Templates executed by the tool during generation of product code. They are also are completely free without restriction, because parts of them are copied to the generated code. As a result , a tool derivate (level 2) does not contain any LGPL code , but only BSD 3 Clause code. Executing the tool derivate then produces completely free code (level 1). If questions appear e.g. on using MontiCore itself in a product or building an interpreter, please contact monticore@se-rwth.de.","title":"MontiCore 3-Level License on Tool and Language Repositories"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#underlying-licenses","text":"The MontiCore 3 Level license is built on: LGPL V3.0 BSD-3-Clause Please also note the general disclaimer from the BSD 3 Clause license on liability, etc.","title":"Underlying Licenses"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#included-software","text":"This product includes the following software, both having their own licenses, compatible with MontiCores licenses: AntLR FreeMarker","title":"Included Software"},{"location":"00.org/Licenses/LICENSE-MONTICORE-3-LEVEL/#further-information","text":"see also MontiCore Reference Manual MontiCore project - MontiCore","title":"Further Information"},{"location":"docs/BestPractices-CLI/","text":"MontiCore Best Practices - Designing Tools for Command Line Interfaces Some DSLs require a tool to enable general accessibility via the command line interface (CLI). When designing a tool, we recommend some standard guidelines. Designing a Tool The tool provides a general interface for the functionalities developed for a language. This includes all features such as parsing of models, saving and loading of symbol tables, pretty printing, reporting, or export as object diagram. Default Options The available options are of course language-specific. However, we suggest some default arguments for standardized access. -h,--help Prints this help dialog -i,--input <file> Reads the (mandatory) source file resp. the contents of the model -path <dirlist> Sets the artifact path for imported symbols, space separated -modelpath <dirlist> Sets the artifact path for imported models, space separated -pp,--prettyprint <file> Prints the AST to stdout or the specified output file (optional) -s, --symboltable <file> Serializes and prints the symbol table to stdout or the specified output file (optional) -r,--report <dir> Prints reports of the parsed artifact to the specified directory (optional). Available reports are language-specific -o,--output <dir> Path of generated files (optional) -so,--syntaxobjects <file> Prints an object diagram of the AST to stdout or the specified file (optional) -sc,--script <file> Advanced configuration 2: through a groovy script that allows to adapt and extend the tool workflow (optional) (only some tools provide groovy scripting) -ct, --configtemplate Advanced configuration 1: through a Freemarker template that allows to adapt the generation process (optional) (only some tools provide a template configuration call) An example of a complete yet relatively small tool example can be found in the JSON project . Some explanation to the arguments: * The tool is meant for handling one individual model ( -i ) and store the results appropriately in files. * Typical results are * (1) generated files ( -o ) that are used in the next step of the build process (e.g. for compilation). * (2) the symboltable ( -s ) that is then used by other tools to import symbols * (3) reports ( -r ) and internal information ( -so ), like the AST of the parsed model usable for developers to understand what happened * (4) and potentially also internal information on used input and generated output files that allows the calling build script to understand whether a redo is needed (as part of a larger incremental and efficient development process). * Directories in -path are separated via spaces, i.e. each path is an argument on its own. Example: -path a/b x/y . * Directories in the above options -path , -o describe the root structure that is further refined by packages (like in Java). That means with -path a/b x/y the actual symboltable for a Statechart de.mine.Door is found in a/b/de/mine/Door.scsym or x/y/de/mine/Door.scsym (in that order) * Languages typically only load other symbols rather than other models. Therefore, the argument -path that identifies only paths containing symbols should be implemented by most languages, whereas the argument -modelpath for identifying paths containing models is typically not required. * Groovy-scripting ( -sc , --script ): A Groovy Script is meant to describe the tool internal workflow. It controls parsing, symbol construction, reporting, code generation etc. This kind of scripting should only become necessary when various alternative configurations are possible. Thus, not every tool provides Groovy scripting. * Template-scripting ( -ct , --configtemplate ): It is possible to add a custom template script right before the full generation process starts. This template is useful to customize the generation process e.g. by defining hook points and thus injection more templates or switching verbosity on/off. Usage of the Tool-JAR A note to the tool usage: Tools do not organize the correct order of their calls. If embedded in a larger build process, an appropriate gradle (preferred) or make it is useful for incremental efficiency. This organisation is above the tool, due to the efficiency of the (grade or make) buildscript itself, which must be able to decide, whether a redo is needed. If the tool was called to decide that, too much time was already wasted. For a build script to decide whether to call the tool or not, a tool call should (and actually MontiCore does) provide among others a list of files it used for input. Automatically Generating a Tool-JAR Note to the tool development: To automatically derive an executable JAR from the Gradle build process for the corresponding tool, the following template can be used. // all in one tool-jar shadowJar { manifest { attributes \"Main-Class\": \"de.monticore.${archiveBaseName.get().capitalize()}Tool\" } archiveFileName = \"MC${archiveBaseName.get()}.${archiveExtension.get()}\" minimize() archiveClassifier = \"mc-tool\" } jar.dependsOn shadowJar This blueprint can be used in the build.gradle script to derive a JAR for the tool class and its provided command line functionalities. The packed JAR already contains all the necessary dependencies. The template defines the main class and name of the JAR. To foster automated reuse, the template has already been configured to generate a suitable JAR for each language project without manual adjustments. However, this requires adhering to the following conventions: * The name of the main class is equal to the language project name (usually defined in the settings.gradle ) with the suffix Tool . Furthermore, the first letter of the main class is always capitalized to adhere to the Java code conventions * The package of the main class is de.monticore * The generated JAR can be found in 'target/libs' Example: For a language project MyLang we have to implement the MyLangTool.java located in the package de.monticore . This automatically generates the executable JAR MCMyLang.jar In general, the template can be customized by specifying the corresponding main class and JAR name definitions. However, we recommend to use the predefined automatic approach. Functional Approach When implementing the tool, we recommend a functional paradigm to provide the desired functionalities, as the too class is not about data structures but only exists to make functions available. In this case it would be counterproductive to store the arguments of the available functions as attributes. Instead, it makes more sense to pass these arguments as parameters when calling the respective methods. This yields several advantages: Values that have not yet been set do not have to be displayed with Optionals As a result. tedious unwrapping of Optionals with corresponding error messages is no longer necessary get/set methods for attributes are not required Facilitates reusability of modular functions Of course, there are always trade-offs, but a more explicit functional way of thinking should be considered more intensively, especially when it is not about data structures but about the functions. For instance, if intermediate results are stored for efficiency reasons, this might a good argument to do it differently. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"BestPractices CLI"},{"location":"docs/BestPractices-CLI/#monticore-best-practices-designing-tools-for-command-line-interfaces","text":"Some DSLs require a tool to enable general accessibility via the command line interface (CLI). When designing a tool, we recommend some standard guidelines.","title":"MontiCore Best Practices - Designing Tools for Command Line Interfaces"},{"location":"docs/BestPractices-CLI/#designing-a-tool","text":"The tool provides a general interface for the functionalities developed for a language. This includes all features such as parsing of models, saving and loading of symbol tables, pretty printing, reporting, or export as object diagram.","title":"Designing a Tool"},{"location":"docs/BestPractices-CLI/#default-options","text":"The available options are of course language-specific. However, we suggest some default arguments for standardized access. -h,--help Prints this help dialog -i,--input <file> Reads the (mandatory) source file resp. the contents of the model -path <dirlist> Sets the artifact path for imported symbols, space separated -modelpath <dirlist> Sets the artifact path for imported models, space separated -pp,--prettyprint <file> Prints the AST to stdout or the specified output file (optional) -s, --symboltable <file> Serializes and prints the symbol table to stdout or the specified output file (optional) -r,--report <dir> Prints reports of the parsed artifact to the specified directory (optional). Available reports are language-specific -o,--output <dir> Path of generated files (optional) -so,--syntaxobjects <file> Prints an object diagram of the AST to stdout or the specified file (optional) -sc,--script <file> Advanced configuration 2: through a groovy script that allows to adapt and extend the tool workflow (optional) (only some tools provide groovy scripting) -ct, --configtemplate Advanced configuration 1: through a Freemarker template that allows to adapt the generation process (optional) (only some tools provide a template configuration call) An example of a complete yet relatively small tool example can be found in the JSON project . Some explanation to the arguments: * The tool is meant for handling one individual model ( -i ) and store the results appropriately in files. * Typical results are * (1) generated files ( -o ) that are used in the next step of the build process (e.g. for compilation). * (2) the symboltable ( -s ) that is then used by other tools to import symbols * (3) reports ( -r ) and internal information ( -so ), like the AST of the parsed model usable for developers to understand what happened * (4) and potentially also internal information on used input and generated output files that allows the calling build script to understand whether a redo is needed (as part of a larger incremental and efficient development process). * Directories in -path are separated via spaces, i.e. each path is an argument on its own. Example: -path a/b x/y . * Directories in the above options -path , -o describe the root structure that is further refined by packages (like in Java). That means with -path a/b x/y the actual symboltable for a Statechart de.mine.Door is found in a/b/de/mine/Door.scsym or x/y/de/mine/Door.scsym (in that order) * Languages typically only load other symbols rather than other models. Therefore, the argument -path that identifies only paths containing symbols should be implemented by most languages, whereas the argument -modelpath for identifying paths containing models is typically not required. * Groovy-scripting ( -sc , --script ): A Groovy Script is meant to describe the tool internal workflow. It controls parsing, symbol construction, reporting, code generation etc. This kind of scripting should only become necessary when various alternative configurations are possible. Thus, not every tool provides Groovy scripting. * Template-scripting ( -ct , --configtemplate ): It is possible to add a custom template script right before the full generation process starts. This template is useful to customize the generation process e.g. by defining hook points and thus injection more templates or switching verbosity on/off.","title":"Default Options"},{"location":"docs/BestPractices-CLI/#usage-of-the-tool-jar","text":"A note to the tool usage: Tools do not organize the correct order of their calls. If embedded in a larger build process, an appropriate gradle (preferred) or make it is useful for incremental efficiency. This organisation is above the tool, due to the efficiency of the (grade or make) buildscript itself, which must be able to decide, whether a redo is needed. If the tool was called to decide that, too much time was already wasted. For a build script to decide whether to call the tool or not, a tool call should (and actually MontiCore does) provide among others a list of files it used for input.","title":"Usage of the Tool-JAR"},{"location":"docs/BestPractices-CLI/#automatically-generating-a-tool-jar","text":"Note to the tool development: To automatically derive an executable JAR from the Gradle build process for the corresponding tool, the following template can be used. // all in one tool-jar shadowJar { manifest { attributes \"Main-Class\": \"de.monticore.${archiveBaseName.get().capitalize()}Tool\" } archiveFileName = \"MC${archiveBaseName.get()}.${archiveExtension.get()}\" minimize() archiveClassifier = \"mc-tool\" } jar.dependsOn shadowJar This blueprint can be used in the build.gradle script to derive a JAR for the tool class and its provided command line functionalities. The packed JAR already contains all the necessary dependencies. The template defines the main class and name of the JAR. To foster automated reuse, the template has already been configured to generate a suitable JAR for each language project without manual adjustments. However, this requires adhering to the following conventions: * The name of the main class is equal to the language project name (usually defined in the settings.gradle ) with the suffix Tool . Furthermore, the first letter of the main class is always capitalized to adhere to the Java code conventions * The package of the main class is de.monticore * The generated JAR can be found in 'target/libs' Example: For a language project MyLang we have to implement the MyLangTool.java located in the package de.monticore . This automatically generates the executable JAR MCMyLang.jar In general, the template can be customized by specifying the corresponding main class and JAR name definitions. However, we recommend to use the predefined automatic approach.","title":"Automatically Generating a Tool-JAR"},{"location":"docs/BestPractices-CLI/#functional-approach","text":"When implementing the tool, we recommend a functional paradigm to provide the desired functionalities, as the too class is not about data structures but only exists to make functions available. In this case it would be counterproductive to store the arguments of the available functions as attributes. Instead, it makes more sense to pass these arguments as parameters when calling the respective methods. This yields several advantages: Values that have not yet been set do not have to be displayed with Optionals As a result. tedious unwrapping of Optionals with corresponding error messages is no longer necessary get/set methods for attributes are not required Facilitates reusability of modular functions Of course, there are always trade-offs, but a more explicit functional way of thinking should be considered more intensively, especially when it is not about data structures but about the functions. For instance, if intermediate results are stored for efficiency reasons, this might a good argument to do it differently.","title":"Functional Approach"},{"location":"docs/BestPractices-CLI/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/BestPractices-Errors/","text":"MontiCore Best Practices - Understanding Errors, Defining Errors Errors happen. Some happen because of faults in the code (we call that internal errors), some happen because we haven't explained well how to use MontiCore and how to use the generated code. Here we try to add information how to handle occurring errors. We use the error code for an easier identification. Error codes start with 0x and use 5(!) hex characters and thus should be at the same time memorizable (because not completely unknown, but still not so common that they could be taken for something else). Handling Errors 0x..... How to use Expressions (0xA0129) Expression is a predefined nonterminal in the MontiCore basic grammars. Because of the infix notation of some operators and similar challenges, it is usually not possible to use a subset of the expressions only. For example use of ConditionalExpression may lead to a parser generation error (i.e. 0xA0129 ). Solutions: Use nonterminal Expression and forbid all unwanted alternatives through context conditions. Think of allowing more general expressions? If especially the syntax of if . then . else . shall be reused, why not define this in a new nonterminal and ignore that the same syntactic constructs were already available in another production. Defined by: CKi, BR. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"BestPractices Errors"},{"location":"docs/BestPractices-Errors/#monticore-best-practices-understanding-errors-defining-errors","text":"Errors happen. Some happen because of faults in the code (we call that internal errors), some happen because we haven't explained well how to use MontiCore and how to use the generated code. Here we try to add information how to handle occurring errors. We use the error code for an easier identification. Error codes start with 0x and use 5(!) hex characters and thus should be at the same time memorizable (because not completely unknown, but still not so common that they could be taken for something else).","title":"MontiCore Best Practices - Understanding Errors, Defining Errors"},{"location":"docs/BestPractices-Errors/#handling-errors-0x","text":"","title":"Handling Errors 0x....."},{"location":"docs/BestPractices-Errors/#how-to-use-expressions-0xa0129","text":"Expression is a predefined nonterminal in the MontiCore basic grammars. Because of the infix notation of some operators and similar challenges, it is usually not possible to use a subset of the expressions only. For example use of ConditionalExpression may lead to a parser generation error (i.e. 0xA0129 ). Solutions: Use nonterminal Expression and forbid all unwanted alternatives through context conditions. Think of allowing more general expressions? If especially the syntax of if . then . else . shall be reused, why not define this in a new nonterminal and ignore that the same syntactic constructs were already available in another production. Defined by: CKi, BR.","title":"How to use Expressions (0xA0129)"},{"location":"docs/BestPractices-Errors/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/BestPractices-Language-Design/","text":"MontiCore Best Practices - Designing Languages MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. Some general questions on how to design a complete languages are addressed here. Designing A Language Correct language vs. superset? When you know that the incoming model will be correct, because they are generated by algorithm, you can decide to pass a (slight) superset This may simplify the development process for two reasons: (a) you may derive a simpler grammar and (b) you may omit definitions of context conditions. But beware: (a) situations may change and manually changed models might come in or (b) the is adapted by an ill-behaving pre-processor or (c) the model may come in a wrong version. This applies mainly for unreadable languages, such as JSON or XML. Defined by: BR Versioning an evolving language? When languages evolve, models may become invalid, because certain (now obligatory) parts are missing, or old keywords are used. We generally believe that a language that is made for long-lasting models should not embody its version in the models (i.e. like Java, C++ and other GPLs and unlike XML dialects). When evolving a language, you should only evolve it in conservative form, i.e. All new elements are optional by .? , .* or offer new alternatives (old | new) Old elements or keywords are not simply removed, but forbidden by coco warnings, marking them as deprecated for a while. Downward compatibility of newer models, however, is not useful. We can safely enforce developers should normally use the newest versions of their tools. Defined by: BR Language Design in the Large Making Transitively Inherited Grammars Explicit? When the grammar inclusion hierarchy becomes larger, there will be redundancy. In: grammar A { .. } ; grammar B extends A { .. } ; grammar C extends A,B { .. } ; grammar D extends B { .. } ; Grammars C and D actually include the same nonterminals. If A is made explicit, you have more information right at hand, but also larger grammars. It is a matter of taste. A recommendation: when you use nonterminals from A explicitly, then also make the extension explicit. However, be consistent. How to Achieve Modularity (in the Sense of Decoupling) Modularity in general is an important design principle. In the case of model-based code generation, modularity involves the following dimensions: Modelling languages Models Generator Generated code Runtime-Environment (RTE) including imported standard libraries Software architecture (of the overall system), software stack These dimensions are not orthogonal, but also not completely interrelated. The actual organisation will depend on the form of project. A weak form of modularity would be to organize things in well understood substructures such as packages. A deeper form of modularity deals with possibility for individual reuse and thus an explicit decoupling of individual components. We aim for decoupling (even if developed in the same git project). Modularity also deals with extensibility and adaptation . A principle for adaptation for the generator , the generated code , and the RTE is to design each of them like a framework with explicit extension points. Extension points may be (empty) hook methods to be filled, Java interfaces to be implemented and their objects injected to the code e.g., via factories, builders or simply method parameters. A principle for modularity for the generator , the generated code , and the RTE is to design parts of them as independent library functions (or larger: components) that can be used if needed. We recommend to modularize whenever complexity overwhelms or extensibility and adaptability are important: MontiCore has powerful techniques for adaptation, extension and composition of modelling languages (through their grammars). See the reference manual . MontiCore has powerful techniques for the aggregation of models -- using the same principles as programming languages, namely allowing to keep the models independent (and thus storable, versionable, reusable) artifacts, while they are semantically and through the generator technology well integrated. The appropriate approach is based on using foreign models, e.g., through import statements and sharing symbol infrastructures as described in the reference manual . The generator provides (a) many Java classes and methods that can be overridden (b) Freemarker templates hook points to extend and replace templates, and (c) can be customized using a groovy script. The generator itself is often structured along the software architecture / stack, e.g., in frontend, application backend, database, transport layer, etc. The generated code must be designed appropriately by the generator designer, by generating builders, mills, etc. for each form of product - quite similar to MontiCore itself. The generated code is usually structured along the components or sub-systems that the software architecture defines. The RTE is probably well-designed if it is usable in a normal framework. Please note: it is not easy to design modularity and extensibility from beginning. Framework design has shown that this is an iterative optimizing process. It must be avoided to design too many extension elements into the system from the beginning, because this adds a lot of complexity. Defined by: BR Realizing Embedding through an Interface Nonterminal Extension Point Consider the following scenario: A language Host defines an extension point through an interface nonterminal. grammar Host { A = I*; interface I; } Another language Embedded , that has no connection to the Host language, defines a class nonterminal E . grammar Embedded { E = \"something\"; } MontiCore provides alternative solutions to embed the language Embedded into the language Host at the extension point I . All solutions presented here require to implement a new grammar G that extends the grammars Embedded and Host reuses the start nonterminal of the Host grammar: grammar G extends Host, Embedded { start A; } The connection between extension point and extension is performed by an additional grammar rule in the grammar G . This can be realized in one of the following ways each one of which has its own advantages and disadvantages: Embedding through overriding of extension rule and implementing extension point: E implements I; Advantage: simple embedding rule Disadvantage: does not work in combination with inheritance of extension rule Should therefore only be used, if E is not used anywhere else (= in not other language that is potentially used in combination with this language) Embedding through extending extension rule and implementing extension point rule: IE extends E implements I = \"something\"; Advantage: does work in combination with inheritance of extension rule Disadvantage: cloning of RHS of the extension rule can produce inconsistencies if E is changed Can be used if it is assured that this rule is adjusted whenever E is changed, e.g., by assuming that E is not modified at all Embedding through implementing extension point rule and providing extension on right-hand side: IE implements I = E; Advantage: does work in combination with inheritance of extension rule Disadvantage: introduces new level of indirection in the AST that invalidates the check whether the required abstract syntax (RHS of interface nonterminal) is present Should therefore not be used, if the interface has a right-hand side Defined by: AB Recurring Language Components The import statements Many models depend on other models from which they receive symbols they can rely on. To define this kind of dependencies using import statements is convenient and well known (e.g., from Java). We thus suggest to use the import statement in the spirit of Java. import aName at the first sight means that a specific class with the qualified name aName is used. In reality, however, Java has a very convenient convention that class aName is always defined in the artifact (i.e. file) with the same name aName.java and the needed symbol table is part of aName.class . So an import statement actually locates an artifact. As a consequence, we suggest: import aModelName refers to an artifact with name aModelName -- regardless which kind of model is defined there. All the symbols exported by the artifact aModelName are imported when using the import statement import aModelName . The imported artifact provides the desired symbols, typically stored through an earlier tool execution in a symbol file aModelName.sym . The symbol file may have specific extensions, such as autsym or cdsym . Selective import (known from Java), such as import aName.innerClass should be possible, but currently no such showcase has been made yet (beyond Java). The import statement is only used to make symbols available in their simple form. It is usually not intended to explicate a single dependency, e.g., a configuration model that depends on exactly one base model. Like in Java, where you import an artifact and then still explicitly extend the contained class. It is methodically of interest to store at most one artifact with the same qualified name (although it is not per se forbidden to have more). Java then also uses the first occurring class in its classpath only. In a heterogeneous language setting, it may be necessary to map symbols from a source to a target form (e.g., state symbols to Java enum constants or state pattern classes). There are three main options for this task: Store in the desired target symbol form upon creating the symbol file. Has some problems: (1) increases dependencies between tools, (2) potentially several files need to be stored. Adapt the imported symbols upon loading (recommended). Use an explicit transformation tool between the two model processing tools to map the initially stored symbol file to the desired format. Version number in language variants As an important rule: Do not include version numbers in the DSL explicitly. The reason is that whenever you do a tooling update, all the models that have been defined before are suddenly not valid anymore and have to be adapted. Java has very carefully ensured that updates in the language are extensions only and thus all old Java files are still validated with new Java compilers (with the one exception: new keyword assert ). If your language is still very volatile against disruptive changes, it may be an option at the beginning, but should be avoided with the first real release. It is a burden to manage version numbers and downward compatibility through all the versioning, especially if language components evolve with their own versioning. MontiCore provides a theory of conservative extension to avoid explicit version controlling within the language. And if needed: MontiCore and their tools provide extensive checks of wellformedness (i.e. context conditions), on each update a fully automated consistency check of all existing models should be easily establishable. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"BestPractices Language Design"},{"location":"docs/BestPractices-Language-Design/#monticore-best-practices-designing-languages","text":"MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. Some general questions on how to design a complete languages are addressed here.","title":"MontiCore Best Practices - Designing Languages"},{"location":"docs/BestPractices-Language-Design/#designing-a-language","text":"","title":"Designing A Language"},{"location":"docs/BestPractices-Language-Design/#correct-language-vs-superset","text":"When you know that the incoming model will be correct, because they are generated by algorithm, you can decide to pass a (slight) superset This may simplify the development process for two reasons: (a) you may derive a simpler grammar and (b) you may omit definitions of context conditions. But beware: (a) situations may change and manually changed models might come in or (b) the is adapted by an ill-behaving pre-processor or (c) the model may come in a wrong version. This applies mainly for unreadable languages, such as JSON or XML. Defined by: BR","title":"Correct language vs. superset?"},{"location":"docs/BestPractices-Language-Design/#versioning-an-evolving-language","text":"When languages evolve, models may become invalid, because certain (now obligatory) parts are missing, or old keywords are used. We generally believe that a language that is made for long-lasting models should not embody its version in the models (i.e. like Java, C++ and other GPLs and unlike XML dialects). When evolving a language, you should only evolve it in conservative form, i.e. All new elements are optional by .? , .* or offer new alternatives (old | new) Old elements or keywords are not simply removed, but forbidden by coco warnings, marking them as deprecated for a while. Downward compatibility of newer models, however, is not useful. We can safely enforce developers should normally use the newest versions of their tools. Defined by: BR","title":"Versioning an evolving language?"},{"location":"docs/BestPractices-Language-Design/#language-design-in-the-large","text":"","title":"Language Design in the Large"},{"location":"docs/BestPractices-Language-Design/#making-transitively-inherited-grammars-explicit","text":"When the grammar inclusion hierarchy becomes larger, there will be redundancy. In: grammar A { .. } ; grammar B extends A { .. } ; grammar C extends A,B { .. } ; grammar D extends B { .. } ; Grammars C and D actually include the same nonterminals. If A is made explicit, you have more information right at hand, but also larger grammars. It is a matter of taste. A recommendation: when you use nonterminals from A explicitly, then also make the extension explicit. However, be consistent.","title":"Making Transitively Inherited Grammars Explicit?"},{"location":"docs/BestPractices-Language-Design/#how-to-achieve-modularity-in-the-sense-of-decoupling","text":"Modularity in general is an important design principle. In the case of model-based code generation, modularity involves the following dimensions: Modelling languages Models Generator Generated code Runtime-Environment (RTE) including imported standard libraries Software architecture (of the overall system), software stack These dimensions are not orthogonal, but also not completely interrelated. The actual organisation will depend on the form of project. A weak form of modularity would be to organize things in well understood substructures such as packages. A deeper form of modularity deals with possibility for individual reuse and thus an explicit decoupling of individual components. We aim for decoupling (even if developed in the same git project). Modularity also deals with extensibility and adaptation . A principle for adaptation for the generator , the generated code , and the RTE is to design each of them like a framework with explicit extension points. Extension points may be (empty) hook methods to be filled, Java interfaces to be implemented and their objects injected to the code e.g., via factories, builders or simply method parameters. A principle for modularity for the generator , the generated code , and the RTE is to design parts of them as independent library functions (or larger: components) that can be used if needed. We recommend to modularize whenever complexity overwhelms or extensibility and adaptability are important: MontiCore has powerful techniques for adaptation, extension and composition of modelling languages (through their grammars). See the reference manual . MontiCore has powerful techniques for the aggregation of models -- using the same principles as programming languages, namely allowing to keep the models independent (and thus storable, versionable, reusable) artifacts, while they are semantically and through the generator technology well integrated. The appropriate approach is based on using foreign models, e.g., through import statements and sharing symbol infrastructures as described in the reference manual . The generator provides (a) many Java classes and methods that can be overridden (b) Freemarker templates hook points to extend and replace templates, and (c) can be customized using a groovy script. The generator itself is often structured along the software architecture / stack, e.g., in frontend, application backend, database, transport layer, etc. The generated code must be designed appropriately by the generator designer, by generating builders, mills, etc. for each form of product - quite similar to MontiCore itself. The generated code is usually structured along the components or sub-systems that the software architecture defines. The RTE is probably well-designed if it is usable in a normal framework. Please note: it is not easy to design modularity and extensibility from beginning. Framework design has shown that this is an iterative optimizing process. It must be avoided to design too many extension elements into the system from the beginning, because this adds a lot of complexity. Defined by: BR","title":"How to Achieve Modularity (in the Sense of Decoupling)"},{"location":"docs/BestPractices-Language-Design/#realizing-embedding-through-an-interface-nonterminal-extension-point","text":"Consider the following scenario: A language Host defines an extension point through an interface nonterminal. grammar Host { A = I*; interface I; } Another language Embedded , that has no connection to the Host language, defines a class nonterminal E . grammar Embedded { E = \"something\"; } MontiCore provides alternative solutions to embed the language Embedded into the language Host at the extension point I . All solutions presented here require to implement a new grammar G that extends the grammars Embedded and Host reuses the start nonterminal of the Host grammar: grammar G extends Host, Embedded { start A; } The connection between extension point and extension is performed by an additional grammar rule in the grammar G . This can be realized in one of the following ways each one of which has its own advantages and disadvantages: Embedding through overriding of extension rule and implementing extension point: E implements I; Advantage: simple embedding rule Disadvantage: does not work in combination with inheritance of extension rule Should therefore only be used, if E is not used anywhere else (= in not other language that is potentially used in combination with this language) Embedding through extending extension rule and implementing extension point rule: IE extends E implements I = \"something\"; Advantage: does work in combination with inheritance of extension rule Disadvantage: cloning of RHS of the extension rule can produce inconsistencies if E is changed Can be used if it is assured that this rule is adjusted whenever E is changed, e.g., by assuming that E is not modified at all Embedding through implementing extension point rule and providing extension on right-hand side: IE implements I = E; Advantage: does work in combination with inheritance of extension rule Disadvantage: introduces new level of indirection in the AST that invalidates the check whether the required abstract syntax (RHS of interface nonterminal) is present Should therefore not be used, if the interface has a right-hand side Defined by: AB","title":"Realizing Embedding through an Interface Nonterminal Extension Point"},{"location":"docs/BestPractices-Language-Design/#recurring-language-components","text":"","title":"Recurring Language Components"},{"location":"docs/BestPractices-Language-Design/#the-import-statements","text":"Many models depend on other models from which they receive symbols they can rely on. To define this kind of dependencies using import statements is convenient and well known (e.g., from Java). We thus suggest to use the import statement in the spirit of Java. import aName at the first sight means that a specific class with the qualified name aName is used. In reality, however, Java has a very convenient convention that class aName is always defined in the artifact (i.e. file) with the same name aName.java and the needed symbol table is part of aName.class . So an import statement actually locates an artifact. As a consequence, we suggest: import aModelName refers to an artifact with name aModelName -- regardless which kind of model is defined there. All the symbols exported by the artifact aModelName are imported when using the import statement import aModelName . The imported artifact provides the desired symbols, typically stored through an earlier tool execution in a symbol file aModelName.sym . The symbol file may have specific extensions, such as autsym or cdsym . Selective import (known from Java), such as import aName.innerClass should be possible, but currently no such showcase has been made yet (beyond Java). The import statement is only used to make symbols available in their simple form. It is usually not intended to explicate a single dependency, e.g., a configuration model that depends on exactly one base model. Like in Java, where you import an artifact and then still explicitly extend the contained class. It is methodically of interest to store at most one artifact with the same qualified name (although it is not per se forbidden to have more). Java then also uses the first occurring class in its classpath only. In a heterogeneous language setting, it may be necessary to map symbols from a source to a target form (e.g., state symbols to Java enum constants or state pattern classes). There are three main options for this task: Store in the desired target symbol form upon creating the symbol file. Has some problems: (1) increases dependencies between tools, (2) potentially several files need to be stored. Adapt the imported symbols upon loading (recommended). Use an explicit transformation tool between the two model processing tools to map the initially stored symbol file to the desired format.","title":"The import statements"},{"location":"docs/BestPractices-Language-Design/#version-number-in-language-variants","text":"As an important rule: Do not include version numbers in the DSL explicitly. The reason is that whenever you do a tooling update, all the models that have been defined before are suddenly not valid anymore and have to be adapted. Java has very carefully ensured that updates in the language are extensions only and thus all old Java files are still validated with new Java compilers (with the one exception: new keyword assert ). If your language is still very volatile against disruptive changes, it may be an option at the beginning, but should be avoided with the first real release. It is a burden to manage version numbers and downward compatibility through all the versioning, especially if language components evolve with their own versioning. MontiCore provides a theory of conservative extension to avoid explicit version controlling within the language. And if needed: MontiCore and their tools provide extensive checks of wellformedness (i.e. context conditions), on each update a fully automated consistency check of all existing models should be easily establishable.","title":"Version number in language variants"},{"location":"docs/BestPractices-Language-Design/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/BestPractices-Symbols-Scopes/","text":"MontiCore Best Practices - Symbols, Scopes, Symboltables MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. The newest MontiCore release gives powerful capabilities to define and use symbols. Symbols, scopes, and symboltables are somewhat complex to design, but powerful in their use. Designing Symbols, Scopes and SymbolTables How to define a Symbol Usage without a given Symbol Definition grammar E { A = Name@S; symbol S = Name; } If you want to use a special form of symbol that shall neither be defined inside the grammar of a language, nor shall it be imported. We can define symbols of kind S in the grammar in a grammar rule that is never reached by the parser from the start production. Through this, MontiCore generates: symbol table infrastructure for handling S symbols symbol table infrastructure for resolving these in E scopes, and integration of S symbols with the AST of A . However, S symbols are not automatically instantiated. This has to be described manually, e.g., by extending the symbol table creator or via providing an adapter translating a foreign symbol into an S symbol. This can be used, e.g., in these scenarios: A name of a certain kind is introduced automatically the first time it occurs in a model. If it occurs more than once, all other occurrences of the name do not introduce new symbols. (e.g., this happens with features in FDs, and works because features do not have a body.) A name in a language E refers to a named element of another language, but the language shall be decoupled from E . Therefore, E introduces a symbol S and an adapter maps other, foreign symbols to S symbols. Defined by: AB, BR Symbol Definition prepared for Reuse grammar E { symbol Bla = \"bla\" Name AnotherNT; } * has the effect that three things are defined: (a) concrete syntax, abstract syntax with (b) AST element ASTBla and (c) a symbol BlaSymbol . * Reuse of the symbol BlaSymbol currently only works together with a reuse of the syntax too, i.e. grammar F extends E { Blubb extends Bla = \"blubb\" Name; } would for example be illegal, because the conservative extension paradigm enforces AnotherNT to be included in Blubb as well. * To allow individual reuse of symbol BlaSymbol we recommend to restructure its definition into an interface that does not preclude create syntax and only a minimal constraint on the abstract syntax: grammar E { symbol interface Bla = Name; Bla2 implements Bla = \"bla\" Name AnotherNT; } grammar F extends E { Blubb implements Bla = \"blubb\" Name; } Please note that MontiCore allows that a nonterminal implements multiple interfaces. However, only one of them may carry the symbol keyboard property, because the newly defined symbol then is also a subclass of the inherited symbol (in Java). Loading (DeSerializing) Symbols of Unknown Symbol Kinds Specific languages (e.g., CD ) may provide specific symbols, of specific kinds. A symbol import of these symbols into another language L1 has to cope with potentially unknown kinds of symbols, even though the super kind could be known. E.g., TypeSymbol is extended by CDTypeSymbol providing e.g., additional visibility information. Upon loading an CD -symboltable into an L1 -tool it may be that neither AST-class CDTypeSymbol nor superclass information about it is available. But, the symbols of the unknown kind should (and can) be loaded as symbols of a more abstract kind. Loading the symbols of the unknown kind as symbols of the specific known kind is possible in multiple ways. Options would be 1. adapt the L1 -tool to know about the new symbols, or 2. the L1 -tool has been written in such a way that new classes can be added through appropriate class loading, or 3. the L1 -tool is configurable in handling unknown symbol kinds as explained below. Loading Symbols as Symbols of Another Kind Symbols of an unknown source kind (e.g., CDTypeSymbol ) may easily be loaded as symbols of a known kind (e.g., TypeSymbol ) when the source kind provides all mandatory attributes (i.e. those without defaults) of the symbol class. This is especially the case if the source kind is a subclass of the known kind. This behavior can be configured in the global scope by calling the method putSymbolDeser(String, ISymbolDeser) , where the unknown source kind is encoded as string (here: CDTypeSymbol ) and is mapped to an appropriate DeSer (here for TypeSymbol ). For instance the call would be putSymbolDeSer(\"de.monticore.cdbasis._symboltable.CDTypeSymbol\", new TypeSymbolDeSer()) . Because the global scope is a singleton, this configuration can be e.g., called in or shortly after constructing the global scope. However, this would still encode the name of the unknown symbol kind in the L1 -tool, although it prevents any actual dependency to the imported tools. The method can also be called from a CLI to dynamically configure the deserialization, e.g., the information be fed to the L1 -tool via parameters, e.g., like java L2Tool --typeSymbol=de.monticore.cdbasis._symboltable.CDTypeSymbol --functionSymbol=de.monticore.cdbasis._symboltable.CDMethodSymbol Converting Stored Symbol Tables If the unknown symbol kinds do have different attributes or some extra information needs to be calculated in the new symbols, then either the L1 -tool needs to be adapted or the serialized symbol table can be transformed to another serialized symbol table where the kind information is transformed as required as an intermediate step between the tools providing and reading the symbol tables. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"BestPractices Symbols Scopes"},{"location":"docs/BestPractices-Symbols-Scopes/#monticore-best-practices-symbols-scopes-symboltables","text":"MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. The newest MontiCore release gives powerful capabilities to define and use symbols. Symbols, scopes, and symboltables are somewhat complex to design, but powerful in their use.","title":"MontiCore Best Practices - Symbols, Scopes, Symboltables"},{"location":"docs/BestPractices-Symbols-Scopes/#designing-symbols-scopes-and-symboltables","text":"","title":"Designing Symbols, Scopes and SymbolTables"},{"location":"docs/BestPractices-Symbols-Scopes/#how-to-define-a-symbol-usage-without-a-given-symbol-definition","text":"grammar E { A = Name@S; symbol S = Name; } If you want to use a special form of symbol that shall neither be defined inside the grammar of a language, nor shall it be imported. We can define symbols of kind S in the grammar in a grammar rule that is never reached by the parser from the start production. Through this, MontiCore generates: symbol table infrastructure for handling S symbols symbol table infrastructure for resolving these in E scopes, and integration of S symbols with the AST of A . However, S symbols are not automatically instantiated. This has to be described manually, e.g., by extending the symbol table creator or via providing an adapter translating a foreign symbol into an S symbol. This can be used, e.g., in these scenarios: A name of a certain kind is introduced automatically the first time it occurs in a model. If it occurs more than once, all other occurrences of the name do not introduce new symbols. (e.g., this happens with features in FDs, and works because features do not have a body.) A name in a language E refers to a named element of another language, but the language shall be decoupled from E . Therefore, E introduces a symbol S and an adapter maps other, foreign symbols to S symbols. Defined by: AB, BR","title":"How to define a Symbol Usage without a given Symbol Definition"},{"location":"docs/BestPractices-Symbols-Scopes/#symbol-definition-prepared-for-reuse","text":"grammar E { symbol Bla = \"bla\" Name AnotherNT; } * has the effect that three things are defined: (a) concrete syntax, abstract syntax with (b) AST element ASTBla and (c) a symbol BlaSymbol . * Reuse of the symbol BlaSymbol currently only works together with a reuse of the syntax too, i.e. grammar F extends E { Blubb extends Bla = \"blubb\" Name; } would for example be illegal, because the conservative extension paradigm enforces AnotherNT to be included in Blubb as well. * To allow individual reuse of symbol BlaSymbol we recommend to restructure its definition into an interface that does not preclude create syntax and only a minimal constraint on the abstract syntax: grammar E { symbol interface Bla = Name; Bla2 implements Bla = \"bla\" Name AnotherNT; } grammar F extends E { Blubb implements Bla = \"blubb\" Name; } Please note that MontiCore allows that a nonterminal implements multiple interfaces. However, only one of them may carry the symbol keyboard property, because the newly defined symbol then is also a subclass of the inherited symbol (in Java).","title":"Symbol Definition prepared for Reuse"},{"location":"docs/BestPractices-Symbols-Scopes/#loading-deserializing-symbols-of-unknown-symbol-kinds","text":"Specific languages (e.g., CD ) may provide specific symbols, of specific kinds. A symbol import of these symbols into another language L1 has to cope with potentially unknown kinds of symbols, even though the super kind could be known. E.g., TypeSymbol is extended by CDTypeSymbol providing e.g., additional visibility information. Upon loading an CD -symboltable into an L1 -tool it may be that neither AST-class CDTypeSymbol nor superclass information about it is available. But, the symbols of the unknown kind should (and can) be loaded as symbols of a more abstract kind. Loading the symbols of the unknown kind as symbols of the specific known kind is possible in multiple ways. Options would be 1. adapt the L1 -tool to know about the new symbols, or 2. the L1 -tool has been written in such a way that new classes can be added through appropriate class loading, or 3. the L1 -tool is configurable in handling unknown symbol kinds as explained below.","title":"Loading (DeSerializing) Symbols of Unknown Symbol Kinds"},{"location":"docs/BestPractices-Symbols-Scopes/#loading-symbols-as-symbols-of-another-kind","text":"Symbols of an unknown source kind (e.g., CDTypeSymbol ) may easily be loaded as symbols of a known kind (e.g., TypeSymbol ) when the source kind provides all mandatory attributes (i.e. those without defaults) of the symbol class. This is especially the case if the source kind is a subclass of the known kind. This behavior can be configured in the global scope by calling the method putSymbolDeser(String, ISymbolDeser) , where the unknown source kind is encoded as string (here: CDTypeSymbol ) and is mapped to an appropriate DeSer (here for TypeSymbol ). For instance the call would be putSymbolDeSer(\"de.monticore.cdbasis._symboltable.CDTypeSymbol\", new TypeSymbolDeSer()) . Because the global scope is a singleton, this configuration can be e.g., called in or shortly after constructing the global scope. However, this would still encode the name of the unknown symbol kind in the L1 -tool, although it prevents any actual dependency to the imported tools. The method can also be called from a CLI to dynamically configure the deserialization, e.g., the information be fed to the L1 -tool via parameters, e.g., like java L2Tool --typeSymbol=de.monticore.cdbasis._symboltable.CDTypeSymbol --functionSymbol=de.monticore.cdbasis._symboltable.CDMethodSymbol","title":"Loading Symbols as Symbols of Another Kind"},{"location":"docs/BestPractices-Symbols-Scopes/#converting-stored-symbol-tables","text":"If the unknown symbol kinds do have different attributes or some extra information needs to be calculated in the new symbols, then either the L1 -tool needs to be adapted or the serialized symbol table can be transformed to another serialized symbol table where the kind information is transformed as required as an intermediate step between the tools providing and reading the symbol tables.","title":"Converting Stored Symbol Tables"},{"location":"docs/BestPractices-Symbols-Scopes/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/BestPractices-Syntax-Design/","text":"MontiCore Best Practices - Concrete and Abstract Syntax MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specific advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. This file is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual. Designing Concrete and Abstract Syntax Specific keywords that shall be used as normal names elsewhere A = \"foo\" B introduces foo as a keyword that cannot be used as an ordinary (variable) name anymore. To prevent that we may use: A = key(\"foo\") B instead, which introduces foo only at that specific point. In general, we use all Java keywords as permanent, but abstain from other permanent keywords, especially if they are only used for a specific purpose in a composable sublanguage, like in in the OCL. Defined by: BR Complex Token clashing with other uses of sub-tokens For example <- is supposed to be used as arrow, but in an expression 3<-10 is also syntactically allowed. The problem: as soon as \"<-\" is defined as a token in any part of the current or any extended grammars, the expression 3<-10 would not be parsed as 3 < -10 anymore. Solutions: We might decompose the token to \"<\" \"-\" which in its consequence means that we put more burden to the context-free parser and less to the regular scanner. (\"scannerless parsing\") Drawback: spaces would now be allowed inbetween. Decompose the token to {noSpace(2)}? \"<\" \"-\" . This (slightly hacking approach) prevents spaces between two tokens. The challenge: when designing a language component, we don't know yet what further uses will bring. This may include sub-tokens to come up with new interactions. This would require an (already defined) grammar with the complex token to be adapted afterwards (and thus conflict with the library idea). Remark: A forthcoming enhancement will provide an improved solution, keeping parsing efficiency and compositionality of grammars. Defined by: BR Extension forms in a component grammar A component grammar is meant for extension. MontiCore therefore provides five(!) mechanisms that can be used when a sub-grammar shall extend a super-grammar. The solutions are briefly discussed here: 1. Interface in the super-grammar * Introduce an interface and allow building of sub-nonterminals in sub-grammars. component grammar A { interface X; N = \"bla\" X \"blubb\"; } grammar B extends A { Y implements X = \"specific\" \"thing\" } * Advantage: Multiple extensions are possible at the same time. An NT Y can also implement multiple interfaces (like in Java). * Disadvantage: the designer of A explicitly has to design the hole (extension point) X and add it into the production. 2. Overriding (empty) nonterminal from the super-grammar * Use a normal nonterminal X and override it in a sub-grammar. component grammar A { X = \"\"; N = \"bla\" X \"blubb\"; } grammar B extends A { @Override X = \"my\" \"thing\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: 1. The designer of A explicitly has to design the hole (extension point) X and inject it into other places. 2. Only one overriding alternative possible (i.e. multiple overriding in subgrammars are allowed, but only the most specific resides). 3. Extending nonterminal from the super-grammar. * Use an empty normal nonterminal X and extend it in a sub-grammar. component grammar A { X = ; N = \"bla\" X \"blubb\"; } grammar B extends A { Y extends X = \"this\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: The designer of A explicitly has to design the hole (extension point) X and inject it into other places. * Care: Extension still allows the (empty) alternative X . 4. Using external nonterminals in the super-grammar. * Mark nonterminal X as external. component grammar A { external X; N = \"bla\" X \"blubb\"; } grammar B extends A { X = \"your\"; } * Advantage: Explicitely marks a nonterminal as hole (extension point) in the grammar. Please observe that interface terminals may or not may be meant to be extended in sub-grammars. external is clearer here. * Disadvantage: 1. Leads to more objects in the AST. Both classes a.X and b.X are instantiated and a.X only links to b.X . 2. Only one filling of the hole is possible. Overriding the whole production. If you don't want to add a hole at any possible place of extension: component grammar A { N = \"bla\" \"blubb\"; } grammar B extends A { @Override N = \"bla\" \"my\" \"blubb\" \"now\"; } Advantage: Compact definition. No \" framework thinking \" needed (no need to forecast all potential extension points) Disadvantage: The entire production is overriden (some redundancy). Only one overriding alternative possible. Combinations are possible. Dependent on the anticipated forms of adaptations option 1, 2, 3 and 5 are in use. Defined by: BR Avoid empty nonterminals (if body is known) From the two variants: A = \"bla\" B? C*; B = \"B's body\" ; C = \"C's body\" ; and A = \"bla\" B C; B = (\"B's body\")? ; C = (\"C's body\")* ; we generally prefer the first one, i.e. add multiplicities when using a nonterminal. This is a matter of taste, but useful to keep this consistent. Sometimes exceptions are useful. Defined by: SVa, BR Avoid complex tokens (1) The token definitions can only define regular expressions. Furthermore, the token parser (i.e. the lexer) does not consider backtracking. If combinations of characters may be split into several token sequences this leads to problems. E.g. in 3-2 and (-2) the - has different roles. Unfortunately these problems also occur when composing languages that make excessive use of (conflicting) token definitions. Solution: instead of defining a complex token like token NegativeNat = \"-\" Digits; we split the token and allow individual parsing into nonterminals: NegativeNat = negative:[\"-\"] Digits {noSpace()}? (where we assume Digits is a given token). As a workaround, we use the semantic predicate {noSpace()}? that ensures that between the two last processed token there is no space inbetween. If one of the tokens is optional we have to split the alternatives: SignedNatLiteral = (negative:[\"-\"]) Digits {noSpace()}? | Digits ; Adding a handcoded function like getValue() via astrule or the TOP-mechanism allows to use SignedNatLiteral like a token. Scannerless parsing is a principle where the tokens are reduced to simple characters (or character classes, such as [a-z] ). Scannerless parsing generally avoids this kinds of problems, but is way slower. This kind of solution tries to mediate between the two extremes benefitting from both approaches. Defined by: MB, in: MCCommonLiterals.mc4 and other literals grammars. Avoid complex tokens (2) Same general problem. In language composition conflicting tokens may lead to issues. For example Java allows 42. as a literal of type float. UML allows to define cardinalities like [42..44] . Composition clashes. Solution: In a Java sublanguage we split the token: SignedBasicFloatLiteral = ... | Digits \".\" {noSpace()}? ... ; This will ensure that [42..44] will be parsed like [ 42 .. 44 ] in a language composition as well. It generally seems that overly complex composed tokens may lead to issues especially if the language allows compact models. Suboptimal tokens may be e.g. \"[[\" (vs. nested lists), or \"<-\" (vs. 3 < -2 ). Defined by: MC team. How to define keyword enumerations A finite set of keyword-based alternatives can be defined in several forms: Standard three keywords act as alternative: N = ([\"public\"] | [\"protected\"] | [\"private\"]) ; Effects: not extensible without overriding and repetition introduces boolean flags, where only one can be true at a time Use an enumeration nonterminal enumeration E = \"public\" | \"protected\" | \"private\" ; N = E ; Effects: not extensible Use an interface and subclasses with almost empty body: interface E ; P1 implements E = \"public\" ; P2 implements E = \"protected\" ; P3 implements E = \"private\" ; N = E ; Effects: very extensible in various ways (even beyond mere keywords) visitor can easily address the keywords (i.e. by visit(P1) ...) Disadvantage: Clumsy notation and visitors are always needed. Defined by: SVa, BR. Common AST-Access to Syntactically Similar Nonterminals Sometimes the following occurs (e.g. in associations of CDs or interactions of SD): A = X Y Z; B = Z Y X; The concrete syntax differs (in order), but the syntactic concepts are the same. To allow common access, a common interface nonterminal is introduced that is not used in the grammar directly. This doesn't change the concrete syntax but allows common AST access: interface F = X Y Z; // order is irrelevant A implements F = X Y Z; B implements F = Z Y X; Defined by: BR. How and when to use Names for Nonterminals Normally names like expr:Expr can be avoided which makes a grammar easier to read and more concise, i.e. Expr alone has the same effect. There may be two reasons to use a name: Nonterminal X occurs several times and we want to distinguish: left:Expr \"*\" right:Expr We can also use the name to describe the purpose of the nonterminal, i.e. MyVariable implements Variable = Name \"=\" initial:Expression; vs: MyParameter implements Variable = Name \"=\" default:Expression; Defined by: BR. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"BestPractices Syntax Design"},{"location":"docs/BestPractices-Syntax-Design/#monticore-best-practices-concrete-and-abstract-syntax","text":"MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specific advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. This file is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual.","title":"MontiCore Best Practices - Concrete and Abstract Syntax"},{"location":"docs/BestPractices-Syntax-Design/#designing-concrete-and-abstract-syntax","text":"","title":"Designing Concrete and Abstract Syntax"},{"location":"docs/BestPractices-Syntax-Design/#specific-keywords-that-shall-be-used-as-normal-names-elsewhere","text":"A = \"foo\" B introduces foo as a keyword that cannot be used as an ordinary (variable) name anymore. To prevent that we may use: A = key(\"foo\") B instead, which introduces foo only at that specific point. In general, we use all Java keywords as permanent, but abstain from other permanent keywords, especially if they are only used for a specific purpose in a composable sublanguage, like in in the OCL. Defined by: BR","title":"Specific keywords that shall be used as normal names elsewhere"},{"location":"docs/BestPractices-Syntax-Design/#complex-token-clashing-with-other-uses-of-sub-tokens","text":"For example <- is supposed to be used as arrow, but in an expression 3<-10 is also syntactically allowed. The problem: as soon as \"<-\" is defined as a token in any part of the current or any extended grammars, the expression 3<-10 would not be parsed as 3 < -10 anymore. Solutions: We might decompose the token to \"<\" \"-\" which in its consequence means that we put more burden to the context-free parser and less to the regular scanner. (\"scannerless parsing\") Drawback: spaces would now be allowed inbetween. Decompose the token to {noSpace(2)}? \"<\" \"-\" . This (slightly hacking approach) prevents spaces between two tokens. The challenge: when designing a language component, we don't know yet what further uses will bring. This may include sub-tokens to come up with new interactions. This would require an (already defined) grammar with the complex token to be adapted afterwards (and thus conflict with the library idea). Remark: A forthcoming enhancement will provide an improved solution, keeping parsing efficiency and compositionality of grammars. Defined by: BR","title":"Complex Token clashing with other uses of sub-tokens"},{"location":"docs/BestPractices-Syntax-Design/#extension-forms-in-a-component-grammar","text":"A component grammar is meant for extension. MontiCore therefore provides five(!) mechanisms that can be used when a sub-grammar shall extend a super-grammar. The solutions are briefly discussed here: 1. Interface in the super-grammar * Introduce an interface and allow building of sub-nonterminals in sub-grammars. component grammar A { interface X; N = \"bla\" X \"blubb\"; } grammar B extends A { Y implements X = \"specific\" \"thing\" } * Advantage: Multiple extensions are possible at the same time. An NT Y can also implement multiple interfaces (like in Java). * Disadvantage: the designer of A explicitly has to design the hole (extension point) X and add it into the production. 2. Overriding (empty) nonterminal from the super-grammar * Use a normal nonterminal X and override it in a sub-grammar. component grammar A { X = \"\"; N = \"bla\" X \"blubb\"; } grammar B extends A { @Override X = \"my\" \"thing\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: 1. The designer of A explicitly has to design the hole (extension point) X and inject it into other places. 2. Only one overriding alternative possible (i.e. multiple overriding in subgrammars are allowed, but only the most specific resides). 3. Extending nonterminal from the super-grammar. * Use an empty normal nonterminal X and extend it in a sub-grammar. component grammar A { X = ; N = \"bla\" X \"blubb\"; } grammar B extends A { Y extends X = \"this\"; } * Advantage: Default implementation \"\" exists, no explicit filling needed. * Disadvantage: The designer of A explicitly has to design the hole (extension point) X and inject it into other places. * Care: Extension still allows the (empty) alternative X . 4. Using external nonterminals in the super-grammar. * Mark nonterminal X as external. component grammar A { external X; N = \"bla\" X \"blubb\"; } grammar B extends A { X = \"your\"; } * Advantage: Explicitely marks a nonterminal as hole (extension point) in the grammar. Please observe that interface terminals may or not may be meant to be extended in sub-grammars. external is clearer here. * Disadvantage: 1. Leads to more objects in the AST. Both classes a.X and b.X are instantiated and a.X only links to b.X . 2. Only one filling of the hole is possible. Overriding the whole production. If you don't want to add a hole at any possible place of extension: component grammar A { N = \"bla\" \"blubb\"; } grammar B extends A { @Override N = \"bla\" \"my\" \"blubb\" \"now\"; } Advantage: Compact definition. No \" framework thinking \" needed (no need to forecast all potential extension points) Disadvantage: The entire production is overriden (some redundancy). Only one overriding alternative possible. Combinations are possible. Dependent on the anticipated forms of adaptations option 1, 2, 3 and 5 are in use. Defined by: BR","title":"Extension forms in a  component grammar"},{"location":"docs/BestPractices-Syntax-Design/#avoid-empty-nonterminals-if-body-is-known","text":"From the two variants: A = \"bla\" B? C*; B = \"B's body\" ; C = \"C's body\" ; and A = \"bla\" B C; B = (\"B's body\")? ; C = (\"C's body\")* ; we generally prefer the first one, i.e. add multiplicities when using a nonterminal. This is a matter of taste, but useful to keep this consistent. Sometimes exceptions are useful. Defined by: SVa, BR","title":"Avoid empty nonterminals (if body is known)"},{"location":"docs/BestPractices-Syntax-Design/#avoid-complex-tokens-1","text":"The token definitions can only define regular expressions. Furthermore, the token parser (i.e. the lexer) does not consider backtracking. If combinations of characters may be split into several token sequences this leads to problems. E.g. in 3-2 and (-2) the - has different roles. Unfortunately these problems also occur when composing languages that make excessive use of (conflicting) token definitions. Solution: instead of defining a complex token like token NegativeNat = \"-\" Digits; we split the token and allow individual parsing into nonterminals: NegativeNat = negative:[\"-\"] Digits {noSpace()}? (where we assume Digits is a given token). As a workaround, we use the semantic predicate {noSpace()}? that ensures that between the two last processed token there is no space inbetween. If one of the tokens is optional we have to split the alternatives: SignedNatLiteral = (negative:[\"-\"]) Digits {noSpace()}? | Digits ; Adding a handcoded function like getValue() via astrule or the TOP-mechanism allows to use SignedNatLiteral like a token. Scannerless parsing is a principle where the tokens are reduced to simple characters (or character classes, such as [a-z] ). Scannerless parsing generally avoids this kinds of problems, but is way slower. This kind of solution tries to mediate between the two extremes benefitting from both approaches. Defined by: MB, in: MCCommonLiterals.mc4 and other literals grammars.","title":"Avoid complex tokens (1)"},{"location":"docs/BestPractices-Syntax-Design/#avoid-complex-tokens-2","text":"Same general problem. In language composition conflicting tokens may lead to issues. For example Java allows 42. as a literal of type float. UML allows to define cardinalities like [42..44] . Composition clashes. Solution: In a Java sublanguage we split the token: SignedBasicFloatLiteral = ... | Digits \".\" {noSpace()}? ... ; This will ensure that [42..44] will be parsed like [ 42 .. 44 ] in a language composition as well. It generally seems that overly complex composed tokens may lead to issues especially if the language allows compact models. Suboptimal tokens may be e.g. \"[[\" (vs. nested lists), or \"<-\" (vs. 3 < -2 ). Defined by: MC team.","title":"Avoid complex tokens (2)"},{"location":"docs/BestPractices-Syntax-Design/#how-to-define-keyword-enumerations","text":"A finite set of keyword-based alternatives can be defined in several forms: Standard three keywords act as alternative: N = ([\"public\"] | [\"protected\"] | [\"private\"]) ; Effects: not extensible without overriding and repetition introduces boolean flags, where only one can be true at a time Use an enumeration nonterminal enumeration E = \"public\" | \"protected\" | \"private\" ; N = E ; Effects: not extensible Use an interface and subclasses with almost empty body: interface E ; P1 implements E = \"public\" ; P2 implements E = \"protected\" ; P3 implements E = \"private\" ; N = E ; Effects: very extensible in various ways (even beyond mere keywords) visitor can easily address the keywords (i.e. by visit(P1) ...) Disadvantage: Clumsy notation and visitors are always needed. Defined by: SVa, BR.","title":"How to define keyword enumerations"},{"location":"docs/BestPractices-Syntax-Design/#common-ast-access-to-syntactically-similar-nonterminals","text":"Sometimes the following occurs (e.g. in associations of CDs or interactions of SD): A = X Y Z; B = Z Y X; The concrete syntax differs (in order), but the syntactic concepts are the same. To allow common access, a common interface nonterminal is introduced that is not used in the grammar directly. This doesn't change the concrete syntax but allows common AST access: interface F = X Y Z; // order is irrelevant A implements F = X Y Z; B implements F = Z Y X; Defined by: BR.","title":"Common AST-Access to Syntactically Similar Nonterminals"},{"location":"docs/BestPractices-Syntax-Design/#how-and-when-to-use-names-for-nonterminals","text":"Normally names like expr:Expr can be avoided which makes a grammar easier to read and more concise, i.e. Expr alone has the same effect. There may be two reasons to use a name: Nonterminal X occurs several times and we want to distinguish: left:Expr \"*\" right:Expr We can also use the name to describe the purpose of the nonterminal, i.e. MyVariable implements Variable = Name \"=\" initial:Expression; vs: MyParameter implements Variable = Name \"=\" default:Expression; Defined by: BR.","title":"How and when to use Names for Nonterminals"},{"location":"docs/BestPractices-Syntax-Design/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/BestPractices/","text":"MontiCore Best Practices - A Guide For Small Solutions MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specific advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. The list is subdivided into several MD files tackling various language design areas. The list is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual. Designing A Language includes: Language Design in the Large Designing Concrete and Abstract Syntax Handling Errors 0x..... Designing Symbols, Scopes and SymbolTables Designing Tools for Command Line Interfaces Generating Code with Templates (no practice defined here yet) Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Best Practices"},{"location":"docs/BestPractices/#monticore-best-practices-a-guide-for-small-solutions","text":"MontiCore provides a number of options to design languages, access and modify the abstract syntax tree, and produce output files. This (currently unsorted and evolving) list of practices discusses solutions that we identified and applied as well as alternatives and their specific advantages and drawbacks. The list also mentions where the solutions have been found and where they have been applied first. The list is subdivided into several MD files tackling various language design areas. The list is partially temporary and also contains compact (incomplete) solutions. More detailed descriptions of best practices can be found in the MontiCore reference manual . Some of the best practices here will also be incorporated in the next version of the reference manual. Designing A Language includes: Language Design in the Large Designing Concrete and Abstract Syntax Handling Errors 0x..... Designing Symbols, Scopes and SymbolTables Designing Tools for Command Line Interfaces Generating Code with Templates (no practice defined here yet)","title":"MontiCore Best Practices - A Guide For Small Solutions"},{"location":"docs/BestPractices/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/BuildMontiCore/","text":"MontiCore - Language Workbench And Development Tool Framework MontiCore Reference Manual . General disclaimer (Repeated from the BSD 3 Clause license): This software is provided by the copyright holders and contributors \"as is\" and any expressed or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services, loss of use, data, or profits, or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. Included Software This product includes the following software: * AntLR * FreeMarker Contribution When you want to contribute: Please make sure that your complete workspace only uses UNIX line endings (LF) and all files are UTF-8 without BOM. On Windows you should configure git to not automatically replace LF with CRLF during checkout by executing the following configuration: git config --global core.autocrlf input Build MontiCore MontiCore is currently built using Gradle. Please note that from the top level build script, not everything is built and all tests executed. It is a deliberate decision, to exclude some of the longer lasting tasks. build the productive code (including the unit tests, ~8 min) gradle buildMC skipping the unit tests: gradle assembleMC run integration tests (which are not included in the unit tests, ~30 min) all integration tests gradle testIT Integration tests of the generator: gradle -p monticore-test/it build EMF Integration tests of the generator (only test collection not included in testIt ): gradle -p monticore-test/it build -PbuildProfile=emf Experiments (from the Reference Manual) as integration tests: gradle -p monticore-test/01.experiments build and gradle -p monticore-test/02.experiments build Grammar integration tests: gradle -p monticore-test/monticore-grammar-it build clean: call gradle clean cleaning integration tests: using gradle gradle clean within the corresponding subproject (see above) Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"BuildMontiCore"},{"location":"docs/BuildMontiCore/#monticore-language-workbench-and-development-tool-framework","text":"MontiCore Reference Manual .","title":"MontiCore - Language Workbench And Development Tool Framework"},{"location":"docs/BuildMontiCore/#general-disclaimer","text":"(Repeated from the BSD 3 Clause license): This software is provided by the copyright holders and contributors \"as is\" and any expressed or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services, loss of use, data, or profits, or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.","title":"General disclaimer"},{"location":"docs/BuildMontiCore/#included-software","text":"This product includes the following software: * AntLR * FreeMarker","title":"Included Software"},{"location":"docs/BuildMontiCore/#contribution","text":"When you want to contribute: Please make sure that your complete workspace only uses UNIX line endings (LF) and all files are UTF-8 without BOM. On Windows you should configure git to not automatically replace LF with CRLF during checkout by executing the following configuration: git config --global core.autocrlf input","title":"Contribution"},{"location":"docs/BuildMontiCore/#build-monticore","text":"MontiCore is currently built using Gradle. Please note that from the top level build script, not everything is built and all tests executed. It is a deliberate decision, to exclude some of the longer lasting tasks. build the productive code (including the unit tests, ~8 min) gradle buildMC skipping the unit tests: gradle assembleMC run integration tests (which are not included in the unit tests, ~30 min) all integration tests gradle testIT Integration tests of the generator: gradle -p monticore-test/it build EMF Integration tests of the generator (only test collection not included in testIt ): gradle -p monticore-test/it build -PbuildProfile=emf Experiments (from the Reference Manual) as integration tests: gradle -p monticore-test/01.experiments build and gradle -p monticore-test/02.experiments build Grammar integration tests: gradle -p monticore-test/monticore-grammar-it build clean: call gradle clean cleaning integration tests: using gradle gradle clean within the corresponding subproject (see above)","title":"Build MontiCore"},{"location":"docs/BuildMontiCore/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/DevelopedLanguages/","text":"Languages and Language Components Developed with MontiCore The MontiCore language workbench has been under development for a while already and of course has been used by our group to develop many languages. Not all of those languages are publicly available and some of these languages are equipped with tools based on MontiCore 5. Many of these languages are composed of sublanguages and thus potentially build on each other. The available languages can be used as is, but also be adapted, extended and further composed. Please also have a look at our literature references for further information on many of the languages. Github Available Languages Class Diagrams Sequence Diagrams JSON Feature Diagrams SI Units automaton EmbeddedMontiArc Object Diagrams Further Languages (e.g. used in scientific and industrial projects) MontiArc ADL is an architectural definition language for component and connector models with enhanced connection facilities, hierarchical decomposition etc. and provides a simulator [HRR12,BHH+17,Wor16,Hab16] . MontiArcAutomaton ADL is an extension of the architectural definition language MontiArc using automata to describe behavior. Some applications e.g. are of robotics, production, or InternetOfThings. [BKRW17a,HKR+16,BRW16a,Wor16] . UML/P is a derivation from UML, especially suited for agile development. See language definition and usage method in [Rum17,Rum16,Sch12] . UML/P Class Diagrams for data structures UML/P Object Diagrams for exemplaric situations: usable for constructive development as well as testing OCL/P as Java-variant of the OCL with a nice logic, set-comprehension etc. UML/P Statecharts for behavior UML/P Sequence Diagrams for interaction Activity Diagrams for workflows and requirements (an extension to the books) Delta-MontiArc [HRRS12,HKR+11,HRRS11] is a DSL for expressing deltas on MontiArc component definitions which allows to model software product lines in a bottom up way. MontiArcHV [HRR+11] allows specifying component variability fully integrated within the component hierarchy located at variation points in component definitions. Java as full language as well as source for Java expressions, statements, attribute or method definitions. FeatureDSL is a DSL for feature diagrams in software product line approaches. DeltaCD is a DSL for expressing deltas on class diagrams which allows to model software product lines in a bottom up way Aerospace Constraint Specification Language is a DSL used to specify critical situations in an airspace including airplanes, weather, flight conditions and much more. [ZPK+11] clArc DSL Family: [PR13] Cloud Architecture Description Language: used to model of architectures of cloud-based systems; based on MontiArc. Target Description Language: used to model the infrastructure architecture of cloud-based systems. Mapping Description Language: used to model deployments between software and infrastructure architectures. Architecture Scenario Description Language: used to model scenario-based test cases for software architectures. I/O-TestDSL for the definition of stream-based, input-output related black-box tests for architecture definition languages like MontiArc. LightRocks , a modelling language for robotic assembly processes. cdViews is a DSL used to model partial views on class diagrams RBAC for Role-Based Access Control in enterprise information systems. MontiWis [[RR13,Rei16]] is a family of DSLs for the model-based, generative development of web information systems among others based on class diagrams, activity diagrams and views. HQL : Hibernate Query Language that maps to hibernate based executions. SQL the well known DB query language; used for embedding e.g. into other languages. XML the basic infrastructure for all XML dialects CarOLO DSLs for autonomic driving. This among others contains a DSL for defining road scenarios with moving vehicles as well a obstacles suited for laser, lidar, radar and camera sensors. This languages are part of the Darpa Urban Challenge 2007. [BR12b,BR12,Ber10,BR09] . ProcEd a Web-based Editing Solution for Domain Specific Process-Engineering [BGR09] . MontiWeb a modular development approach for Web Information Systems (which was later succeeded by MontiWIS) [DRRS09] . C++ and its sublanguages for expressions, statements and definitions (but no generic types, no defines). MontiCore itself uses a family of DSLs for the definition of DSLs, i.e., their grammars. [HR17] More Information about Languages and Language Components MontiCore Reference Manual . The reference Manual describes how to use MontiCore as an out-of-the-box language workbench ), but also as a grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of MontiCore core Language Components . MontiCore concentrates on reuse. It therefore offers a set of predefined language components where the main artifact is usually a component grammar . Reusing these language components allows language developers to define their own language as a composition of reusable assets efficiently. Reusable assets describe among others several sets of literals , expressions and types , which are relatively freely composable. List of languages . This is a another list of newer MontiCore 6 languages that can be used out of the box or also composed. Many of them already are rather stable, but some of them also undergo a lively development and enhancement. These complete languages are usually composed of a number of language components. MontiCore topic list Describes various research topics which MontiCore builds on or where MontiCore has been used as foundation. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Languages"},{"location":"docs/DevelopedLanguages/#languages-and-language-components-developed-with-monticore","text":"The MontiCore language workbench has been under development for a while already and of course has been used by our group to develop many languages. Not all of those languages are publicly available and some of these languages are equipped with tools based on MontiCore 5. Many of these languages are composed of sublanguages and thus potentially build on each other. The available languages can be used as is, but also be adapted, extended and further composed. Please also have a look at our literature references for further information on many of the languages.","title":"Languages and Language Components Developed with MontiCore"},{"location":"docs/DevelopedLanguages/#github-available-languages","text":"Class Diagrams Sequence Diagrams JSON Feature Diagrams SI Units automaton EmbeddedMontiArc Object Diagrams","title":"Github Available Languages"},{"location":"docs/DevelopedLanguages/#further-languages-eg-used-in-scientific-and-industrial-projects","text":"MontiArc ADL is an architectural definition language for component and connector models with enhanced connection facilities, hierarchical decomposition etc. and provides a simulator [HRR12,BHH+17,Wor16,Hab16] . MontiArcAutomaton ADL is an extension of the architectural definition language MontiArc using automata to describe behavior. Some applications e.g. are of robotics, production, or InternetOfThings. [BKRW17a,HKR+16,BRW16a,Wor16] . UML/P is a derivation from UML, especially suited for agile development. See language definition and usage method in [Rum17,Rum16,Sch12] . UML/P Class Diagrams for data structures UML/P Object Diagrams for exemplaric situations: usable for constructive development as well as testing OCL/P as Java-variant of the OCL with a nice logic, set-comprehension etc. UML/P Statecharts for behavior UML/P Sequence Diagrams for interaction Activity Diagrams for workflows and requirements (an extension to the books) Delta-MontiArc [HRRS12,HKR+11,HRRS11] is a DSL for expressing deltas on MontiArc component definitions which allows to model software product lines in a bottom up way. MontiArcHV [HRR+11] allows specifying component variability fully integrated within the component hierarchy located at variation points in component definitions. Java as full language as well as source for Java expressions, statements, attribute or method definitions. FeatureDSL is a DSL for feature diagrams in software product line approaches. DeltaCD is a DSL for expressing deltas on class diagrams which allows to model software product lines in a bottom up way Aerospace Constraint Specification Language is a DSL used to specify critical situations in an airspace including airplanes, weather, flight conditions and much more. [ZPK+11] clArc DSL Family: [PR13] Cloud Architecture Description Language: used to model of architectures of cloud-based systems; based on MontiArc. Target Description Language: used to model the infrastructure architecture of cloud-based systems. Mapping Description Language: used to model deployments between software and infrastructure architectures. Architecture Scenario Description Language: used to model scenario-based test cases for software architectures. I/O-TestDSL for the definition of stream-based, input-output related black-box tests for architecture definition languages like MontiArc. LightRocks , a modelling language for robotic assembly processes. cdViews is a DSL used to model partial views on class diagrams RBAC for Role-Based Access Control in enterprise information systems. MontiWis [[RR13,Rei16]] is a family of DSLs for the model-based, generative development of web information systems among others based on class diagrams, activity diagrams and views. HQL : Hibernate Query Language that maps to hibernate based executions. SQL the well known DB query language; used for embedding e.g. into other languages. XML the basic infrastructure for all XML dialects CarOLO DSLs for autonomic driving. This among others contains a DSL for defining road scenarios with moving vehicles as well a obstacles suited for laser, lidar, radar and camera sensors. This languages are part of the Darpa Urban Challenge 2007. [BR12b,BR12,Ber10,BR09] . ProcEd a Web-based Editing Solution for Domain Specific Process-Engineering [BGR09] . MontiWeb a modular development approach for Web Information Systems (which was later succeeded by MontiWIS) [DRRS09] . C++ and its sublanguages for expressions, statements and definitions (but no generic types, no defines). MontiCore itself uses a family of DSLs for the definition of DSLs, i.e., their grammars. [HR17]","title":"Further Languages (e.g. used in scientific and industrial projects)"},{"location":"docs/DevelopedLanguages/#more-information-about-languages-and-language-components","text":"MontiCore Reference Manual . The reference Manual describes how to use MontiCore as an out-of-the-box language workbench ), but also as a grey box tooling framework . It thus also gives an overview over a number of core mechanisms of MontiCore. List of MontiCore core Language Components . MontiCore concentrates on reuse. It therefore offers a set of predefined language components where the main artifact is usually a component grammar . Reusing these language components allows language developers to define their own language as a composition of reusable assets efficiently. Reusable assets describe among others several sets of literals , expressions and types , which are relatively freely composable. List of languages . This is a another list of newer MontiCore 6 languages that can be used out of the box or also composed. Many of them already are rather stable, but some of them also undergo a lively development and enhancement. These complete languages are usually composed of a number of language components. MontiCore topic list Describes various research topics which MontiCore builds on or where MontiCore has been used as foundation.","title":"More Information about Languages and Language Components"},{"location":"docs/DevelopedLanguages/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/Download/","text":"The following tools for MontiCore can be used from the command line and thus e.g. well be embedded in scripting. Their languages as well as related tooling are currently available for download: The MontiCore tool for processing grammars The MontiCore runtime library The Automaton example project that can be used with the MontiCore CLI tool The Automaton example project in Gradle that can be used with Gradle The CD tool for a Class Diagram language The FACT tool for a Feature Diagram language The FeatureConfiguration tool for a Feature Diagram language The FeatureConfigurationPartial tool for a Feature Diagram language The FeatureDiagram tool for a Feature Diagram language The MLC tool for grouping Monticore Language Components (not yet publicly available) The OCL tool for an Object Constraint Language The OD4Data tool for an Object Diagram language The OD4Report tool for an Object Diagram language The SD4Development tool for a Sequence Diagram language The Statecharts tool for a Statechart language The XML tool for an XML language Please note the MontiCore 3-Level License of these tools. Further Information see also MontiCore handbook MontiCore Reference Languages - Languages Built Using MontiCore Build MontiCore - How to Build MontiCore Getting Started - How to start using MontiCore Changelog - Release Notes FAQ - FAQ Licenses - MontiCore 3-Level License Project root: MontiCore @github List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore","title":"Downloads"},{"location":"docs/Download/#further-information","text":"see also MontiCore handbook MontiCore Reference Languages - Languages Built Using MontiCore Build MontiCore - How to Build MontiCore Getting Started - How to start using MontiCore Changelog - Release Notes FAQ - FAQ Licenses - MontiCore 3-Level License Project root: MontiCore @github List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore","title":"Further Information"},{"location":"docs/GettingStarted/","text":"Getting Started with MontiCore This page describes the technical installation and usage of MontiCore for language developers. This page further inspects a simple example grammar and the Java classes and other artifacts generated from this grammar. After installing MontiCore as described on this page, it can be used to develop new modelling languages and generators as described in subsequent chapters. MontiCore provides a command line interface (CLI) tool and can easily be used with Gradle. The Gradle integration enables developers to easily employ MontiCore in commonly used integrated development environments (IDEs), such as Eclipse and IntelliJ IDEA. We strongly recommend to work through the section about the CLI tool first. The CLI section contains information about an example MontiCore project and the files generated by MontiCore. It also shortly explains some key features of MontiCore. Detailed information about all configuration options that can be used in the MontiCore CLI tool and in MontiCore Gradle projects are explained in Chapter 16 of the handbook . More information about the example Automata language are available in Chapter 21 of the handbook . Prerequisites: Installing the Java Development Kit We start with the JDK: Please perform the following steps to install the Java Development Kit (JDK) and validate that the installation was successful: Install a JDK with at least version 8 provided by Oracle or OpenJDK. Make sure the environment variable JAVA_HOME points to the installed JDK, and not to the JRE, e.g., the following would be good: /user/lib/jvm/java-8-openjdk on UNIX or C:\\Program Files\\Java\\jdk1.8.* on Windows. You will need this in order to run the Java compiler for compiling the generated Java source files. Also make sure that the system variable is set such that the Java compiler can be used from any directory. JDK installations on UNIX systems do this automatically. On Windows systems, the bin directory of the JDK installation needs to be appended to the PATH variable, e.g. %PATH%;%JAVA_HOME% . Test whether the setup was successful. Open a command line shell in any directory. Execute the command javac -version . If this command is recognized and the shell displays the version of the installed JDK (e.g., javac 1.8.0_192 ), then the setup was successful. Now we have the prerequisites to run MontiCore from the command line. The JDK installation is also required for using MontiCore with Gradle. Install and Use the MontiCore Command Line Interface This section describes instructions to perform the following first steps to use MontiCore as an CLI tool: Installation of the MontiCore distribution file. Grammar inspection Running the MontiCore generator Compiling the product Running the product, i.e. the Automata tool with an example model example/PingPong.aut . Installation For installing MontiCore, perform the following steps: Download the example Automata MontiCore project: // MontiCore zip distribution source https://www.monticore.de/download/monticore.tar.gz Unzip the archive. The unzipped files include a directory called mc-workspace containing the executable MontiCore tool monticore-cli.jar along with a directory src containing handwritten Automata DSL infrastructure, a directory hwc containing handwritten code that is incorporated into the generated code, and a directory example containing an example model of the Automata DSL. // MontiCore zip distribution content in directory mc-workspace Automata.mc4 monticore-cli.jar monticore-rt.jar src/automata/AutomataTool.java src/automata/visitors/CountStates.java src/automata/prettyprint/PrettyPrinter.java src/automata/cocos/AtLeastOneInitialAndFinalState.java src/automata/cocos/StateNameStartsWithCapitalLetter.java src/automata/cocos/TransitionSourceExists.java hwc/automata/_ast/ASTState.java hwc/automata/_symboltable/AutomatonSymbol.java hwc/automata/_symboltable/AutomataSymbols2Json.java hwc/automata/_symboltable/AutomatonSymbolDeser.java hwc/automata/_symboltable/AutomataGlobalScope.java example/PingPong.aut Inspect the Example Grammar MontiCore is a language workbench. It supports developers in developing modular modelling languages. The core of MontiCore is its grammar modelling language (cf. Chapter 4 of the MontiCore handbook ), which is used by developers for modelling context-free grammars. A MontiCore grammar defines (parts of) the abstract and concrete syntax of a language. Each grammar contains nonterminals, production rules, and may extend other grammars. At most one rule is marked as the start rule. It is a key feature of MontiCore that it allows a grammar to reuse and extend other grammars . In an extension all the nonterminals defined in the extended grammars can be reused or even overridden. This form of extension allows to achieve several effects: Language (i.e. grammar) components can be reused and integrated in larger languages, composed of several components. Individual nonterminals can be reused (like classes) from a library. A given language can be extended, allowing to add additional alternatives inside a language. Component grammars and grammar extensions are detailedly discussed in Chapter 4 of the MontiCore handbook . grammar Automata extends de.monticore.MCBasics { symbol scope Automaton = \"automaton\" Name \"{\" (State | Transition)* \"}\" ; symbol State = \"state\" Name ((\"<<\" [\"initial\"] \">>\" ) | (\"<<\" [\"final\"] \">>\" ))* ( (\"{\" (State | Transition)* \"}\") | \";\") ; Transition = from:Name \"-\" input:Name \">\" to:Name \";\" ; } Listing 2.2: The Automata grammar. In the following, we inspect the MontiCore grammar of the Automata language. Navigate your file explorer to the unzipped mc-workspace directory. The directory contains the file Automata.mc4 . This file contains the MontiCore grammar depicted in Listing 2.2. MontiCore grammars end with .mc4 . The definition of a MontiCore grammar starts with the keyword grammar , followed by the grammar's name. In this example, the grammar is called Automata . The grammar's name is optionally followed by the keyword extends and a list of grammars that are extended by the grammar. In this example, the Automata grammar extends the grammar de.monticore.MCBasics . Tip 2.3 MontiCore Key Feature: Composition The MontiCore language workbench allows to compose language components by composing grammars and also to reuse all infrastructure, such as context conditions, symbol table infrastructure, generator parts and handwritten extensions. In the example the Automata grammar extends the grammar de.monticore.MCBasics and thus reuses its functionality. MontiCore comes with an extensive library of predefined language components. Grammars can also have a package and import other grammars. If a grammar has a package, then the package declaration must be the first statement in the grammar and is of the form package QualifiedName where package is a keyword and QualifiedName is an arbitrary qualified name (e.g., de.monticore ). The optional grammar imports follow the package definition. Every import is of the form import QualifiedName . The Automata example grammar file does neither contain a package declaration nor imports. The grammar extended by the Automata grammar is specified by its fully qualified name. As usual in context-free grammars, production rules have a left-hand side and a right-hand side. The left-hand side contains the possibly annotated name of a nonterminal. The left-hand side is followed by the terminal = and the right-hand side. Nonterminal names start with an upper-case letter. For instance, the Automata grammar contains the nonterminals Automaton , State , and Transition . A single nonterminal can be annotated with the start keyword. Then, the nonterminal is the starting symbol of the grammar. If no nonterminal is annotated with start , then the first nonterminal of the grammar becomes the starting symbol by default. In the Automata grammar, the Automaton nonterminal is the starting symbol. The other possible annotations for nonterminals influence the generated classes for the abstract syntax tree as well as the generated symbol table infrastructure. Details can be found in Chapter 4 and Chapter 9 of the MontiCore handbook . For example, the Automaton nonterminal is annotated with symbol and scope . The annotation symbol makes the MontiCore generator generate a symbol class for the nonterminal. Intuitively stated, the annotation scope instructs MontiCore to construct a symbol table infrastructure that opens a scope when the production is processed. The following sections explain the effects of annotating the Automaton nonterminal with the keywords symbol and scope in more detail. Terminals are surrounded by quotation marks. The Automata grammar, for example, inter alia contains the terminals automaton , state , { , } , and ; . The right-hand sides of grammar productions consist of nonterminals, terminals, and semantic predicates, may use cardinalities ( * , + , ? ), and introduce alternatives via the terminal | as known from regular expressions. Details can be found in Chapter 4 of the MontiCore handbook . The right-hand side of the production defining the nonterminal Automaton , for example, uses the terminal automaton and the nonterminals Name , State , and Transition . The nonterminal Name is not defined in the grammar Automata . Thus, it must be defined in one of the extended grammars. In this case, Name is defined in the grammar MCBasics and is reused by the grammar Automata . For distinguishing different usages of nonterminals on right-hand sides, they can be named. For example, the right-hand side of the production defining the nonterminal Transition uses the Name nonterminal twice. The first usage is named input and the second usage is named to . MontiCore also supports interface and external nonterminals for introducing extension points as detailedly described in Chapter 4 of the MontiCore handbook . However, the example grammar does not use these concepts. automaton PingPong { state NoGame <<initial>>; state Ping; state Pong <<final>>; NoGame - startGame > Ping; Ping - stopGame > NoGame; Pong - stopGame > NoGame; Ping - returnBall > Pong; Pong - returnBall > Ping; } Listing 2.4: A model conforming to the Automata grammar. Listing 2.4 depicts an example model conforming to the Automata grammar in its concrete syntax. You can find the model in the file PingPong.aut contained in the example directory of the unzipped mc-workspace directory. Run MontiCore The MontiCore generator takes a MontiCore grammar as input and generates an infrastructure for processing models conforming to the grammar. When a grammar E extends another grammar G , then all the infrastructure generated for the grammar G is reused and only the extending part from E is generated. Tip 2.5 Infrastructure Generated by MontiCore MontiCore itself as well as the infrastructure generated by the MontiCore generator are implemented in Java. This infrastructure includes: a parser for parsing models conforming to the grammar and transforming textual models into abstract syntax tree instances abstracting from the concrete syntax. a symbol table infrastructure to handle the symbols introduced or used by models conforming to the grammar. The symbol table infrastructure is used for resolving dependencies between model elements that are possibly defined in different files. a context-condition checking framework for checking well-formedness rules that cannot be captured by context-free languages. a visitor infrastructure for traversing models respectively their abstract syntax instances. The abstract syntax of a model consists of its internal representation as an abstract syntax tree abstracting from the concrete syntax of the model (the instance of the data structure obtained from parsing) and the symbol table of the model. a mill infrastructure for retrieving objects for language processing, such as parsers, builders for abstract syntax trees, visitors and objects for the symbol tables of the language. The possibility to configure the mills is crucial for reusing the functionality implemented for a sublanguage (cf. Section 5.9, Section 5.10.2, and Section 11.5 for details). a code generating framework that extends the FreeMarker template engine [Fre21] by various modularity enhancing features. For executing MontiCore using the Automata grammar as input, perform the following steps: Open a command line shell and change the working directory to the unzipped directory ( mc-workspace ). Execute the following command in order to generate the language infrastructure of the Automata DSL: java -jar monticore.jar -g Automata.mc4 -hcp hwc/ src/ -mp monticore-rt.jar The only required argument Automata.mc4 denotes the input grammar that shall be processed by MontiCore. The processing includes the generation of the language infrastructure. Using the option -hcp enables specifying the path to a directory containing the handwritten code that is to be incorporated into the generated infrastructure. In this case, passing the argument hwc/ to the option -hcp makes MontiCore consider the handwritten code located in the directory hwc/ . Providing handwritten code enables to easily incorporate additional functionality into the generated code. For example, this enables developers to extend generated abstract syntax classes as detailedly described in (cf. Section 5.10 of the MontiCore handbook ). Passing the argument -mp enables specifying the paths to directories containing paths to grammars and Java classes that are imported by the processed grammar and the related tooling. In this case, the archive monticore-rt.jar contains the grammars and handwritten extensions of the monticore standard library (not yet publicly available) . More information about the standard library can be found in Chapters 17- 20 of the handbook . Executing the command launches MontiCore, which results in the executing of the following steps: The specified grammar is parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure are generated into the default output directory out . This infrastructure consists of the directories out/automata/ containing the mill (cf. Section 5.9, Section 5.10.2, Section 11.5). out/automata/_ast containing the abstract syntax tree data structure (cf. Chapter 5 of the MontiCore handbook ). out/automata/_auxiliary containing adapted mills of sublanguages, which are required for configuring the mills of sublanguages (cf. Chapter 11 of the MontiCore handbook ). out/automata/_cocos containing the infrastructure for context conditions (cf. Chapter 10 of the MontiCore handbook ). out/automata/_od containing the infrastructure for printing object diagrams for reports produced during processing the models. out/automata/_parser containing the generated parsers, which are based on ANTLR (cf. Chapter 6 of the MontiCore handbook ). out/automata/_symboltable containing the infrastructure for the symbol table (cf. Chapter 6 of the MontiCore handbook ). out/automata/_visitor containing the infrastructure for visitors (cf. Chapter 9 of the MontiCore handbook ). out//automata containing reports created during the processing of the grammar. The output directory also contains a log file of the executed generation process with the generation time in its name. In the following, we review the classes and interfaces generated from the Automata grammar that are relevant for language engineers in more detail. We do not review the classes and interfaces that are only internally relevant for MontiCore and are usually not intended to be used by language engineers. Abstract Syntax Tree Data Structure The tree data structure is generated into the directory out/automata/_ast . Details about the generation of AST classes can be found in (cf. Chapter 5 of the MontiCore handbook ). For each nonterminal contained in the grammar, the MontiCore generator produces AST and corresponding builder classes. The AST classes implement the abstract syntax tree data structure. The builder classes implement the builder pattern for constructing instances of the respective AST classes as usual. For example, the class ASTAutomaton is the AST class generated for the Automaton nonterminal (cf. Listing 2.2) and the class ASTAutomatonBuilder is the corresponding generated builder class. Parts of the AST data structure generated for the Automata grammar. Figure 2.6: Parts of the AST data structure generated for the Automata grammar. The contents of the AST and builder classes are generated systematically from the grammar. The attributes of each AST class resemble the right-hand side of the corresponding production rule. In the following, we mainly speak of attributes, but please be aware that all attributes come fully equipped with access and modification methods, which should normally be used. For instance, Figure 2.6 depicts parts of the generated AST infrastructure for the Automata grammar. The class ASTAutomaton contains the attributes name , states , and transitions . The AST class does not contain an attribute for the terminal automaton as it is part of every word conforming to the production of the Automaton nonterminal. The type of the attribute name is String whereas the attributes states and transitions are lists of the types of the AST classes corresponding to the used nonterminals. This is the case because exactly one Name is parsed with the right-hand side of the production of the nonterminal Automaton , whereas multiple states and transitions can be parsed. The ASTAutomaton class further contains the attributes symbol , spannedScope , and enclosingScope . These attributes are specific to the symbol table of Automata models and are used for linking the symbol table of a model with its abstract syntax tree. Details can be found in Chapter 9 of the MontiCore handbook . Tip 2.7 Generated Symbols and Scopes in the AST Each AST class contains access to the enclosingScope . When a production contains the keyword symbol , the generated AST class contains the attribute symbol (see Chapter 9 of the MontiCore handbook ). Keyword scope indicates that a nonterminal also defines a new local scope, stored in attribute spannedScope . The parser builds the abstract syntax tree of a model and the available scope genitor creates the symbol table of the model, consisting of symbols and scopes. The ASTAutomaton class further contains several straight-forward methods for checking different instances for equality and accessing the attributes. Similar to the ASTAutomaton class, the ASTAutomatonBuilder class contains attributes resembling the right-hand side of the corresponding production. It further contains methods for changing the values of the attributes (e.g., addState ), checking whether the AST instance that would be constructed from the current builder state is valid (cf. isValid ), and for building the AST instance corresponding to the builder's state (cf. build ). The contents of the other AST and Builder classes are constructed analogously. Tip 2.7 Generated Symbols and Scopes in the AST If the generator detects that an AST class for a nonterminal is already implemented in the handwritten code, then it produces a corresponding TOP AST class instead. This TOP mechanism allows developers to add handwritten extensions to any generated class, while reusing the generated TOP class via extension. This gives a very close integration between handwritten and generated code that even adapts builders accordingly, while preventing the very bad habit of performing manual changes to the generated code. Option -hcp tells the generator where to look for handwritten integrations. The following section presents the methods of the classes for parsing textual models (possibly stored in files) into AST class instances at runtime. For now, it suffices for you to understand that (1) MontiCore generates an extensible AST data structure that resembles the nonterminals and productions of the grammar in a straight-forward way and (2) that all models of a grammar have an AST data structure representation for internal processing. Parser The infrastructure is generated into the directory out/automata/_parser . Details about the generated parsers and their uses are described in Chapter 6 of the MontiCore handbook . Parts of the class AutomataParser generated from the Automata grammar. Figure 2.9: Parts of the class AutomataParser generated from the Automata grammar. Parts of the generated class AutomataParser are depicted in Figure 2.9. The class implements the generated parser for the Automata grammar. Usually, developers are solely concerned with the methods parse(String) and parse_String(String) . For now, it suffices if you remember that parsing textual Automata models stored in files is possible by calling the method parse(String) of an AutomataParser object with the fully qualified name of the file as input. Tip 2.10 Methods for Parsing The class AutomataParser contains the methods parse(Reader r) , parse(String filename) , and parse_String(String content) . All of the methods return an object of type Optional<ASTAutomaton> , where absence means failure of parsing and errors have been issued. For each nonterminal in the grammar, the class further contains methods for parsing a sub-model described by this nonterminal. Symbol Table The infrastructure is generated into the directory out/automata/_symboltable . Details about the generated symbol table infrastructure and its use are described in Chapter 9 of the MontiCore handbook . The symbol table infrastructure is used for resolving cross-references concerning information defined in different model elements that are potentially defined in different models stored in different files. Figure 2.11: The scope classes generated from the `Automata` grammar. Tip 2.12 Scope Classes For the Automata grammar, the generator produces the classes AutomataScope , AutomataArtifactScope , and AutomataGlobalScope as well as respective interfaces. The relationships between these classes and interfaces are depicted in Figure 2.11. The singleton AutomataGlobalScope contains all AutomataArtifactScopes of all loaded Automata artifacts. AutomataScope s represent scopes spanned inside of models. Figure 2.13: Parts of the symbol classes generated from the Automata grammar. Figure 2.13 depicts parts of the symbol classes generated for the Automata grammar. As the nonterminal State is annotated with symbol in the Automata grammar, the generator produces the class StateSymbol . The StateSymbol class, inter alia, contains the attributes name , enclosingScope , and spannedScope . The attribute name stores the name of the symbol. The attributes enclosingScope and spannedScope store the enclosing and spanned scopes of the symbol. The class further contains methods for accessing and setting the attributes. For all symbol classes, the MontiCore generator also produces builder classes (e.g., AutomataArtifactScopeBuilder and StateSymbolBuilder ). Tip 2.14 Extending Symbol Classes It is possible to add further methods and attributes in two ways: adding a symbol rule in the grammar (described in Chapter 9 of the MontiCore handbook ) or using the TOP mechanism applied to the generated symbols. The generated class AutomataScopesGenitor is responsible for creating the scope structure of Automata artifacts and linking the scope structure with the corresponding AST nodes. For this task, it provides the method createFromAST that takes an ASTAutomaton instance as input and returns an IAutomataArtifactScope instance. The returned IAutomataArtifactScope instance can be added as a subscope to the (during runtime unique and administrated by the mill) AutomataGlobalScope instance. Developers can create visitors for complementing the symbol table (creating symbols and filling the extensions introduced via symbol rules or the TOP mechanism) of an Automata artifact. After creating the scope structure, the visitor should be used to traverse the AST instance of the artifact for complementing the symbols and scopes. The following sections explain the generated visitor infrastructure in more detail. Optional<AutomatonSymbol> resolveAutomaton(String name) List<AutomatonSymbol> resolveAutomatonMany(String name) Optional<StateSymbol> resolveState(String name) List<StateSymbol> resolveStateMany(String name) Listing 2.15: Different resolve methods. For each nonterminal annotated with symbol in the grammar Automata , the scope interfaces contain a symbol-specific resolve method taking a string as input. The method can be called to resolve symbol instances by their names. The name given as input to a resolve method should be as qualified as needed to find the symbol. For instance, Listing 2.15 lists the signatures of four of the resolve methods provided by the interface IAutomataScope . For now, it suffices for you to understand that (1) MontiCore generates an extensible symbol table data structure that resembles the scope and symbol structure as specified in the grammar in a straight-forward way and (2) that all models of a grammar have a symbol table data structure representation for internal processing and (3) that symbols can be resolved from scopes via calling the resolve methods. (De)Serialization of Symbol Tables MontiCore also supports the serialization and deserialization of symbol tables. The (de)serialization is crucial for incremental code generation and efficient language composition via aggregation. Details about this are explained in Chapter 7 and Chapter 9 of the MontiCore handbook . For the (de)serialization, the generator produces the class AutomataSymbol2Json . It provides the public methods store and load . The former can be used to serialize IAutomataScope instances into their string representations encoded in JSON and persisting these to a file at a location that is passed as method argument. The latter can be used to load a stored IAutomataScope into its objects representation. For now, it suffices that you understand which methods to call for the (de)serialization. Visitor Figure 2.16: Parts of the visitor infrastructure generated from the Automata grammar The infrastructure is generated into the directory out/automata/_visitor . Details about the generated visitor infrastructure are described in Chapter 8 of the MontiCore handbook . For each grammar, the generator systematically produces several classes and interfaces implementing the visitor infrastructure. For the Automata grammar, for example, the generator produces the interfaces AutomataTraverser , AutomataVisitor2 , and AutomataHandler and the class AutomataTraverserImplementation . The relationships between these interfaces and classes are depicted in Figure 2.16. The interfaces Traverser , Visitor2 and Handler together realize the Visitor pattern. Conceptually, the traverser is the entry point for traversing. The traverser manages visitors for the different sublanguages and realizes the default traversing strategy. Whenever an AST node is traversed, the traverser delegates the visit to the corresponding visitor implementation. If a special traversal is to be implemented that differs from the default, it is possible to add handlers to the traverser that realize the alternative traversal. For a more detailed explanation consider reading Chapter 8 of the MontiCore handbook . Tip 2.17 Visitors MontiCore provides the visitor pattern in a detangled and thus flexible variant. AutomataTraverser is traversing the AST. AutomataVisitor2 contain the actual functionalities, added through subclassing. Many visitors can be added to the traverser for parallel execution via the method add4Automata . The visitors are compositional, allowing to maximize reuse of visitors from sublanguages, and they can be adapted through the TOP mechanism. For example, the handwritten class PrettyPrinter , which can be found in the directory mc-workspace/src/automata/prettyprint , implements functionality for pretty printing an Automata model, which is given by its abstract syntax tree. Listing 2.18 depicts the attributes and the constructor of the class. The PrettyPrinter class implements the AutomataHandler interface. Its constructor instantiates a printer (a helper for printing indented strings) and retrieves an AutomataTraverser object from the mill (which is explained later on). It sets the handler of the traverser to itself. This ensures that the pretty printer becomes the handler of the traverser. We will execute it in a following section. public class PrettyPrinter implements AutomataHandler { private final IndentPrinter printer; private AutomataTraverser traverser; public PrettyPrinter() { this.printer = new IndentPrinter(); this.traverser = AutomataMill.traverser(); traverser.setAutomataHandler(this); } // further methods } Listing 2.18: Attributes and constructor of the PrettyPrinter for the Automata language. For now, you should understand that (1) for implementing visitors it is often sufficient to implement the visitor interfaces and to add them to a traverser and (2) custom traversals can be realized by implementing handlers and adding those to the traverser. Context Conditions The infrastructure is generated into the directory out/automata/_cocos . Details about the generated context condition infrastructure are described in Chapter 10 of the MontiCore handbook . For each nonterminal of a grammar, the generator produces a context condition interface for implementing context conditions for this nonterminal. For the Automata grammar, for example, the generator produced the interface AutomataASTStateCoCo . The interface solely contains the method check(ASTState) . Each class implementing the interface should represent a predicate over subtrees of abstract syntax trees starting at a node with the type corresponding to the nonterminal. The check method should be implemented such that it reports an error or a warning if the input node does not satisfy the predicate. Thus, context conditions implement well-formedness rules that cannot be captured by context-free grammars (or that are intentionally not captured by the grammar to achieve a specific AST data structure). For producing the error or warning, the static methods error and warning of the MontiCore runtime class Log should be used. For the Automata grammar, the generator also produced the class AutomataCocoChecker . For each nonterminal of the grammar, the class contains a method for adding context condition instances to an AutomataCocoChecker instance. For checking whether an AST node satisfies all registered context conditions, the method checkAll can be called with the AST node as input. Calling the method makes the checker traverse the abstract syntax tree and check whether each node satisfies the context conditions registered for the node. Thus, AutomataCocoChecker instances represent sets of context conditions that are required to be satisfied by abstract syntax tree instances. For now, you should understand that (1) implementing context conditions is possible via implementing the generated CoCo interfaces and (2) context conditions can be checked via instantiating the Checker class, adding the CoCos, and calling the checkAll method. Mill as Factory for Builders The for the Automata language is generated into the directory out/automata/ . Details about the generated mill and the mill pattern in general are described in Section 11.5. The generated mill class AutomataMill is responsible for providing ready to use and correct parser, scope genitor, scope, and builder instances. The mill of each language is a singleton. Tip 2.19 Mill Use and Automatic Initialization A mill is a factory for builders and other commonly used functions, such as parsers or visitors. The mill was introduced to ensure compositionality of languages, while retaining reusability of functions developed for sublanguages. Only one mill instance exists, even though in composed languages it is available under several static signatures. Let language G2 extend another language G1 . Then G2Mill initializes the G1Mill appropriately, such that all the code of the sublanguage G1 can be reused in the tools developed for the language G2 , even when creating new AST nodes, symbols, etc. Cool mechanism and the developers don't have to bother. public static IAutomataGlobalScope globalScope() public static IAutomataArtifactScope artifactScope() public static IAutomataScope scope() public static AutomataScopesGenitor scopesGenitor () public static AutomataScopesGenitorDelegator scopesGenitorDelegator() public static ASTAutomatonBuilder automatonBuilder() public static AutomatonSymbolBuilder automatonSymbolBuilder() public static AutomataParser parser() public static AutomataTraverser traverser () Listing 2.20: Some method of the AutomataMill . Developers should retrieve all instances of the classes and interfaces provided by the mill by using the mill. Instances of the classes and interfaces that are provided by the mill should never be instantiated manually. Otherwise, it may be the case that not all of the code implemented for the language can be reused as expected in other languages extending the language. Listing 2.20 shows some signatures of the methods of the AutomataMill . Tip 2.12 Mill Methods A mill provides public static methods for retrieving the instances of the parsers, scope genitors, scopes, and builders. For that is acts like a factory. Because a mill is realized using the static delegator pattern (cf. Section 11.1), it still can be adapted at will. This combines the advantage of general availability with the advantage of being able to override the functions. For now, you should understand that (1) the methods of the mill should be used for creating ready to use and correct parser, scope genitor, scope, and builder instances and (2) how to call these methods. Compile the Target Section 2.2.3 describes how to generate the desired Java code from a MontiCore grammar. For these Java classes, generated for the Automata DSL, execute the following command: javac -cp monticore.jar -sourcepath \"src/;out/;hwc/\" \\ src/automata/AutomataTool.java Please note, on Unix systems paths are separated using \":\" (colon) instead of semicolons. Providing the option -cp with the argument monticore-cli.jar makes the Java compiler consider the compiled MontiCore runtime classes contained in the file monticore-cli.jar . The option -sourcepath enables to specify paths to directories containing the source files that should be considered during the compilation. In this case, executing the command makes the Java compiler consider all generated classes located in and all handwritten classes located in src and hwc . The last argument instructs the Java compiler to compile the class src/automata/AutomataTool.java . Please note that the structure of the handwritten classes follows the package layout of the generated code, i.e. there are the following sub directories (Java packages): src/automata contains the top-level language realization for using the generated DSL infrastructure. In this case the class src/automata/AutomataTool.java constitutes a main class executable for processing automata models with the automata DSL. src/automata/cocos contains infrastructure for context condition of the automata DSL. src/automata/prettyprint contains an exemplary use of the generated visitor infrastructure for processing parsed models for pretty printing. src/automata/visitors contains an exemplary analysis using the visitor infrastructure. The exemplary analysis counts the states contained in the parsed automata model. hwc/automata/_ast contains an exemplary usage of the handwritten code integration mechanism for modifying the AST for the automata DSL. Details about the integration mechanism are described in Section 5.10. hwc/automata/_symboltable contains handwritten extensions of the generated symbol table infrastructure. Details about implementing handwritten symbol table infrastructure extensions are described in Chapter 9 of the MontiCore handbook . Please, also do not mix the code for the Automata tool vs. the code for the final product, generated from that tool, although both have a similar package structure. We already described the contents of the directories hwc/automata/_ast and hwc/automata/_symboltable in the previous section. They contain handwritten extensions of the abstract syntax of the Automata language. public class CountStates implements AutomataVisitor2 { private int count = 0; @Override public void visit(ASTState node) { count++; } public int getCount() { return count; } } Listing 2.22: The CountStates visitor implementation The directory src/automata/visitors contains the file CountStates.java . The class is depicted in Listing 2.22. It implements a simple visitor for counting the number of states contained in an Automata model. To this effect, it implements the AutomataVisitor2 interface. It has an attribute count of type int for storing the current number of counted nodes. It overrides the visit method for ASTState to increase the counter whenever a state is visited. The directory src/automata/cocos contains the context-condition implementations for the Automata language. public class AtLeastOneInitialAndFinalState implements AutomataASTAutomatonCoCo { @Override public void check(ASTAutomaton automaton) { boolean initialState = false; boolean finalState = false; for (ASTState state : automaton.getStateList()) { if (state.isInitial()) { initialState = true; } if (state.isFinal()) { finalState = true; } } if (!initialState || !finalState) { // Issue error... Log.error(\"0xA0116 An automaton must have at least one initial and one final state.\", automaton.get_SourcePositionStart()); } } } Listing 2.23: Context condition implementation for checking that there exist at least one initial and at least one final state. Listing 2.23 depicts the class AtLeastOneInitialAndFinalState . The class implements a context condition for checking whether an Automata model contains at least one initial and at least one final state. To this effect, the class implements the interface AutomataASTAutomatonCoCo . The class StateNameStartsWithCapitalLetter is implemented similarly. public class TransitionSourceExists implements AutomataASTTransitionCoCo { @Override public void check(ASTTransition node) { IAutomataScope enclosingScope = node.getEnclosingScope(); Optional<StateSymbol> sourceState = enclosingScope.resolveState(node.getFrom()); if (!sourceState.isPresent()) { // Issue error... Log.error( \"0xADD03 Source state of transition missing.\", node.get_SourcePositionStart()); } } } Listing 2.24: Context condition implementation for checking that states used in transitions exist. Listing 2.24 presents the implementation of the class TransitionSourceExists . The class implements a context condition for checking whether the source states used in transitions are defined. To this effect, the class uses the resolving mechanisms of the symbol table. For each transition, the context conditions tries to resolve the state symbol corresponding to the source state of the transition. If the resolving fails for the state, then the context condition logs an error. The class AutomataTool is the main class of the Automata language. It is defined in the file AutomataTool.java contained in the directory src/automata . public class AutomataTool { // main method missing in this listing public ASTAutomaton parse(String model) { try { AutomataParser parser = new AutomataParser() ; Optional<ASTAutomaton> optAutomaton = parser.parse(model); if (!parser.hasErrors() && optAutomaton.isPresent()) { return optAutomaton.get(); } Log.error(\"0xEE840 Model could not be parsed.\"); } catch (RecognitionException | IOException e) { Log.error(\"0xEE640 Failed to parse \" + model, e); } System.exit(1); return null; } public IAutomataArtifactScope createSymbolTable(ASTAutomaton ast) { IAutomataGlobalScope globalScope = AutomataMill.globalScope(); globalScope.setModelPath(new ModelPath()); globalScope.setFileExt(\"aut\"); AutomataScopesGenitorDelegator symbolTable = AutomataMill .scopesGenitorDelegator(); return symbolTable.createFromAST(ast); } } Listing 2.25: Methods for parsing and creating symbol tables. Listing 2.25 presents the implementation of the methods parse and createSymbolTable of the AutomataTool class. The methods can be used for parsing and creating symbol tables for Automata . The methods also demonstrate the usage of the mill for retrieving global scopes and genitors. public static void main(String[] args) { // delegate main to instantiatable method for better integration, // reuse, etc. new AutomataTool().run(args); } public void run(String[] args) { // use normal logging (no DEBUG, TRACE) Log.ensureInitalization(); // Retrieve the model name if (args.length != 2) { Log.error(\"0xEE7400 Arguments are: (1) input model and (2) symbol store.\"); return; } Log.info(\"Automata DSL Tool\", \"AutomataTool\"); String model = args[0]; // parse the model and create the AST representation ASTAutomaton ast = parse(model); Log.info(model + \" parsed successfully!\", \"AutomataTool\"); // setup the symbol table IAutomataArtifactScope modelTopScope = createSymbolTable(ast); // can be used for resolving names in the model Optional<StateSymbol> aSymbol = modelTopScope.resolveState(\"Ping\"); if (aSymbol.isPresent()) { Log.info(\"Resolved state symbol \\\"Ping\\\"; FQN = \" + aSymbol.get().toString(), \"AutomataTool\"); } else { Log.info(\"This automaton does not contain a state called \\\"Ping\\\";\", \"AutomataTool\"); } // setup context condition infrastructure AutomataCoCoChecker checker = new AutomataCoCoChecker(); // add a custom set of context conditions checker.addCoCo(new StateNameStartsWithCapitalLetter()); checker.addCoCo(new AtLeastOneInitialAndFinalState()); checker.addCoCo(new TransitionSourceExists()); // check the CoCos checker.checkAll(ast); // Now we know the model is well-formed and start backend // store artifact scope and its symbols AutomataSymbols2Json deser = new AutomataSymbols2Json(); deser.store(modelTopScope, args[1]); // analyze the model with a visitor CountStates cs = new CountStates(); AutomataTraverser traverser = AutomataMill.traverser(); traverser.add4Automata(cs); ast.accept(traverser); Log.info(\"Automaton has \" + cs.getCount() + \" states.\", \"AutomataTool\"); // execute a pretty printer PrettyPrinter pp = new PrettyPrinter(); AutomataTraverser traverser2 = AutomataMill.traverser(); traverser2.setAutomataHandler(pp); ast.accept(traverser2); Log.info(\"Pretty printing automaton into console:\", \"AutomataTool\"); // print the result Log.println(pp.getResult()); } Listing 2.26: Main method of the AutomataTool class The AutomataTool provides a main method, which can be called from the command line. The implementation of the method is depicted in Listing 2.26. It expects two inputs. The first is the name of a file containing an Automata model. The second input is the name of the file in which the tool should store the symbol table of the model given as first input. The method parses the input model, creates the symbol table, resolves a state, executes context conditions, stores the symbol table by using the serialization, executes the visitor for counting the states, and pretty prints the model to the standard output. Inspect the main method and try to understand the implementation for the executed tasks. Read the above descriptions again if necessary. Run the Tool The previous command compiles the handwritten and generated code including the Automata tool class AutomataTool . For running the Automata DSL tool, execute the following command: java -cp \"src/;out/;hwc/;monticore-rt.jar\" \\ -i automata.AutomataTool example/PingPong.aut \\ -s st/PingPong.autsym Please note again, on Unix systems paths are separated using \":\" (colon) instead of semicolons. Executing the command runs the Automata DSL tool. Using the option -cp makes the Java interpreter consider the compiled classes contained in the paths specified by the argument. The argument automata.AutomataTool makes the Java interpreter execute the main method of the class automata.AutomataTool contained in the directory src . The argument example/PingPong.aut is passed to the main method of the Automata DSL tool class as input. Inspect the output on the command line, which displays log messages concerning the processing of the example Automata model. The last argument st/PingPong.autsym is also passed to the main method. It makes the tool store the serialized symbol table of the input model into the file example/PingPong.aut . The shipped example Automata DSL (all sources contained in mc-workspace/src and mc-workspace/hwc ) can be used as a starting point for creating your own language. It can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described above. Using MontiCore via Gradle From the Command Line It is possible to execute MontiCore via the MontiCore plugin. A detailed description about using the MontiCore Gradle plugin is given in Chapter 16 of the MontiCore handbook . This section describes the execution of MontiCore via a Gradle plugin from the command line shell by example. Before you start, install gradle and make sure that you can use it from the command line. The shipped example Automata DSL can be used as a starting point and can be downloaded here: https://www.monticore.de/download/Automaton.zip The build script (file build.gradle ) can easily be adapted for creating build scripts for other languages. For executing MontiCore via the Gradle plugin from the command line shell by example of the Automata DSL, perform the following steps: Download the Automata example. Unzip the downloaded zip file into an arbitrary directory. Open a shell and change your working directory to the directory in which you unzipped the downloaded file (the directory containing the file build.gradle ). Execute Gradle in the shell: If you are using a Windows shell, execute the command gradle build . If you are using a Unix shell, execute the command ./gradle build . When executing the above commands, MontiCore launches, which results in the execution of the following steps: The grammars specified in the build.gradle are incrementally parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure are generated into the default output directory ../target/generated-sources/monticore/sourcecode . The contents of this generated directory are equal to the contents of the generated directory out as described in . Using MontiCore in Eclipse The MontiCore plugin can be used in Eclipse. Section 2.4.1 describes the process of setting up Eclipse. Section 2.4.2 presents how to import the example project in Eclipse. Finally, Section 2.4.3 explains how the MontiCore Gradle plugin can be executed in Eclipse. Setting up Eclipse Before you import the example project and run MontiCore as a Gradle plugin, please make sure that a current version of the Gradle plugin is installed in Eclipse. When installing a new version of Eclipse, the Gradle plugin is installed by default. If the Gradle plugin is not yet integrated into your Eclipse installation, download the latest Eclipse version or perform the following steps to install the Eclipse plugin: Download and install Eclipse (or use an existing one). Open Eclipse. Install the needed Plugins. Help > Eclipse Marketplace... Type 'gradle' in the search box and click Enter. Install the 'Buildship Gradle Integration' plugin. Make sure to configure Eclipse to use an JDK instead of an JRE. Window > Preferences > Java > Installed JREs. Importing the Example The shipped example Automata DSL can be used as a starting point. Once imported into Eclipse, it can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described in Section 2.4.3. To import the example, perform the following steps: Download and unzip the Automata example (cf. Listing 2.3) Open Eclipse and select File > Import > Gradle (if you are required to choose a Gradle version, then choose version 6.7.1) > Existing Gradle Projects > Next. Click on the Browse.. button and import the directory that contains the file build.gradle from the Automata example. Running MontiCore To execute the MontiCore Gradle plugin, perform the following steps: Select the Gradle Task menu (at the top or bottom, depending on your installed Eclipse version). There select automaton > build > build (double click). This makes Eclipse execute the MontiCore Gradle plugin as described in Section 2.3. After installing and executing MontiCore in Eclipse, your workspace should look similar to Figure 2.27. Figure 2.27: Eclipse after importing the example project and executing MontiCore Using MontiCore in IntelliJ IDEA The MontiCore plugin can be used in IDEA. Section 2.5.1 describes the process of setting up IntelliJ IDEA. Afterwards, Section 2.5.2 presents how to import the example project in Eclipse. Finally, Section 2.5.3 explains how the MontiCore Gradle plugin can be executed in IntelliJ IDEA. Setting up IntelliJ IDEA For setting up IntelliJ IDEA, perform the following steps: Download and install IntelliJ IDEA (or use your existing installation). Hint for Students: You get the Ultimate version of IntelliJ IDEA for free. Open IntelliJ IDEA. Importing the Example The shipped example Automata DSL can be used as a starting point. Once imported into IntelliJ IDEA, it can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described in Section 2.5.3. For importing the example, perform the following steps: Download and unzip the Automata Example (cf. Listing 2.3). In the IDE select: File > Open. Select the directory containing the build.gradle (if you are required to choose a Gradle version, then choose version 6.7.1). Running MontiCore To execute the MontiCore Gradle plugin, perform the following steps: Select the Gradle Projects menu on the right. From there select automaton > Tasks> build > build (double click). This makes IntelliJ IDEA execute the Gradle plugin as described in Section 2.3. If you do not see the Gradle Projects menu yet, right-click on the build.gradle file and select 'Import Gradle Project'. Now the Gradle Projects menu should occur on the right side and you can follow the above mentioned steps for the execution. After installing and executing MontiCore in IntelliJ IDEA, your workspace should look similar to Figure 2.28. Figure 2.28: IntelliJ IDEA after importing the example project and executing MontiCore Fre21 FreeMarker website. https://freemarker.org/, 2021. Using MontiCore with GitPod Installing all the prerequisites and an IDE can take some time. Alternatively to this, you can use Gitpod , an open-source Kubernetes application for ready-to-code developer environments. It already has all the prerequisites and an operational Web IDE similar to Microsoft's Visual Studio Code installed. You need to login with an existing GitHub account to use it. This link can be used to access the Gitpod project for the Automata language. First, an environment for the project with the proper Java and Gradle version will be prepared and initialized automatically. After that, you will be directed to the Web IDE. The project will be built with Gradle first, and after that it is ready-to-use. The Web IDE also has a built-in terminal which can be used to build the project via gradle build or execute other tasks. The Web IDE can be used to change existing project files, such as the Automata grammar or the handwritten classes for the language. Simply navigate to the grammars or classes in the file explorer on the left-hand side of the IDE and edit the files. This makes experimenting with MontiCore possible. The changes will be compiled by the IDE immediately and compilation errors will be marked with red color. To run the project, execute the command gradle build in the terminal. You will notice that the link to the Gitpod project is generated and always has the same pattern. An example for a link is https://indigo-ostrich-8psdfoer.ws-eu18.gitpod.io. After 30 minutes of non-use, Gitpod will \"freeze\" the environment. It can be reactivated by using the same link to access it. The environment is reactivated, and you do not even need to rebuild the project with Gradle to use the project again. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Getting Started"},{"location":"docs/GettingStarted/#getting-started-with-monticore","text":"This page describes the technical installation and usage of MontiCore for language developers. This page further inspects a simple example grammar and the Java classes and other artifacts generated from this grammar. After installing MontiCore as described on this page, it can be used to develop new modelling languages and generators as described in subsequent chapters. MontiCore provides a command line interface (CLI) tool and can easily be used with Gradle. The Gradle integration enables developers to easily employ MontiCore in commonly used integrated development environments (IDEs), such as Eclipse and IntelliJ IDEA. We strongly recommend to work through the section about the CLI tool first. The CLI section contains information about an example MontiCore project and the files generated by MontiCore. It also shortly explains some key features of MontiCore. Detailed information about all configuration options that can be used in the MontiCore CLI tool and in MontiCore Gradle projects are explained in Chapter 16 of the handbook . More information about the example Automata language are available in Chapter 21 of the handbook .","title":"Getting Started with MontiCore"},{"location":"docs/GettingStarted/#prerequisites-installing-the-java-development-kit","text":"We start with the JDK: Please perform the following steps to install the Java Development Kit (JDK) and validate that the installation was successful: Install a JDK with at least version 8 provided by Oracle or OpenJDK. Make sure the environment variable JAVA_HOME points to the installed JDK, and not to the JRE, e.g., the following would be good: /user/lib/jvm/java-8-openjdk on UNIX or C:\\Program Files\\Java\\jdk1.8.* on Windows. You will need this in order to run the Java compiler for compiling the generated Java source files. Also make sure that the system variable is set such that the Java compiler can be used from any directory. JDK installations on UNIX systems do this automatically. On Windows systems, the bin directory of the JDK installation needs to be appended to the PATH variable, e.g. %PATH%;%JAVA_HOME% . Test whether the setup was successful. Open a command line shell in any directory. Execute the command javac -version . If this command is recognized and the shell displays the version of the installed JDK (e.g., javac 1.8.0_192 ), then the setup was successful. Now we have the prerequisites to run MontiCore from the command line. The JDK installation is also required for using MontiCore with Gradle.","title":"Prerequisites: Installing the Java Development Kit"},{"location":"docs/GettingStarted/#install-and-use-the-monticore-command-line-interface","text":"This section describes instructions to perform the following first steps to use MontiCore as an CLI tool: Installation of the MontiCore distribution file. Grammar inspection Running the MontiCore generator Compiling the product Running the product, i.e. the Automata tool with an example model example/PingPong.aut .","title":"Install and Use the MontiCore Command Line Interface"},{"location":"docs/GettingStarted/#installation","text":"For installing MontiCore, perform the following steps: Download the example Automata MontiCore project: // MontiCore zip distribution source https://www.monticore.de/download/monticore.tar.gz Unzip the archive. The unzipped files include a directory called mc-workspace containing the executable MontiCore tool monticore-cli.jar along with a directory src containing handwritten Automata DSL infrastructure, a directory hwc containing handwritten code that is incorporated into the generated code, and a directory example containing an example model of the Automata DSL. // MontiCore zip distribution content in directory mc-workspace Automata.mc4 monticore-cli.jar monticore-rt.jar src/automata/AutomataTool.java src/automata/visitors/CountStates.java src/automata/prettyprint/PrettyPrinter.java src/automata/cocos/AtLeastOneInitialAndFinalState.java src/automata/cocos/StateNameStartsWithCapitalLetter.java src/automata/cocos/TransitionSourceExists.java hwc/automata/_ast/ASTState.java hwc/automata/_symboltable/AutomatonSymbol.java hwc/automata/_symboltable/AutomataSymbols2Json.java hwc/automata/_symboltable/AutomatonSymbolDeser.java hwc/automata/_symboltable/AutomataGlobalScope.java example/PingPong.aut","title":"Installation"},{"location":"docs/GettingStarted/#inspect-the-example-grammar","text":"MontiCore is a language workbench. It supports developers in developing modular modelling languages. The core of MontiCore is its grammar modelling language (cf. Chapter 4 of the MontiCore handbook ), which is used by developers for modelling context-free grammars. A MontiCore grammar defines (parts of) the abstract and concrete syntax of a language. Each grammar contains nonterminals, production rules, and may extend other grammars. At most one rule is marked as the start rule. It is a key feature of MontiCore that it allows a grammar to reuse and extend other grammars . In an extension all the nonterminals defined in the extended grammars can be reused or even overridden. This form of extension allows to achieve several effects: Language (i.e. grammar) components can be reused and integrated in larger languages, composed of several components. Individual nonterminals can be reused (like classes) from a library. A given language can be extended, allowing to add additional alternatives inside a language. Component grammars and grammar extensions are detailedly discussed in Chapter 4 of the MontiCore handbook . grammar Automata extends de.monticore.MCBasics { symbol scope Automaton = \"automaton\" Name \"{\" (State | Transition)* \"}\" ; symbol State = \"state\" Name ((\"<<\" [\"initial\"] \">>\" ) | (\"<<\" [\"final\"] \">>\" ))* ( (\"{\" (State | Transition)* \"}\") | \";\") ; Transition = from:Name \"-\" input:Name \">\" to:Name \";\" ; } Listing 2.2: The Automata grammar. In the following, we inspect the MontiCore grammar of the Automata language. Navigate your file explorer to the unzipped mc-workspace directory. The directory contains the file Automata.mc4 . This file contains the MontiCore grammar depicted in Listing 2.2. MontiCore grammars end with .mc4 . The definition of a MontiCore grammar starts with the keyword grammar , followed by the grammar's name. In this example, the grammar is called Automata . The grammar's name is optionally followed by the keyword extends and a list of grammars that are extended by the grammar. In this example, the Automata grammar extends the grammar de.monticore.MCBasics . Tip 2.3 MontiCore Key Feature: Composition The MontiCore language workbench allows to compose language components by composing grammars and also to reuse all infrastructure, such as context conditions, symbol table infrastructure, generator parts and handwritten extensions. In the example the Automata grammar extends the grammar de.monticore.MCBasics and thus reuses its functionality. MontiCore comes with an extensive library of predefined language components. Grammars can also have a package and import other grammars. If a grammar has a package, then the package declaration must be the first statement in the grammar and is of the form package QualifiedName where package is a keyword and QualifiedName is an arbitrary qualified name (e.g., de.monticore ). The optional grammar imports follow the package definition. Every import is of the form import QualifiedName . The Automata example grammar file does neither contain a package declaration nor imports. The grammar extended by the Automata grammar is specified by its fully qualified name. As usual in context-free grammars, production rules have a left-hand side and a right-hand side. The left-hand side contains the possibly annotated name of a nonterminal. The left-hand side is followed by the terminal = and the right-hand side. Nonterminal names start with an upper-case letter. For instance, the Automata grammar contains the nonterminals Automaton , State , and Transition . A single nonterminal can be annotated with the start keyword. Then, the nonterminal is the starting symbol of the grammar. If no nonterminal is annotated with start , then the first nonterminal of the grammar becomes the starting symbol by default. In the Automata grammar, the Automaton nonterminal is the starting symbol. The other possible annotations for nonterminals influence the generated classes for the abstract syntax tree as well as the generated symbol table infrastructure. Details can be found in Chapter 4 and Chapter 9 of the MontiCore handbook . For example, the Automaton nonterminal is annotated with symbol and scope . The annotation symbol makes the MontiCore generator generate a symbol class for the nonterminal. Intuitively stated, the annotation scope instructs MontiCore to construct a symbol table infrastructure that opens a scope when the production is processed. The following sections explain the effects of annotating the Automaton nonterminal with the keywords symbol and scope in more detail. Terminals are surrounded by quotation marks. The Automata grammar, for example, inter alia contains the terminals automaton , state , { , } , and ; . The right-hand sides of grammar productions consist of nonterminals, terminals, and semantic predicates, may use cardinalities ( * , + , ? ), and introduce alternatives via the terminal | as known from regular expressions. Details can be found in Chapter 4 of the MontiCore handbook . The right-hand side of the production defining the nonterminal Automaton , for example, uses the terminal automaton and the nonterminals Name , State , and Transition . The nonterminal Name is not defined in the grammar Automata . Thus, it must be defined in one of the extended grammars. In this case, Name is defined in the grammar MCBasics and is reused by the grammar Automata . For distinguishing different usages of nonterminals on right-hand sides, they can be named. For example, the right-hand side of the production defining the nonterminal Transition uses the Name nonterminal twice. The first usage is named input and the second usage is named to . MontiCore also supports interface and external nonterminals for introducing extension points as detailedly described in Chapter 4 of the MontiCore handbook . However, the example grammar does not use these concepts. automaton PingPong { state NoGame <<initial>>; state Ping; state Pong <<final>>; NoGame - startGame > Ping; Ping - stopGame > NoGame; Pong - stopGame > NoGame; Ping - returnBall > Pong; Pong - returnBall > Ping; } Listing 2.4: A model conforming to the Automata grammar. Listing 2.4 depicts an example model conforming to the Automata grammar in its concrete syntax. You can find the model in the file PingPong.aut contained in the example directory of the unzipped mc-workspace directory.","title":"Inspect the Example Grammar"},{"location":"docs/GettingStarted/#run-monticore","text":"The MontiCore generator takes a MontiCore grammar as input and generates an infrastructure for processing models conforming to the grammar. When a grammar E extends another grammar G , then all the infrastructure generated for the grammar G is reused and only the extending part from E is generated. Tip 2.5 Infrastructure Generated by MontiCore MontiCore itself as well as the infrastructure generated by the MontiCore generator are implemented in Java. This infrastructure includes: a parser for parsing models conforming to the grammar and transforming textual models into abstract syntax tree instances abstracting from the concrete syntax. a symbol table infrastructure to handle the symbols introduced or used by models conforming to the grammar. The symbol table infrastructure is used for resolving dependencies between model elements that are possibly defined in different files. a context-condition checking framework for checking well-formedness rules that cannot be captured by context-free languages. a visitor infrastructure for traversing models respectively their abstract syntax instances. The abstract syntax of a model consists of its internal representation as an abstract syntax tree abstracting from the concrete syntax of the model (the instance of the data structure obtained from parsing) and the symbol table of the model. a mill infrastructure for retrieving objects for language processing, such as parsers, builders for abstract syntax trees, visitors and objects for the symbol tables of the language. The possibility to configure the mills is crucial for reusing the functionality implemented for a sublanguage (cf. Section 5.9, Section 5.10.2, and Section 11.5 for details). a code generating framework that extends the FreeMarker template engine [Fre21] by various modularity enhancing features. For executing MontiCore using the Automata grammar as input, perform the following steps: Open a command line shell and change the working directory to the unzipped directory ( mc-workspace ). Execute the following command in order to generate the language infrastructure of the Automata DSL: java -jar monticore.jar -g Automata.mc4 -hcp hwc/ src/ -mp monticore-rt.jar The only required argument Automata.mc4 denotes the input grammar that shall be processed by MontiCore. The processing includes the generation of the language infrastructure. Using the option -hcp enables specifying the path to a directory containing the handwritten code that is to be incorporated into the generated infrastructure. In this case, passing the argument hwc/ to the option -hcp makes MontiCore consider the handwritten code located in the directory hwc/ . Providing handwritten code enables to easily incorporate additional functionality into the generated code. For example, this enables developers to extend generated abstract syntax classes as detailedly described in (cf. Section 5.10 of the MontiCore handbook ). Passing the argument -mp enables specifying the paths to directories containing paths to grammars and Java classes that are imported by the processed grammar and the related tooling. In this case, the archive monticore-rt.jar contains the grammars and handwritten extensions of the monticore standard library (not yet publicly available) . More information about the standard library can be found in Chapters 17- 20 of the handbook . Executing the command launches MontiCore, which results in the executing of the following steps: The specified grammar is parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure are generated into the default output directory out . This infrastructure consists of the directories out/automata/ containing the mill (cf. Section 5.9, Section 5.10.2, Section 11.5). out/automata/_ast containing the abstract syntax tree data structure (cf. Chapter 5 of the MontiCore handbook ). out/automata/_auxiliary containing adapted mills of sublanguages, which are required for configuring the mills of sublanguages (cf. Chapter 11 of the MontiCore handbook ). out/automata/_cocos containing the infrastructure for context conditions (cf. Chapter 10 of the MontiCore handbook ). out/automata/_od containing the infrastructure for printing object diagrams for reports produced during processing the models. out/automata/_parser containing the generated parsers, which are based on ANTLR (cf. Chapter 6 of the MontiCore handbook ). out/automata/_symboltable containing the infrastructure for the symbol table (cf. Chapter 6 of the MontiCore handbook ). out/automata/_visitor containing the infrastructure for visitors (cf. Chapter 9 of the MontiCore handbook ). out//automata containing reports created during the processing of the grammar. The output directory also contains a log file of the executed generation process with the generation time in its name. In the following, we review the classes and interfaces generated from the Automata grammar that are relevant for language engineers in more detail. We do not review the classes and interfaces that are only internally relevant for MontiCore and are usually not intended to be used by language engineers.","title":"Run MontiCore"},{"location":"docs/GettingStarted/#abstract-syntax-tree-data-structure","text":"The tree data structure is generated into the directory out/automata/_ast . Details about the generation of AST classes can be found in (cf. Chapter 5 of the MontiCore handbook ). For each nonterminal contained in the grammar, the MontiCore generator produces AST and corresponding builder classes. The AST classes implement the abstract syntax tree data structure. The builder classes implement the builder pattern for constructing instances of the respective AST classes as usual. For example, the class ASTAutomaton is the AST class generated for the Automaton nonterminal (cf. Listing 2.2) and the class ASTAutomatonBuilder is the corresponding generated builder class. Parts of the AST data structure generated for the Automata grammar. Figure 2.6: Parts of the AST data structure generated for the Automata grammar. The contents of the AST and builder classes are generated systematically from the grammar. The attributes of each AST class resemble the right-hand side of the corresponding production rule. In the following, we mainly speak of attributes, but please be aware that all attributes come fully equipped with access and modification methods, which should normally be used. For instance, Figure 2.6 depicts parts of the generated AST infrastructure for the Automata grammar. The class ASTAutomaton contains the attributes name , states , and transitions . The AST class does not contain an attribute for the terminal automaton as it is part of every word conforming to the production of the Automaton nonterminal. The type of the attribute name is String whereas the attributes states and transitions are lists of the types of the AST classes corresponding to the used nonterminals. This is the case because exactly one Name is parsed with the right-hand side of the production of the nonterminal Automaton , whereas multiple states and transitions can be parsed. The ASTAutomaton class further contains the attributes symbol , spannedScope , and enclosingScope . These attributes are specific to the symbol table of Automata models and are used for linking the symbol table of a model with its abstract syntax tree. Details can be found in Chapter 9 of the MontiCore handbook . Tip 2.7 Generated Symbols and Scopes in the AST Each AST class contains access to the enclosingScope . When a production contains the keyword symbol , the generated AST class contains the attribute symbol (see Chapter 9 of the MontiCore handbook ). Keyword scope indicates that a nonterminal also defines a new local scope, stored in attribute spannedScope . The parser builds the abstract syntax tree of a model and the available scope genitor creates the symbol table of the model, consisting of symbols and scopes. The ASTAutomaton class further contains several straight-forward methods for checking different instances for equality and accessing the attributes. Similar to the ASTAutomaton class, the ASTAutomatonBuilder class contains attributes resembling the right-hand side of the corresponding production. It further contains methods for changing the values of the attributes (e.g., addState ), checking whether the AST instance that would be constructed from the current builder state is valid (cf. isValid ), and for building the AST instance corresponding to the builder's state (cf. build ). The contents of the other AST and Builder classes are constructed analogously. Tip 2.7 Generated Symbols and Scopes in the AST If the generator detects that an AST class for a nonterminal is already implemented in the handwritten code, then it produces a corresponding TOP AST class instead. This TOP mechanism allows developers to add handwritten extensions to any generated class, while reusing the generated TOP class via extension. This gives a very close integration between handwritten and generated code that even adapts builders accordingly, while preventing the very bad habit of performing manual changes to the generated code. Option -hcp tells the generator where to look for handwritten integrations. The following section presents the methods of the classes for parsing textual models (possibly stored in files) into AST class instances at runtime. For now, it suffices for you to understand that (1) MontiCore generates an extensible AST data structure that resembles the nonterminals and productions of the grammar in a straight-forward way and (2) that all models of a grammar have an AST data structure representation for internal processing.","title":"Abstract Syntax Tree Data Structure"},{"location":"docs/GettingStarted/#parser","text":"The infrastructure is generated into the directory out/automata/_parser . Details about the generated parsers and their uses are described in Chapter 6 of the MontiCore handbook . Parts of the class AutomataParser generated from the Automata grammar. Figure 2.9: Parts of the class AutomataParser generated from the Automata grammar. Parts of the generated class AutomataParser are depicted in Figure 2.9. The class implements the generated parser for the Automata grammar. Usually, developers are solely concerned with the methods parse(String) and parse_String(String) . For now, it suffices if you remember that parsing textual Automata models stored in files is possible by calling the method parse(String) of an AutomataParser object with the fully qualified name of the file as input. Tip 2.10 Methods for Parsing The class AutomataParser contains the methods parse(Reader r) , parse(String filename) , and parse_String(String content) . All of the methods return an object of type Optional<ASTAutomaton> , where absence means failure of parsing and errors have been issued. For each nonterminal in the grammar, the class further contains methods for parsing a sub-model described by this nonterminal.","title":"Parser"},{"location":"docs/GettingStarted/#symbol-table","text":"The infrastructure is generated into the directory out/automata/_symboltable . Details about the generated symbol table infrastructure and its use are described in Chapter 9 of the MontiCore handbook . The symbol table infrastructure is used for resolving cross-references concerning information defined in different model elements that are potentially defined in different models stored in different files. Figure 2.11: The scope classes generated from the `Automata` grammar. Tip 2.12 Scope Classes For the Automata grammar, the generator produces the classes AutomataScope , AutomataArtifactScope , and AutomataGlobalScope as well as respective interfaces. The relationships between these classes and interfaces are depicted in Figure 2.11. The singleton AutomataGlobalScope contains all AutomataArtifactScopes of all loaded Automata artifacts. AutomataScope s represent scopes spanned inside of models. Figure 2.13: Parts of the symbol classes generated from the Automata grammar. Figure 2.13 depicts parts of the symbol classes generated for the Automata grammar. As the nonterminal State is annotated with symbol in the Automata grammar, the generator produces the class StateSymbol . The StateSymbol class, inter alia, contains the attributes name , enclosingScope , and spannedScope . The attribute name stores the name of the symbol. The attributes enclosingScope and spannedScope store the enclosing and spanned scopes of the symbol. The class further contains methods for accessing and setting the attributes. For all symbol classes, the MontiCore generator also produces builder classes (e.g., AutomataArtifactScopeBuilder and StateSymbolBuilder ). Tip 2.14 Extending Symbol Classes It is possible to add further methods and attributes in two ways: adding a symbol rule in the grammar (described in Chapter 9 of the MontiCore handbook ) or using the TOP mechanism applied to the generated symbols. The generated class AutomataScopesGenitor is responsible for creating the scope structure of Automata artifacts and linking the scope structure with the corresponding AST nodes. For this task, it provides the method createFromAST that takes an ASTAutomaton instance as input and returns an IAutomataArtifactScope instance. The returned IAutomataArtifactScope instance can be added as a subscope to the (during runtime unique and administrated by the mill) AutomataGlobalScope instance. Developers can create visitors for complementing the symbol table (creating symbols and filling the extensions introduced via symbol rules or the TOP mechanism) of an Automata artifact. After creating the scope structure, the visitor should be used to traverse the AST instance of the artifact for complementing the symbols and scopes. The following sections explain the generated visitor infrastructure in more detail. Optional<AutomatonSymbol> resolveAutomaton(String name) List<AutomatonSymbol> resolveAutomatonMany(String name) Optional<StateSymbol> resolveState(String name) List<StateSymbol> resolveStateMany(String name) Listing 2.15: Different resolve methods. For each nonterminal annotated with symbol in the grammar Automata , the scope interfaces contain a symbol-specific resolve method taking a string as input. The method can be called to resolve symbol instances by their names. The name given as input to a resolve method should be as qualified as needed to find the symbol. For instance, Listing 2.15 lists the signatures of four of the resolve methods provided by the interface IAutomataScope . For now, it suffices for you to understand that (1) MontiCore generates an extensible symbol table data structure that resembles the scope and symbol structure as specified in the grammar in a straight-forward way and (2) that all models of a grammar have a symbol table data structure representation for internal processing and (3) that symbols can be resolved from scopes via calling the resolve methods.","title":"Symbol Table"},{"location":"docs/GettingStarted/#deserialization-of-symbol-tables","text":"MontiCore also supports the serialization and deserialization of symbol tables. The (de)serialization is crucial for incremental code generation and efficient language composition via aggregation. Details about this are explained in Chapter 7 and Chapter 9 of the MontiCore handbook . For the (de)serialization, the generator produces the class AutomataSymbol2Json . It provides the public methods store and load . The former can be used to serialize IAutomataScope instances into their string representations encoded in JSON and persisting these to a file at a location that is passed as method argument. The latter can be used to load a stored IAutomataScope into its objects representation. For now, it suffices that you understand which methods to call for the (de)serialization.","title":"(De)Serialization of Symbol Tables"},{"location":"docs/GettingStarted/#visitor","text":"Figure 2.16: Parts of the visitor infrastructure generated from the Automata grammar The infrastructure is generated into the directory out/automata/_visitor . Details about the generated visitor infrastructure are described in Chapter 8 of the MontiCore handbook . For each grammar, the generator systematically produces several classes and interfaces implementing the visitor infrastructure. For the Automata grammar, for example, the generator produces the interfaces AutomataTraverser , AutomataVisitor2 , and AutomataHandler and the class AutomataTraverserImplementation . The relationships between these interfaces and classes are depicted in Figure 2.16. The interfaces Traverser , Visitor2 and Handler together realize the Visitor pattern. Conceptually, the traverser is the entry point for traversing. The traverser manages visitors for the different sublanguages and realizes the default traversing strategy. Whenever an AST node is traversed, the traverser delegates the visit to the corresponding visitor implementation. If a special traversal is to be implemented that differs from the default, it is possible to add handlers to the traverser that realize the alternative traversal. For a more detailed explanation consider reading Chapter 8 of the MontiCore handbook . Tip 2.17 Visitors MontiCore provides the visitor pattern in a detangled and thus flexible variant. AutomataTraverser is traversing the AST. AutomataVisitor2 contain the actual functionalities, added through subclassing. Many visitors can be added to the traverser for parallel execution via the method add4Automata . The visitors are compositional, allowing to maximize reuse of visitors from sublanguages, and they can be adapted through the TOP mechanism. For example, the handwritten class PrettyPrinter , which can be found in the directory mc-workspace/src/automata/prettyprint , implements functionality for pretty printing an Automata model, which is given by its abstract syntax tree. Listing 2.18 depicts the attributes and the constructor of the class. The PrettyPrinter class implements the AutomataHandler interface. Its constructor instantiates a printer (a helper for printing indented strings) and retrieves an AutomataTraverser object from the mill (which is explained later on). It sets the handler of the traverser to itself. This ensures that the pretty printer becomes the handler of the traverser. We will execute it in a following section. public class PrettyPrinter implements AutomataHandler { private final IndentPrinter printer; private AutomataTraverser traverser; public PrettyPrinter() { this.printer = new IndentPrinter(); this.traverser = AutomataMill.traverser(); traverser.setAutomataHandler(this); } // further methods } Listing 2.18: Attributes and constructor of the PrettyPrinter for the Automata language. For now, you should understand that (1) for implementing visitors it is often sufficient to implement the visitor interfaces and to add them to a traverser and (2) custom traversals can be realized by implementing handlers and adding those to the traverser.","title":"Visitor"},{"location":"docs/GettingStarted/#context-conditions","text":"The infrastructure is generated into the directory out/automata/_cocos . Details about the generated context condition infrastructure are described in Chapter 10 of the MontiCore handbook . For each nonterminal of a grammar, the generator produces a context condition interface for implementing context conditions for this nonterminal. For the Automata grammar, for example, the generator produced the interface AutomataASTStateCoCo . The interface solely contains the method check(ASTState) . Each class implementing the interface should represent a predicate over subtrees of abstract syntax trees starting at a node with the type corresponding to the nonterminal. The check method should be implemented such that it reports an error or a warning if the input node does not satisfy the predicate. Thus, context conditions implement well-formedness rules that cannot be captured by context-free grammars (or that are intentionally not captured by the grammar to achieve a specific AST data structure). For producing the error or warning, the static methods error and warning of the MontiCore runtime class Log should be used. For the Automata grammar, the generator also produced the class AutomataCocoChecker . For each nonterminal of the grammar, the class contains a method for adding context condition instances to an AutomataCocoChecker instance. For checking whether an AST node satisfies all registered context conditions, the method checkAll can be called with the AST node as input. Calling the method makes the checker traverse the abstract syntax tree and check whether each node satisfies the context conditions registered for the node. Thus, AutomataCocoChecker instances represent sets of context conditions that are required to be satisfied by abstract syntax tree instances. For now, you should understand that (1) implementing context conditions is possible via implementing the generated CoCo interfaces and (2) context conditions can be checked via instantiating the Checker class, adding the CoCos, and calling the checkAll method.","title":"Context Conditions"},{"location":"docs/GettingStarted/#mill-as-factory-for-builders","text":"The for the Automata language is generated into the directory out/automata/ . Details about the generated mill and the mill pattern in general are described in Section 11.5. The generated mill class AutomataMill is responsible for providing ready to use and correct parser, scope genitor, scope, and builder instances. The mill of each language is a singleton. Tip 2.19 Mill Use and Automatic Initialization A mill is a factory for builders and other commonly used functions, such as parsers or visitors. The mill was introduced to ensure compositionality of languages, while retaining reusability of functions developed for sublanguages. Only one mill instance exists, even though in composed languages it is available under several static signatures. Let language G2 extend another language G1 . Then G2Mill initializes the G1Mill appropriately, such that all the code of the sublanguage G1 can be reused in the tools developed for the language G2 , even when creating new AST nodes, symbols, etc. Cool mechanism and the developers don't have to bother. public static IAutomataGlobalScope globalScope() public static IAutomataArtifactScope artifactScope() public static IAutomataScope scope() public static AutomataScopesGenitor scopesGenitor () public static AutomataScopesGenitorDelegator scopesGenitorDelegator() public static ASTAutomatonBuilder automatonBuilder() public static AutomatonSymbolBuilder automatonSymbolBuilder() public static AutomataParser parser() public static AutomataTraverser traverser () Listing 2.20: Some method of the AutomataMill . Developers should retrieve all instances of the classes and interfaces provided by the mill by using the mill. Instances of the classes and interfaces that are provided by the mill should never be instantiated manually. Otherwise, it may be the case that not all of the code implemented for the language can be reused as expected in other languages extending the language. Listing 2.20 shows some signatures of the methods of the AutomataMill . Tip 2.12 Mill Methods A mill provides public static methods for retrieving the instances of the parsers, scope genitors, scopes, and builders. For that is acts like a factory. Because a mill is realized using the static delegator pattern (cf. Section 11.1), it still can be adapted at will. This combines the advantage of general availability with the advantage of being able to override the functions. For now, you should understand that (1) the methods of the mill should be used for creating ready to use and correct parser, scope genitor, scope, and builder instances and (2) how to call these methods.","title":"Mill as Factory for Builders"},{"location":"docs/GettingStarted/#compile-the-target","text":"Section 2.2.3 describes how to generate the desired Java code from a MontiCore grammar. For these Java classes, generated for the Automata DSL, execute the following command: javac -cp monticore.jar -sourcepath \"src/;out/;hwc/\" \\ src/automata/AutomataTool.java Please note, on Unix systems paths are separated using \":\" (colon) instead of semicolons. Providing the option -cp with the argument monticore-cli.jar makes the Java compiler consider the compiled MontiCore runtime classes contained in the file monticore-cli.jar . The option -sourcepath enables to specify paths to directories containing the source files that should be considered during the compilation. In this case, executing the command makes the Java compiler consider all generated classes located in and all handwritten classes located in src and hwc . The last argument instructs the Java compiler to compile the class src/automata/AutomataTool.java . Please note that the structure of the handwritten classes follows the package layout of the generated code, i.e. there are the following sub directories (Java packages): src/automata contains the top-level language realization for using the generated DSL infrastructure. In this case the class src/automata/AutomataTool.java constitutes a main class executable for processing automata models with the automata DSL. src/automata/cocos contains infrastructure for context condition of the automata DSL. src/automata/prettyprint contains an exemplary use of the generated visitor infrastructure for processing parsed models for pretty printing. src/automata/visitors contains an exemplary analysis using the visitor infrastructure. The exemplary analysis counts the states contained in the parsed automata model. hwc/automata/_ast contains an exemplary usage of the handwritten code integration mechanism for modifying the AST for the automata DSL. Details about the integration mechanism are described in Section 5.10. hwc/automata/_symboltable contains handwritten extensions of the generated symbol table infrastructure. Details about implementing handwritten symbol table infrastructure extensions are described in Chapter 9 of the MontiCore handbook . Please, also do not mix the code for the Automata tool vs. the code for the final product, generated from that tool, although both have a similar package structure. We already described the contents of the directories hwc/automata/_ast and hwc/automata/_symboltable in the previous section. They contain handwritten extensions of the abstract syntax of the Automata language. public class CountStates implements AutomataVisitor2 { private int count = 0; @Override public void visit(ASTState node) { count++; } public int getCount() { return count; } } Listing 2.22: The CountStates visitor implementation The directory src/automata/visitors contains the file CountStates.java . The class is depicted in Listing 2.22. It implements a simple visitor for counting the number of states contained in an Automata model. To this effect, it implements the AutomataVisitor2 interface. It has an attribute count of type int for storing the current number of counted nodes. It overrides the visit method for ASTState to increase the counter whenever a state is visited. The directory src/automata/cocos contains the context-condition implementations for the Automata language. public class AtLeastOneInitialAndFinalState implements AutomataASTAutomatonCoCo { @Override public void check(ASTAutomaton automaton) { boolean initialState = false; boolean finalState = false; for (ASTState state : automaton.getStateList()) { if (state.isInitial()) { initialState = true; } if (state.isFinal()) { finalState = true; } } if (!initialState || !finalState) { // Issue error... Log.error(\"0xA0116 An automaton must have at least one initial and one final state.\", automaton.get_SourcePositionStart()); } } } Listing 2.23: Context condition implementation for checking that there exist at least one initial and at least one final state. Listing 2.23 depicts the class AtLeastOneInitialAndFinalState . The class implements a context condition for checking whether an Automata model contains at least one initial and at least one final state. To this effect, the class implements the interface AutomataASTAutomatonCoCo . The class StateNameStartsWithCapitalLetter is implemented similarly. public class TransitionSourceExists implements AutomataASTTransitionCoCo { @Override public void check(ASTTransition node) { IAutomataScope enclosingScope = node.getEnclosingScope(); Optional<StateSymbol> sourceState = enclosingScope.resolveState(node.getFrom()); if (!sourceState.isPresent()) { // Issue error... Log.error( \"0xADD03 Source state of transition missing.\", node.get_SourcePositionStart()); } } } Listing 2.24: Context condition implementation for checking that states used in transitions exist. Listing 2.24 presents the implementation of the class TransitionSourceExists . The class implements a context condition for checking whether the source states used in transitions are defined. To this effect, the class uses the resolving mechanisms of the symbol table. For each transition, the context conditions tries to resolve the state symbol corresponding to the source state of the transition. If the resolving fails for the state, then the context condition logs an error. The class AutomataTool is the main class of the Automata language. It is defined in the file AutomataTool.java contained in the directory src/automata . public class AutomataTool { // main method missing in this listing public ASTAutomaton parse(String model) { try { AutomataParser parser = new AutomataParser() ; Optional<ASTAutomaton> optAutomaton = parser.parse(model); if (!parser.hasErrors() && optAutomaton.isPresent()) { return optAutomaton.get(); } Log.error(\"0xEE840 Model could not be parsed.\"); } catch (RecognitionException | IOException e) { Log.error(\"0xEE640 Failed to parse \" + model, e); } System.exit(1); return null; } public IAutomataArtifactScope createSymbolTable(ASTAutomaton ast) { IAutomataGlobalScope globalScope = AutomataMill.globalScope(); globalScope.setModelPath(new ModelPath()); globalScope.setFileExt(\"aut\"); AutomataScopesGenitorDelegator symbolTable = AutomataMill .scopesGenitorDelegator(); return symbolTable.createFromAST(ast); } } Listing 2.25: Methods for parsing and creating symbol tables. Listing 2.25 presents the implementation of the methods parse and createSymbolTable of the AutomataTool class. The methods can be used for parsing and creating symbol tables for Automata . The methods also demonstrate the usage of the mill for retrieving global scopes and genitors. public static void main(String[] args) { // delegate main to instantiatable method for better integration, // reuse, etc. new AutomataTool().run(args); } public void run(String[] args) { // use normal logging (no DEBUG, TRACE) Log.ensureInitalization(); // Retrieve the model name if (args.length != 2) { Log.error(\"0xEE7400 Arguments are: (1) input model and (2) symbol store.\"); return; } Log.info(\"Automata DSL Tool\", \"AutomataTool\"); String model = args[0]; // parse the model and create the AST representation ASTAutomaton ast = parse(model); Log.info(model + \" parsed successfully!\", \"AutomataTool\"); // setup the symbol table IAutomataArtifactScope modelTopScope = createSymbolTable(ast); // can be used for resolving names in the model Optional<StateSymbol> aSymbol = modelTopScope.resolveState(\"Ping\"); if (aSymbol.isPresent()) { Log.info(\"Resolved state symbol \\\"Ping\\\"; FQN = \" + aSymbol.get().toString(), \"AutomataTool\"); } else { Log.info(\"This automaton does not contain a state called \\\"Ping\\\";\", \"AutomataTool\"); } // setup context condition infrastructure AutomataCoCoChecker checker = new AutomataCoCoChecker(); // add a custom set of context conditions checker.addCoCo(new StateNameStartsWithCapitalLetter()); checker.addCoCo(new AtLeastOneInitialAndFinalState()); checker.addCoCo(new TransitionSourceExists()); // check the CoCos checker.checkAll(ast); // Now we know the model is well-formed and start backend // store artifact scope and its symbols AutomataSymbols2Json deser = new AutomataSymbols2Json(); deser.store(modelTopScope, args[1]); // analyze the model with a visitor CountStates cs = new CountStates(); AutomataTraverser traverser = AutomataMill.traverser(); traverser.add4Automata(cs); ast.accept(traverser); Log.info(\"Automaton has \" + cs.getCount() + \" states.\", \"AutomataTool\"); // execute a pretty printer PrettyPrinter pp = new PrettyPrinter(); AutomataTraverser traverser2 = AutomataMill.traverser(); traverser2.setAutomataHandler(pp); ast.accept(traverser2); Log.info(\"Pretty printing automaton into console:\", \"AutomataTool\"); // print the result Log.println(pp.getResult()); } Listing 2.26: Main method of the AutomataTool class The AutomataTool provides a main method, which can be called from the command line. The implementation of the method is depicted in Listing 2.26. It expects two inputs. The first is the name of a file containing an Automata model. The second input is the name of the file in which the tool should store the symbol table of the model given as first input. The method parses the input model, creates the symbol table, resolves a state, executes context conditions, stores the symbol table by using the serialization, executes the visitor for counting the states, and pretty prints the model to the standard output. Inspect the main method and try to understand the implementation for the executed tasks. Read the above descriptions again if necessary.","title":"Compile the Target"},{"location":"docs/GettingStarted/#run-the-tool","text":"The previous command compiles the handwritten and generated code including the Automata tool class AutomataTool . For running the Automata DSL tool, execute the following command: java -cp \"src/;out/;hwc/;monticore-rt.jar\" \\ -i automata.AutomataTool example/PingPong.aut \\ -s st/PingPong.autsym Please note again, on Unix systems paths are separated using \":\" (colon) instead of semicolons. Executing the command runs the Automata DSL tool. Using the option -cp makes the Java interpreter consider the compiled classes contained in the paths specified by the argument. The argument automata.AutomataTool makes the Java interpreter execute the main method of the class automata.AutomataTool contained in the directory src . The argument example/PingPong.aut is passed to the main method of the Automata DSL tool class as input. Inspect the output on the command line, which displays log messages concerning the processing of the example Automata model. The last argument st/PingPong.autsym is also passed to the main method. It makes the tool store the serialized symbol table of the input model into the file example/PingPong.aut . The shipped example Automata DSL (all sources contained in mc-workspace/src and mc-workspace/hwc ) can be used as a starting point for creating your own language. It can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described above.","title":"Run the Tool"},{"location":"docs/GettingStarted/#using-monticore-via-gradle-from-the-command-line","text":"It is possible to execute MontiCore via the MontiCore plugin. A detailed description about using the MontiCore Gradle plugin is given in Chapter 16 of the MontiCore handbook . This section describes the execution of MontiCore via a Gradle plugin from the command line shell by example. Before you start, install gradle and make sure that you can use it from the command line. The shipped example Automata DSL can be used as a starting point and can be downloaded here: https://www.monticore.de/download/Automaton.zip The build script (file build.gradle ) can easily be adapted for creating build scripts for other languages. For executing MontiCore via the Gradle plugin from the command line shell by example of the Automata DSL, perform the following steps: Download the Automata example. Unzip the downloaded zip file into an arbitrary directory. Open a shell and change your working directory to the directory in which you unzipped the downloaded file (the directory containing the file build.gradle ). Execute Gradle in the shell: If you are using a Windows shell, execute the command gradle build . If you are using a Unix shell, execute the command ./gradle build . When executing the above commands, MontiCore launches, which results in the execution of the following steps: The grammars specified in the build.gradle are incrementally parsed and processed by MontiCore. Java source files for the corresponding DSL infrastructure are generated into the default output directory ../target/generated-sources/monticore/sourcecode . The contents of this generated directory are equal to the contents of the generated directory out as described in .","title":"Using MontiCore via Gradle From the Command Line"},{"location":"docs/GettingStarted/#using-monticore-in-eclipse","text":"The MontiCore plugin can be used in Eclipse. Section 2.4.1 describes the process of setting up Eclipse. Section 2.4.2 presents how to import the example project in Eclipse. Finally, Section 2.4.3 explains how the MontiCore Gradle plugin can be executed in Eclipse.","title":"Using MontiCore in Eclipse"},{"location":"docs/GettingStarted/#setting-up-eclipse","text":"Before you import the example project and run MontiCore as a Gradle plugin, please make sure that a current version of the Gradle plugin is installed in Eclipse. When installing a new version of Eclipse, the Gradle plugin is installed by default. If the Gradle plugin is not yet integrated into your Eclipse installation, download the latest Eclipse version or perform the following steps to install the Eclipse plugin: Download and install Eclipse (or use an existing one). Open Eclipse. Install the needed Plugins. Help > Eclipse Marketplace... Type 'gradle' in the search box and click Enter. Install the 'Buildship Gradle Integration' plugin. Make sure to configure Eclipse to use an JDK instead of an JRE. Window > Preferences > Java > Installed JREs.","title":"Setting up Eclipse"},{"location":"docs/GettingStarted/#importing-the-example","text":"The shipped example Automata DSL can be used as a starting point. Once imported into Eclipse, it can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described in Section 2.4.3. To import the example, perform the following steps: Download and unzip the Automata example (cf. Listing 2.3) Open Eclipse and select File > Import > Gradle (if you are required to choose a Gradle version, then choose version 6.7.1) > Existing Gradle Projects > Next. Click on the Browse.. button and import the directory that contains the file build.gradle from the Automata example.","title":"Importing the Example"},{"location":"docs/GettingStarted/#running-monticore","text":"To execute the MontiCore Gradle plugin, perform the following steps: Select the Gradle Task menu (at the top or bottom, depending on your installed Eclipse version). There select automaton > build > build (double click). This makes Eclipse execute the MontiCore Gradle plugin as described in Section 2.3. After installing and executing MontiCore in Eclipse, your workspace should look similar to Figure 2.27. Figure 2.27: Eclipse after importing the example project and executing MontiCore","title":"Running MontiCore"},{"location":"docs/GettingStarted/#using-monticore-in-intellij-idea","text":"The MontiCore plugin can be used in IDEA. Section 2.5.1 describes the process of setting up IntelliJ IDEA. Afterwards, Section 2.5.2 presents how to import the example project in Eclipse. Finally, Section 2.5.3 explains how the MontiCore Gradle plugin can be executed in IntelliJ IDEA.","title":"Using MontiCore in IntelliJ IDEA"},{"location":"docs/GettingStarted/#setting-up-intellij-idea","text":"For setting up IntelliJ IDEA, perform the following steps: Download and install IntelliJ IDEA (or use your existing installation). Hint for Students: You get the Ultimate version of IntelliJ IDEA for free. Open IntelliJ IDEA.","title":"Setting up IntelliJ IDEA"},{"location":"docs/GettingStarted/#importing-the-example_1","text":"The shipped example Automata DSL can be used as a starting point. Once imported into IntelliJ IDEA, it can easily be altered to specify your own DSL by adjusting the grammar and the handwritten Java sources and rerunning MontiCore as described in Section 2.5.3. For importing the example, perform the following steps: Download and unzip the Automata Example (cf. Listing 2.3). In the IDE select: File > Open. Select the directory containing the build.gradle (if you are required to choose a Gradle version, then choose version 6.7.1).","title":"Importing the Example"},{"location":"docs/GettingStarted/#running-monticore_1","text":"To execute the MontiCore Gradle plugin, perform the following steps: Select the Gradle Projects menu on the right. From there select automaton > Tasks> build > build (double click). This makes IntelliJ IDEA execute the Gradle plugin as described in Section 2.3. If you do not see the Gradle Projects menu yet, right-click on the build.gradle file and select 'Import Gradle Project'. Now the Gradle Projects menu should occur on the right side and you can follow the above mentioned steps for the execution. After installing and executing MontiCore in IntelliJ IDEA, your workspace should look similar to Figure 2.28. Figure 2.28: IntelliJ IDEA after importing the example project and executing MontiCore Fre21 FreeMarker website. https://freemarker.org/, 2021.","title":"Running MontiCore"},{"location":"docs/GettingStarted/#using-monticore-with-gitpod","text":"Installing all the prerequisites and an IDE can take some time. Alternatively to this, you can use Gitpod , an open-source Kubernetes application for ready-to-code developer environments. It already has all the prerequisites and an operational Web IDE similar to Microsoft's Visual Studio Code installed. You need to login with an existing GitHub account to use it. This link can be used to access the Gitpod project for the Automata language. First, an environment for the project with the proper Java and Gradle version will be prepared and initialized automatically. After that, you will be directed to the Web IDE. The project will be built with Gradle first, and after that it is ready-to-use. The Web IDE also has a built-in terminal which can be used to build the project via gradle build or execute other tasks. The Web IDE can be used to change existing project files, such as the Automata grammar or the handwritten classes for the language. Simply navigate to the grammars or classes in the file explorer on the left-hand side of the IDE and edit the files. This makes experimenting with MontiCore possible. The changes will be compiled by the IDE immediately and compilation errors will be marked with red color. To run the project, execute the command gradle build in the terminal. You will notice that the link to the Gitpod project is generated and always has the same pattern. An example for a link is https://indigo-ostrich-8psdfoer.ws-eu18.gitpod.io. After 30 minutes of non-use, Gitpod will \"freeze\" the environment. It can be reactivated by using the same link to access it. The environment is reactivated, and you do not even need to rebuild the project with Gradle to use the project again.","title":"Using MontiCore with GitPod"},{"location":"docs/GettingStarted/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/Languages/","text":"MontiCore Languages of Level II - an Overview MontiCore is a language workbench with an explicit notion of language components. It uses grammars to describe textual DSLs. MontiCore uses an extended grammar format that allows to compose language components via inheritance, embedding and aggregation (see the reference manual for details). A language component is mainly represented through (1) the grammar describing concrete and abstract syntax of the language, (2) Java-classes implementing specific functionalities, and (3) Freemarker-Templates helping to print a model to text. However, language components are often identified with their main component grammar. Language components are currently organized in two levels: In this list you mainly find grammars for complete (but also reusable and adaptable) languages (Level II). A list of grammar components with individual reusable nonterminals is also available in the MontiCore core project ( development status ) (Level I). The following list contains the language grammars found in the MontiCore projects, such as cd4analysis/cd4analysis . They are usually contained in project folders like src/main/grammars/ and organized in packages like de.monticore.cd . Publicly available MontiCore projects are hosted at https://github.com/MontiCore . List of Languages Class Diagram For Analysis (CD4A) (MontiCore stable) CD4A is the textual representation to describe UML class diagrams (it uses the UML/P variant). CD4A covers classes, interfaces, inheritance, attributes with types, visibilities , and all kinds of associations and composition , including qualified and ordered associations . Classes can be placed in different packages . An example: classdiagram MyLife { abstract class Person { int age; Date birthday; List<String> nickNames; } package com.universityLib { <<myStereotype>> class Student extends Person { StudentStatus status; } enum StudentStatus { ENROLLED, FINISHED; } } composition Person -> Address [*] {ordered}; association [0..2] Person (parent) <-> (child) Person [*]; association phonebook Person [String] -> PhoneNumber ; } CD4A focuses on the analysis phase in typical data-driven development projects and is therefore mainly for data modelling. Consequently, it omits method signatures and complex generics. The primary use of the CD4A language is therefore data modelling . The CD4A language opens various possibilities for the development of data structures, database tables as well as data transport infrastructures in cloud and distributed systems. Main grammar de.monticore.cd.CD4Analysis and detailed description Class Diagram for Code (CD4Code) (MontiCore stable) CD4Code describes UML class diagrams . CD4Code is a conservative extension of CD4A , which includes method signatures. An example: classdiagram MyLife2 { // like CD4A but also allows: class Person { protected List<Person> closestFriends(int n); void addFriend(Person friends...); <<myStereotype>> void relocate(); } } CD4Code is often used as tool-internal AST that allows to map any kind of source models to a class/attribute/method/association based intermediate structure, before it is printed e.g. as Java code. For example a transformation sequence could be: MontiCoreCLI : Grammar -> Grammar AST encoded in CD4Code -> Decoration for custom behavior -> Java code Statechart -> State pattern encoded in CD4Code -> Decoration by monitoring methods -> Java code. Main grammar de.monticore.cd.CD4Code and detailed description (see Section CD4Code ) Feature Diagrams (MontiCore stable) Language for feature models and feature configurations. Feature diagrams are used to model (software) product lines and their variants . Feature configurations select a subset of features of a feature model to describe a product of the product line. An example: featurediagram MyPhones { Phone -> Memory & OS & Camera? & Screen; Memory -> Internal & External?; Internal -> [1..2] of {Small, Medium, Large}; OS -> iOS ^ Android; Screen -> Flexible | FullHD; Camera requires (iOS && External) || Android ; } Rules F -> ... have a parent feature (left-hand side) and its child features (right-hand side). Operators are: optional feature ? , and & , or | , xor ^ , and subset cardinality constraints, like [1..2] of ... . Further, a feature model may define cross-tree constraints using logic operators and && , or || , implication requires , etc. * Main grammar FeatureDiagram and detailed description GUI DSL (not yet publicly available) (Alpha: Intention to become stable) Language for textual definition of Graphical User Interfaces of Web Applications GUI DSL covers GUI elements and relevant configuration, which include layout elements, widgets , their style definition and references to data sources . Language is mainly used to describe GUI of Web Applications . The models of the language represents graphical views or their parts, omitting smaller details of style definition and simplifying connection between graphical elements and data sources. Currently, new version of the GUIDSL is being developed: Basis grammar GUIBasis (not yet publicly available) includes constructs for general visualization component definitions, control statements and components for layout description. Example models (not yet publicly available) can be found in the same repository. Main grammar GUIDSL (not yet publicly available) includes basic concepts and more specific implementation of component configuration. In projects legacy version is currently used: Examples: MaCoCo (not yet publicly available) , Ford Main grammar GUIDSL (not yet publicly available) includes definitions of MontiGem visualisation components, which are based on abstract concepts, described in core grammar GUIDSLCore (not yet publicly available) . Detailed description (not yet publicly available) and documentation (not yet publicly available) . MontiCore Grammar (MontiCore Stable) Language for MontiCore Grammars itself. It can be understood as meta language , but also used as ordinary language. Its main use currently: A MontiCore grammar defines the concrete syntax and the abstract syntax of a textual language. Examples: All languages on this page are defined using MontiCore grammars and thus conform to this Grammar. Main features: Define nonterminals and their productions in EBNF, lexical token as regular expressions. Most important extensions to standard grammars: Abstract , interface and external productions allow to define extensible component grammars (object-oriented grammar style). Inherited productions can be redefined (overwritten) as well as conservatively extended. Symbol and scope infrastructure is defined by simple keywords. Symbols definition places can be introduced and symbol referencing places defined, such that for standard cases automatically symbol tables can be added. Additional attributes and methods can be added to the abstract syntax only. Various elements, such as semantic predicates and actions can be defined in the same style as the underlying ANTLR. MontiCore grammars can be left recursive and even allow mutual recursion. This is e.g. useful for expression hierarchies. Additional elements, such as enum productions and comfortable operations for grammar definitions exist. Main grammars de.monticore.grammar.Grammar defines the language with some open parameters and de.monticore.grammar.Grammar_WithConcepts binds the external, imported expressions, method bodies, etc. Detailed description in the MontiCore Reference Manual. JSON (MontiCore Stable) The MontiCore language for parsing JSON artifacts. An example: { \"Alice\": { \"fullname\": \"Alice Anderson\", \"address\": { \"postal_code\": 10459, \"street\": \"Beck Street\", \"number\": 56 } }, \"Bob\": { ... }, \"Caroll\": { ... }, ... } The JSON grammar adheres to the common JSON standard and allows parsing arbitrary JSON artifacts for further processing. Actually the grammar represents a slight superset to the official JSON standard. It is intended for parsing JSON-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced JSON documents only. Please note that JSON (like XML or ASCII) is primarily a carrier language. The concrete JSON dialect and the question, how to recreate the real objects / data structures, etc. behind the JSON tree structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.JSON and detailed description MontiArc (not yet publicly available) (MontiCore Stable) MontiArc is an architecture and behavior modeling language and framework that provides a platform independent structure and behavior modeling language with an extensible code generation framework. MontiArc covers components their ports , connectors between components and embedded statecharts for component behavior description. Statecharts define states and transitions with conditions on the incoming messages as well as transition actions. An example: component InteriorLight { // MontiArc language port in Boolean lightSignal, // ports in Boolean doorSignal out OnOff status; ORGate or; // used subcomponents lightSignal -> or.a; // connectors doorSignal -> or.b; or.c -> cntr.signal; component LightController cntr { // freshly defined subcomponent port in OnOff signal, out OnOff status; statechart { // with behavior by a Statechart initial state Off / {status = OFF}; state On; Off -> On [ signal == true ] / {status = ON} On -> Off [ signal == false ] / {status = OFF} } } cntr.status -> status; } MontiArc's main goal is to provide a textual notation for Component&Connector diagrams, which is used quite often in various variants in industry. E.g. SysML's BDD, UML's component composition diagrams use the same paradigm. MontiArc does not define data types for their signals, but assumes that these types can be imported (e.g. from a class diagram). MontiArc itself also has no timing predefined, but for a complete language a concrete timing, such as formally grounded by Focus, should be added. Main grammar MontiArc.mc4 (not yet publicly available) and detailed description (not yet publicly available) OCL/P (MontiCore Stable) OCL/P is the textual representation of the UML OCL standard, adapted with Java-like syntax. Its main goal is the usage in combination with other languages like CD4A or Object Diagrams as an integrated part of that languages. OCL/P allows to define invariants and pre-/post-conditions in the known OCL style plus some extensions, such as a generalized let construction. Furthermore, it offers a large set expressions to model constraints. These expressions include Java expressions , set operations , list operations etc., completely covering the OCL standard concepts, but extend it e.g. by set comprehensions known from Haskell, a typesafe cast or a transitive closure operator . An example shows several of the above-mentioned syntactic features: ocl Bookshop { context Shop s inv CustomerPaysBeforeNewOrder: // invariant forall Customer c in s.customers: // quantifiers available c.allowedToOrder implies !exists Invoice i in s.invoices: i.customer == c && i.moneyPayed < i.invoiceAmount ; // Method specification for selling a book context Invoice Stock.sellBook(String iban, int discountPercent, Customer c) let availableBooks = // set comprehension { book | Book book in booksInStock, book.iban == iban } pre: !availableBooks.isEmpty && // precondition c.allowedToOrder; post: let discount = (100 - discountPercent)/100; // postcondition, let b = result.soldBook // result variable in !(b isin booksInStock) && booksInStock.size@pre == booksInStock.size + 1 && // @pre result.invoiceAmount == b.price * discount; // result variable } The OCL language component contains four grammars: OCL , OCLExpressions , OptionalOperators , and SetExpressions . The detailed description provides an in-depth guide for language engineers. Object Diagrams (MontiCore Stable) OD is a language for textual denotation of object diagrams. The OD language has several purposes (when combined with appropriate language extensions): specification language for object structures (as part of the UML/P ) store and transport of data sets (e.g. the artifact analysis toolchain), and report format for the MontiCore tool infrastructure. OD covers named and anonymous objects, object types, links, attributes, attribute values, lists, maps , and visibilities . Special data types, such as Date allow comfortable definition and reading of ODs. For a comfortable definition, objects may be nested into trees while easily retaining their full graph structure. An example: objectdiagram MyFamily { alice:Person { age = 29; cars = [ :BMW { color = BLUE; }, tiger:Jaguar { color = RED; length = 5.3; } ]; }; bob:Person { nicknames = [\"Bob\", \"Bobby\", \"Robert\"]; cars = [tiger]; }; link married alice <-> bob; } If ODs are used as specification technique, e.g. for tests or forbidden situations, a more expressive version of expressions can be used for values (e.g. by composing ODs with JavaExpressions). Furthermore, only interesting attributes need to be defined (underspecification) and conformity to a CD4A model can be checked. The ODs differ from JSON structures, e.g., in the possibility to give the object a name as it is the case for tiger , or alice enabling the definition real graph structures. Main grammars (directly usable): OD4Data OD4Development OD4Report Main grammar components: DateLiterals ODBasis ODAttribute ODLink Detailed description Sequence Diagrams (MontiCore stable) A textual sequence diagram (SD) language. Detailed description The project includes grammars, a symbol table infrastructure, a PrettyPrinter, and various CoCos for typechecking. The language is divided into the two grammars SDBasis and SD4Development. The grammar SDBasis is a component grammar providing basic SD language features. The grammar SD4Development extends the grammar SDBasis with concepts used in UML/P SDs. SD4Development supports modeling objects , method calls , returns , exception throws, dynamic object instantiation , various match modifiers for objects (free, initial, visible, complete), lifelines with activation regions , static method calls, intermediate variable declarations by using OCL, and conditions by using OCL. The grammars can easily be extended by further interactions and object modifiers. The following depicts a simple SD in its textual syntax. sequencediagram AuctionTest { kupfer912: Auction; // Interacting objects bidPol: BiddingPolicy; timePol: TimingPolicy; // Interaction sequence kupfer912 -> bidPol : validateBid(bid) bidPol -> kupfer912 : return BiddingPolicy.OK; kupfer912 -> timePol : newCurrentClosingTime(kupfer912, bid) timePol -> kupfer912 : return t; assert t.timeSec == bid.time.timeSec + extensionTime; } SI Units (MontiCore Stable) The international system of units (SI units) is a physical unit system widely used in the entire world. It is based on the basis units s, m, kg, A, K, mol, cd , provides a variety of derived units, and can be refined using prefixes such as m (milli), k (kilo), etc. The SI Unit project aims to deliver SI units to MontiCore-based languages with expressions. It provides a grammar for all types of SI units and prefixes usable for type definition. Second, it provides the SI Unit literals, such as 5 km as expression values and a language for SI unit types, such as km/h or km/h<long> . Some examples: km/h speed = 5 m / 27 s // variable definition using type km/h speed = (3 * 4m + 17km/h * 10h) / 3.5h // values with SI unit types \u00b0C/s<float> coolingSpeed; // types (\u00b0C/s) with precision (float) g/mm^2<int> pressure; Map<Location,\u00b0C> temperatures; // nesting of types The SI unit literals integrate with MontiCore's expressions and the SI Unit types integrate with MontiCore's type system. The SI unit language remains fully type safe . The math version uses km/h as idealistic full precision real number, while the computing version allows to contrain the precision with km/h<long> . Main grammar components: SI units SI unit literals SI unit types for math SI unit types for computations (other alternatives are possible; SI has not standardized anything here) Example projects: SI Java detailed description Statecharts (MontiCore stable) A set of language variants for Statecharts (UML-like or also embedded SysML-like). It is possible to define syntactically simpler or more complex and comfortable forms of statecharts using a subset of the eleven provided language components. Two complete Statechart language variants are composed for direct usability. A compact teaser for one variant of the Statechart languages: statechart Door { state Opened initial state Closed state Locked Opened -> Closed close() / Closed -> Opened open(1) / {ringTheDoorBell();} Closed -> Locked timeOut(n) / { lockDoor(); } [doorIsLocked] Locked -> Closed [isAuthorized() && doorIsLocked] unlock() / } This example models the different states of a door: Opened , Closed , and Locked . A transition is triggered e.g. by function/method call close() that changes a from a state Opened to state Closed . Transitions can have actions, such as {ringDoorBell();} containing in this case Java statements, or preconditions, such as [ ... ] containing a Boolean expression. State invariants and transition preconditions are defined using Expressions and entry/exit/transition actions are defined using Statements . A Statechart may also have hierarchically decomposed states and other forms of events (not shown here). Detailed description SysML_2 (not yet publicly available) (Alpha: Intention to become stable) MontiCore languages for parsing artifacts of the SysML 2 language family. Examples: package 'Vehicles' { // a SysML block diagram private import ScalarValues::*; block Vehicle; block Truck is Vehicle; value type Torque is ISQ::TorqueValue; } package 'Coffee' { // a SysML activity diagram activity BrewCoffee (in beans : CoffeeBeans, in, water : Water, out coffee : Coffee) { bind grind::beans = beans; action grind : Grind (in beans, out powder); flow grind::powder to brew::powder; bind brew::water = water; action brew : Brew (in powder, in water, out coffee); bind brew::coffee = coffee; } } The SysML 2 grammars adhere to the general upcoming SysML 2 specification (which is still under improvement currently). Actually these grammars represents a slight superset to the official SysML 2 standard. It is intended for parsing SysML 2-compliant models. Well-formedness checks are kept to a minimum, because we assume to parse correctly produced SysML 2 models only. MontiCore's SysML 2 is a language family that comes with a textual representation to describe SysML 2 diagrams with respect to the standard. SysML 2 covers ADs , BDDs , IBDs , PackageDiagrams , ParametricDiagrams , RequirementDiagrams , SDs , SMDs , UseCaseDiagrams , and general SysMLBasics Main grammars (not yet publicly available) and detailed description (not yet publicly available) Tagging (not yet publicly available) (Alpha: Intention to become stable) Tags are known e.g. from the UML and SysML and mainly used to add extra information to a model element. Normally tags (and stereotypes ) are inserted within the models, which over time pollutes the models, especially when different sets of tags are needed for different technical platforms. MontiCore offers a solution that separates a model and its tags into distinct artifacts . Several independent tagging artifacts can be added without any need to adapt the core model. This allows fo reuse even of fixed library models. The tagging artifacts are dependent on two factors: First, tags can be added to named elements of the base model. It is of great help that we have an elegant symbol mechanism included in the MontiCore generator. Second, the set of allowed tags can be constrained, by an explicit definition of allowed tag types and tag values and an explicit declaration on which kinds of symbols a tag may be attached to. Consequently, tagging is not a single language, but a method to automatically and schematically derive languages: A tagging schema language TSL (dependent on the available symbol types of the base grammar) a tagging language TL (dependent on the tag schema models written in TSL) Because tagging models can e.g. be used as configuration techniques in a code generator, appropriate infrastructure is generated as well. Some tagging language examples (not yet publicly available) Although concrete languages (and their grammars) are themselves generated, there is a main grammar ocl.monticore.lang.Tagging (not yet publicly available) , where the tagging language is derived from. See also detailed description (not yet publicly available) Use Case Diagrams (MontiCore stable) A textual use case diagram (UCD) language. Detailed description The project includes a grammar, a symbol table infrastructure, and a semantic differencing operator. The language is defined by the grammar UCD . It supports modeling actors , use cases , preconditions , associations between actors and use cases, extend relations between use cases with guards , include relations between use cases, and specialization relations between actors and use cases. The grammars can easily be extended. The following depicts a simple UCD in its textual syntax. usecasediagram Example { @Player -- Play, Pay, ChangeProfilePicture; @AndroidPlayer specializes Player; @IOSPlayer specializes Player; @Server -- ShowAd, RegisterScore; ShowAd extend Play [!isPremium]; RegisterScore extend Play; abstract Pay include CheckPremium; CreditCard specializes Pay; Bank specializes Pay; ChangeProfilePicture [isPremium]; } XML (MontiCore Stable) The MontiCore language for parsing XML artifacts. An example: <Calendar> <Appointment name=\"lunch\"> <Date>24.04.2020</Date> <Time>11:30</Time> <Location>cafeteria</Location> </Appointment> </Calendar> The XML grammar adheres to the common XML standard and allows parsing arbitrary XML artifacts for further processing. Actually the grammar represents a slight superset to the official XML standard. It is intended for parsing XML-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced XML documents only. Please note that XML (like JSON or ASCII) is mainly a carrier language. The concrete XML dialect and the question, how to recreate the real objects / data structures, etc. behind the XML structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.XML and detailed description JavaLight (MontiCore Stable) This is a reduced version of the Java language . JavaLight is meant to be used to integrate simplified Java-like parts in modeling languages but not to parse complete Java implementations. It provides Java's attribute and method definitions , statements and expressions , but does not provide class or interface definitions and also no wildcards in the type system. One main usage of JavaLight is in the Grammar-language to model e.g. Java methods. An example: public void print(String name) { System.out.println(\"Hello \" + name); } Main grammar de.monticore.JavaLight and detailed description . Java (not yet publicly available) (Beta: In Stabilization) This is the full Java' Language (as Opposed to JavaLight). Main Grammar JavaDSL (not yet publicly available) and detailed description (not yet publicly available) . Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Languages"},{"location":"docs/Languages/#monticore-languages-of-level-ii-an-overview","text":"MontiCore is a language workbench with an explicit notion of language components. It uses grammars to describe textual DSLs. MontiCore uses an extended grammar format that allows to compose language components via inheritance, embedding and aggregation (see the reference manual for details). A language component is mainly represented through (1) the grammar describing concrete and abstract syntax of the language, (2) Java-classes implementing specific functionalities, and (3) Freemarker-Templates helping to print a model to text. However, language components are often identified with their main component grammar. Language components are currently organized in two levels: In this list you mainly find grammars for complete (but also reusable and adaptable) languages (Level II). A list of grammar components with individual reusable nonterminals is also available in the MontiCore core project ( development status ) (Level I). The following list contains the language grammars found in the MontiCore projects, such as cd4analysis/cd4analysis . They are usually contained in project folders like src/main/grammars/ and organized in packages like de.monticore.cd . Publicly available MontiCore projects are hosted at https://github.com/MontiCore .","title":"MontiCore Languages of Level II - an Overview"},{"location":"docs/Languages/#list-of-languages","text":"","title":"List of Languages"},{"location":"docs/Languages/#class-diagram-for-analysis-cd4a-monticore-stable","text":"CD4A is the textual representation to describe UML class diagrams (it uses the UML/P variant). CD4A covers classes, interfaces, inheritance, attributes with types, visibilities , and all kinds of associations and composition , including qualified and ordered associations . Classes can be placed in different packages . An example: classdiagram MyLife { abstract class Person { int age; Date birthday; List<String> nickNames; } package com.universityLib { <<myStereotype>> class Student extends Person { StudentStatus status; } enum StudentStatus { ENROLLED, FINISHED; } } composition Person -> Address [*] {ordered}; association [0..2] Person (parent) <-> (child) Person [*]; association phonebook Person [String] -> PhoneNumber ; } CD4A focuses on the analysis phase in typical data-driven development projects and is therefore mainly for data modelling. Consequently, it omits method signatures and complex generics. The primary use of the CD4A language is therefore data modelling . The CD4A language opens various possibilities for the development of data structures, database tables as well as data transport infrastructures in cloud and distributed systems. Main grammar de.monticore.cd.CD4Analysis and detailed description","title":"Class Diagram For Analysis (CD4A) (MontiCore stable)"},{"location":"docs/Languages/#class-diagram-for-code-cd4code-monticore-stable","text":"CD4Code describes UML class diagrams . CD4Code is a conservative extension of CD4A , which includes method signatures. An example: classdiagram MyLife2 { // like CD4A but also allows: class Person { protected List<Person> closestFriends(int n); void addFriend(Person friends...); <<myStereotype>> void relocate(); } } CD4Code is often used as tool-internal AST that allows to map any kind of source models to a class/attribute/method/association based intermediate structure, before it is printed e.g. as Java code. For example a transformation sequence could be: MontiCoreCLI : Grammar -> Grammar AST encoded in CD4Code -> Decoration for custom behavior -> Java code Statechart -> State pattern encoded in CD4Code -> Decoration by monitoring methods -> Java code. Main grammar de.monticore.cd.CD4Code and detailed description (see Section CD4Code )","title":"Class Diagram for Code (CD4Code) (MontiCore stable)"},{"location":"docs/Languages/#feature-diagrams-monticore-stable","text":"Language for feature models and feature configurations. Feature diagrams are used to model (software) product lines and their variants . Feature configurations select a subset of features of a feature model to describe a product of the product line. An example: featurediagram MyPhones { Phone -> Memory & OS & Camera? & Screen; Memory -> Internal & External?; Internal -> [1..2] of {Small, Medium, Large}; OS -> iOS ^ Android; Screen -> Flexible | FullHD; Camera requires (iOS && External) || Android ; } Rules F -> ... have a parent feature (left-hand side) and its child features (right-hand side). Operators are: optional feature ? , and & , or | , xor ^ , and subset cardinality constraints, like [1..2] of ... . Further, a feature model may define cross-tree constraints using logic operators and && , or || , implication requires , etc. * Main grammar FeatureDiagram and detailed description","title":"Feature Diagrams (MontiCore stable)"},{"location":"docs/Languages/#gui-dsl-not-yet-publicly-available-alpha-intention-to-become-stable","text":"Language for textual definition of Graphical User Interfaces of Web Applications GUI DSL covers GUI elements and relevant configuration, which include layout elements, widgets , their style definition and references to data sources . Language is mainly used to describe GUI of Web Applications . The models of the language represents graphical views or their parts, omitting smaller details of style definition and simplifying connection between graphical elements and data sources. Currently, new version of the GUIDSL is being developed: Basis grammar GUIBasis (not yet publicly available) includes constructs for general visualization component definitions, control statements and components for layout description. Example models (not yet publicly available) can be found in the same repository. Main grammar GUIDSL (not yet publicly available) includes basic concepts and more specific implementation of component configuration. In projects legacy version is currently used: Examples: MaCoCo (not yet publicly available) , Ford Main grammar GUIDSL (not yet publicly available) includes definitions of MontiGem visualisation components, which are based on abstract concepts, described in core grammar GUIDSLCore (not yet publicly available) . Detailed description (not yet publicly available) and documentation (not yet publicly available) .","title":"GUI DSL (not yet publicly available) (Alpha: Intention to become stable)"},{"location":"docs/Languages/#monticore-grammar-monticore-stable","text":"Language for MontiCore Grammars itself. It can be understood as meta language , but also used as ordinary language. Its main use currently: A MontiCore grammar defines the concrete syntax and the abstract syntax of a textual language. Examples: All languages on this page are defined using MontiCore grammars and thus conform to this Grammar. Main features: Define nonterminals and their productions in EBNF, lexical token as regular expressions. Most important extensions to standard grammars: Abstract , interface and external productions allow to define extensible component grammars (object-oriented grammar style). Inherited productions can be redefined (overwritten) as well as conservatively extended. Symbol and scope infrastructure is defined by simple keywords. Symbols definition places can be introduced and symbol referencing places defined, such that for standard cases automatically symbol tables can be added. Additional attributes and methods can be added to the abstract syntax only. Various elements, such as semantic predicates and actions can be defined in the same style as the underlying ANTLR. MontiCore grammars can be left recursive and even allow mutual recursion. This is e.g. useful for expression hierarchies. Additional elements, such as enum productions and comfortable operations for grammar definitions exist. Main grammars de.monticore.grammar.Grammar defines the language with some open parameters and de.monticore.grammar.Grammar_WithConcepts binds the external, imported expressions, method bodies, etc. Detailed description in the MontiCore Reference Manual.","title":"MontiCore Grammar (MontiCore Stable)"},{"location":"docs/Languages/#json-monticore-stable","text":"The MontiCore language for parsing JSON artifacts. An example: { \"Alice\": { \"fullname\": \"Alice Anderson\", \"address\": { \"postal_code\": 10459, \"street\": \"Beck Street\", \"number\": 56 } }, \"Bob\": { ... }, \"Caroll\": { ... }, ... } The JSON grammar adheres to the common JSON standard and allows parsing arbitrary JSON artifacts for further processing. Actually the grammar represents a slight superset to the official JSON standard. It is intended for parsing JSON-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced JSON documents only. Please note that JSON (like XML or ASCII) is primarily a carrier language. The concrete JSON dialect and the question, how to recreate the real objects / data structures, etc. behind the JSON tree structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.JSON and detailed description","title":"JSON (MontiCore Stable)"},{"location":"docs/Languages/#montiarc-not-yet-publicly-available-monticore-stable","text":"MontiArc is an architecture and behavior modeling language and framework that provides a platform independent structure and behavior modeling language with an extensible code generation framework. MontiArc covers components their ports , connectors between components and embedded statecharts for component behavior description. Statecharts define states and transitions with conditions on the incoming messages as well as transition actions. An example: component InteriorLight { // MontiArc language port in Boolean lightSignal, // ports in Boolean doorSignal out OnOff status; ORGate or; // used subcomponents lightSignal -> or.a; // connectors doorSignal -> or.b; or.c -> cntr.signal; component LightController cntr { // freshly defined subcomponent port in OnOff signal, out OnOff status; statechart { // with behavior by a Statechart initial state Off / {status = OFF}; state On; Off -> On [ signal == true ] / {status = ON} On -> Off [ signal == false ] / {status = OFF} } } cntr.status -> status; } MontiArc's main goal is to provide a textual notation for Component&Connector diagrams, which is used quite often in various variants in industry. E.g. SysML's BDD, UML's component composition diagrams use the same paradigm. MontiArc does not define data types for their signals, but assumes that these types can be imported (e.g. from a class diagram). MontiArc itself also has no timing predefined, but for a complete language a concrete timing, such as formally grounded by Focus, should be added. Main grammar MontiArc.mc4 (not yet publicly available) and detailed description (not yet publicly available)","title":"MontiArc (not yet publicly available) (MontiCore Stable)"},{"location":"docs/Languages/#oclp-monticore-stable","text":"OCL/P is the textual representation of the UML OCL standard, adapted with Java-like syntax. Its main goal is the usage in combination with other languages like CD4A or Object Diagrams as an integrated part of that languages. OCL/P allows to define invariants and pre-/post-conditions in the known OCL style plus some extensions, such as a generalized let construction. Furthermore, it offers a large set expressions to model constraints. These expressions include Java expressions , set operations , list operations etc., completely covering the OCL standard concepts, but extend it e.g. by set comprehensions known from Haskell, a typesafe cast or a transitive closure operator . An example shows several of the above-mentioned syntactic features: ocl Bookshop { context Shop s inv CustomerPaysBeforeNewOrder: // invariant forall Customer c in s.customers: // quantifiers available c.allowedToOrder implies !exists Invoice i in s.invoices: i.customer == c && i.moneyPayed < i.invoiceAmount ; // Method specification for selling a book context Invoice Stock.sellBook(String iban, int discountPercent, Customer c) let availableBooks = // set comprehension { book | Book book in booksInStock, book.iban == iban } pre: !availableBooks.isEmpty && // precondition c.allowedToOrder; post: let discount = (100 - discountPercent)/100; // postcondition, let b = result.soldBook // result variable in !(b isin booksInStock) && booksInStock.size@pre == booksInStock.size + 1 && // @pre result.invoiceAmount == b.price * discount; // result variable } The OCL language component contains four grammars: OCL , OCLExpressions , OptionalOperators , and SetExpressions . The detailed description provides an in-depth guide for language engineers.","title":"OCL/P (MontiCore Stable)"},{"location":"docs/Languages/#object-diagrams-monticore-stable","text":"OD is a language for textual denotation of object diagrams. The OD language has several purposes (when combined with appropriate language extensions): specification language for object structures (as part of the UML/P ) store and transport of data sets (e.g. the artifact analysis toolchain), and report format for the MontiCore tool infrastructure. OD covers named and anonymous objects, object types, links, attributes, attribute values, lists, maps , and visibilities . Special data types, such as Date allow comfortable definition and reading of ODs. For a comfortable definition, objects may be nested into trees while easily retaining their full graph structure. An example: objectdiagram MyFamily { alice:Person { age = 29; cars = [ :BMW { color = BLUE; }, tiger:Jaguar { color = RED; length = 5.3; } ]; }; bob:Person { nicknames = [\"Bob\", \"Bobby\", \"Robert\"]; cars = [tiger]; }; link married alice <-> bob; } If ODs are used as specification technique, e.g. for tests or forbidden situations, a more expressive version of expressions can be used for values (e.g. by composing ODs with JavaExpressions). Furthermore, only interesting attributes need to be defined (underspecification) and conformity to a CD4A model can be checked. The ODs differ from JSON structures, e.g., in the possibility to give the object a name as it is the case for tiger , or alice enabling the definition real graph structures. Main grammars (directly usable): OD4Data OD4Development OD4Report Main grammar components: DateLiterals ODBasis ODAttribute ODLink Detailed description","title":"Object Diagrams (MontiCore Stable)"},{"location":"docs/Languages/#sequence-diagrams-monticore-stable","text":"A textual sequence diagram (SD) language. Detailed description The project includes grammars, a symbol table infrastructure, a PrettyPrinter, and various CoCos for typechecking. The language is divided into the two grammars SDBasis and SD4Development. The grammar SDBasis is a component grammar providing basic SD language features. The grammar SD4Development extends the grammar SDBasis with concepts used in UML/P SDs. SD4Development supports modeling objects , method calls , returns , exception throws, dynamic object instantiation , various match modifiers for objects (free, initial, visible, complete), lifelines with activation regions , static method calls, intermediate variable declarations by using OCL, and conditions by using OCL. The grammars can easily be extended by further interactions and object modifiers. The following depicts a simple SD in its textual syntax. sequencediagram AuctionTest { kupfer912: Auction; // Interacting objects bidPol: BiddingPolicy; timePol: TimingPolicy; // Interaction sequence kupfer912 -> bidPol : validateBid(bid) bidPol -> kupfer912 : return BiddingPolicy.OK; kupfer912 -> timePol : newCurrentClosingTime(kupfer912, bid) timePol -> kupfer912 : return t; assert t.timeSec == bid.time.timeSec + extensionTime; }","title":"Sequence Diagrams  (MontiCore stable)"},{"location":"docs/Languages/#si-units-monticore-stable","text":"The international system of units (SI units) is a physical unit system widely used in the entire world. It is based on the basis units s, m, kg, A, K, mol, cd , provides a variety of derived units, and can be refined using prefixes such as m (milli), k (kilo), etc. The SI Unit project aims to deliver SI units to MontiCore-based languages with expressions. It provides a grammar for all types of SI units and prefixes usable for type definition. Second, it provides the SI Unit literals, such as 5 km as expression values and a language for SI unit types, such as km/h or km/h<long> . Some examples: km/h speed = 5 m / 27 s // variable definition using type km/h speed = (3 * 4m + 17km/h * 10h) / 3.5h // values with SI unit types \u00b0C/s<float> coolingSpeed; // types (\u00b0C/s) with precision (float) g/mm^2<int> pressure; Map<Location,\u00b0C> temperatures; // nesting of types The SI unit literals integrate with MontiCore's expressions and the SI Unit types integrate with MontiCore's type system. The SI unit language remains fully type safe . The math version uses km/h as idealistic full precision real number, while the computing version allows to contrain the precision with km/h<long> . Main grammar components: SI units SI unit literals SI unit types for math SI unit types for computations (other alternatives are possible; SI has not standardized anything here) Example projects: SI Java detailed description","title":"SI Units (MontiCore Stable)"},{"location":"docs/Languages/#statecharts-monticore-stable","text":"A set of language variants for Statecharts (UML-like or also embedded SysML-like). It is possible to define syntactically simpler or more complex and comfortable forms of statecharts using a subset of the eleven provided language components. Two complete Statechart language variants are composed for direct usability. A compact teaser for one variant of the Statechart languages: statechart Door { state Opened initial state Closed state Locked Opened -> Closed close() / Closed -> Opened open(1) / {ringTheDoorBell();} Closed -> Locked timeOut(n) / { lockDoor(); } [doorIsLocked] Locked -> Closed [isAuthorized() && doorIsLocked] unlock() / } This example models the different states of a door: Opened , Closed , and Locked . A transition is triggered e.g. by function/method call close() that changes a from a state Opened to state Closed . Transitions can have actions, such as {ringDoorBell();} containing in this case Java statements, or preconditions, such as [ ... ] containing a Boolean expression. State invariants and transition preconditions are defined using Expressions and entry/exit/transition actions are defined using Statements . A Statechart may also have hierarchically decomposed states and other forms of events (not shown here). Detailed description","title":"Statecharts (MontiCore stable)"},{"location":"docs/Languages/#sysml_2-not-yet-publicly-available-alpha-intention-to-become-stable","text":"MontiCore languages for parsing artifacts of the SysML 2 language family. Examples: package 'Vehicles' { // a SysML block diagram private import ScalarValues::*; block Vehicle; block Truck is Vehicle; value type Torque is ISQ::TorqueValue; } package 'Coffee' { // a SysML activity diagram activity BrewCoffee (in beans : CoffeeBeans, in, water : Water, out coffee : Coffee) { bind grind::beans = beans; action grind : Grind (in beans, out powder); flow grind::powder to brew::powder; bind brew::water = water; action brew : Brew (in powder, in water, out coffee); bind brew::coffee = coffee; } } The SysML 2 grammars adhere to the general upcoming SysML 2 specification (which is still under improvement currently). Actually these grammars represents a slight superset to the official SysML 2 standard. It is intended for parsing SysML 2-compliant models. Well-formedness checks are kept to a minimum, because we assume to parse correctly produced SysML 2 models only. MontiCore's SysML 2 is a language family that comes with a textual representation to describe SysML 2 diagrams with respect to the standard. SysML 2 covers ADs , BDDs , IBDs , PackageDiagrams , ParametricDiagrams , RequirementDiagrams , SDs , SMDs , UseCaseDiagrams , and general SysMLBasics Main grammars (not yet publicly available) and detailed description (not yet publicly available)","title":"SysML_2 (not yet publicly available) (Alpha: Intention to become stable)"},{"location":"docs/Languages/#tagging-not-yet-publicly-available-alpha-intention-to-become-stable","text":"Tags are known e.g. from the UML and SysML and mainly used to add extra information to a model element. Normally tags (and stereotypes ) are inserted within the models, which over time pollutes the models, especially when different sets of tags are needed for different technical platforms. MontiCore offers a solution that separates a model and its tags into distinct artifacts . Several independent tagging artifacts can be added without any need to adapt the core model. This allows fo reuse even of fixed library models. The tagging artifacts are dependent on two factors: First, tags can be added to named elements of the base model. It is of great help that we have an elegant symbol mechanism included in the MontiCore generator. Second, the set of allowed tags can be constrained, by an explicit definition of allowed tag types and tag values and an explicit declaration on which kinds of symbols a tag may be attached to. Consequently, tagging is not a single language, but a method to automatically and schematically derive languages: A tagging schema language TSL (dependent on the available symbol types of the base grammar) a tagging language TL (dependent on the tag schema models written in TSL) Because tagging models can e.g. be used as configuration techniques in a code generator, appropriate infrastructure is generated as well. Some tagging language examples (not yet publicly available) Although concrete languages (and their grammars) are themselves generated, there is a main grammar ocl.monticore.lang.Tagging (not yet publicly available) , where the tagging language is derived from. See also detailed description (not yet publicly available)","title":"Tagging (not yet publicly available) (Alpha: Intention to become stable)"},{"location":"docs/Languages/#use-case-diagrams-monticore-stable","text":"A textual use case diagram (UCD) language. Detailed description The project includes a grammar, a symbol table infrastructure, and a semantic differencing operator. The language is defined by the grammar UCD . It supports modeling actors , use cases , preconditions , associations between actors and use cases, extend relations between use cases with guards , include relations between use cases, and specialization relations between actors and use cases. The grammars can easily be extended. The following depicts a simple UCD in its textual syntax. usecasediagram Example { @Player -- Play, Pay, ChangeProfilePicture; @AndroidPlayer specializes Player; @IOSPlayer specializes Player; @Server -- ShowAd, RegisterScore; ShowAd extend Play [!isPremium]; RegisterScore extend Play; abstract Pay include CheckPremium; CreditCard specializes Pay; Bank specializes Pay; ChangeProfilePicture [isPremium]; }","title":"Use Case Diagrams  (MontiCore stable)"},{"location":"docs/Languages/#xml-monticore-stable","text":"The MontiCore language for parsing XML artifacts. An example: <Calendar> <Appointment name=\"lunch\"> <Date>24.04.2020</Date> <Time>11:30</Time> <Location>cafeteria</Location> </Appointment> </Calendar> The XML grammar adheres to the common XML standard and allows parsing arbitrary XML artifacts for further processing. Actually the grammar represents a slight superset to the official XML standard. It is intended for parsing XML-compliant artifacts. Further well-formedness checks are not included, because we assume to parse correctly produced XML documents only. Please note that XML (like JSON or ASCII) is mainly a carrier language. The concrete XML dialect and the question, how to recreate the real objects / data structures, etc. behind the XML structure is beyond this grammar, but can be applied to the AST defined here. Main grammar de.monticore.lang.XML and detailed description","title":"XML (MontiCore Stable)"},{"location":"docs/Languages/#javalight-monticore-stable","text":"This is a reduced version of the Java language . JavaLight is meant to be used to integrate simplified Java-like parts in modeling languages but not to parse complete Java implementations. It provides Java's attribute and method definitions , statements and expressions , but does not provide class or interface definitions and also no wildcards in the type system. One main usage of JavaLight is in the Grammar-language to model e.g. Java methods. An example: public void print(String name) { System.out.println(\"Hello \" + name); } Main grammar de.monticore.JavaLight and detailed description .","title":"JavaLight (MontiCore Stable)"},{"location":"docs/Languages/#java-not-yet-publicly-available-beta-in-stabilization","text":"This is the full Java' Language (as Opposed to JavaLight). Main Grammar JavaDSL (not yet publicly available) and detailed description (not yet publicly available) .","title":"Java (not yet publicly available) (Beta: In Stabilization)"},{"location":"docs/Languages/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"docs/Publications/","text":"Redirecting to https://www.se-rwth.de/topics/MontiCore.php","title":"Publications"},{"location":"docs/further_docs/Impressum/","text":"Impressum According to German law, each website needs to have an \"impressum\", declaring among other things who is responsible for the content. A few things are currently unclear: Is only github (in total) a website or each group withing github, or each project? What if the project is open source, do then all (German) contributors have to add an impressum? If the webpage is hosted outside Germany (like github), does German law then apply at all? Although a lot of things are unclear and the text below doesn't totally fit, we have opted to be on the safe side and add our Impressum below. Please note that this is an open source project and each contributor may change any artifact of the project -- even this text -- so we do not claim any responsibility or credits for the project, even so we are currently having the role of the curators . Herausgeberin Herausgegeben im Auftrag des Rektors der Rheinisch-Westf\u00e4lischen Technischen Hochschule (RWTH) Aachen. RWTH Aachen \\ Templergraben 55 52062 Aachen (Hausanschrift) \\ 52056 Aachen (Postanschrift) Telefon: +49 241 80 1 \\ Telefax: +49 241 80 92312 Internet: www.rwth-aachen.de Die RWTH Aachen ist eine K\u00f6rperschaft des \u00f6ffentlichen Rechts. Sie wird durch den Dr. rer. nat. Dr. h. c. mult. Ulrich R\u00fcdiger vertreten. Zust\u00e4ndige Aufsichtsbeh\u00f6rde Ministerium f\u00fcr Kultur und Wissenschaft des Landes Nordrhein Westfalen, V\u00f6lklinger Stra\u00dfe 49, 40221 D\u00fcsseldorf. Umsatzsteuer-Identifikationsnummer Gem\u00e4\u00df Par. 27 a Umsatzsteuergesetz: DE 121689807 Inhaltliche Verantwortlichkeit Webmaster / Webredaktion: \\ Bernhard Rumpe \\ E-Mail: webmaster@se-rwth.de Die Webseiten der Zentralen Hochschulverwaltung, der Zentralen Einrichtungen, der Gruppenvertretungen, der Institute, Lehrst\u00fchle sowie Lehr- und Forschungsgebiete werden von den von diesen beauftragten Webkoordinatorinnen und Webkoordinatoren beziehungsweise deren Webmastern eigenst\u00e4ndig betreut. Details zu Fragen der Haftung sind in der Datenschutzerkl\u00e4rung nachzulesen.","title":"Impressum"},{"location":"docs/further_docs/Impressum/#impressum","text":"According to German law, each website needs to have an \"impressum\", declaring among other things who is responsible for the content. A few things are currently unclear: Is only github (in total) a website or each group withing github, or each project? What if the project is open source, do then all (German) contributors have to add an impressum? If the webpage is hosted outside Germany (like github), does German law then apply at all? Although a lot of things are unclear and the text below doesn't totally fit, we have opted to be on the safe side and add our Impressum below. Please note that this is an open source project and each contributor may change any artifact of the project -- even this text -- so we do not claim any responsibility or credits for the project, even so we are currently having the role of the curators .","title":"Impressum"},{"location":"docs/further_docs/Impressum/#herausgeberin","text":"Herausgegeben im Auftrag des Rektors der Rheinisch-Westf\u00e4lischen Technischen Hochschule (RWTH) Aachen. RWTH Aachen \\ Templergraben 55 52062 Aachen (Hausanschrift) \\ 52056 Aachen (Postanschrift) Telefon: +49 241 80 1 \\ Telefax: +49 241 80 92312 Internet: www.rwth-aachen.de Die RWTH Aachen ist eine K\u00f6rperschaft des \u00f6ffentlichen Rechts. Sie wird durch den Dr. rer. nat. Dr. h. c. mult. Ulrich R\u00fcdiger vertreten.","title":"Herausgeberin"},{"location":"docs/further_docs/Impressum/#zustandige-aufsichtsbehorde","text":"Ministerium f\u00fcr Kultur und Wissenschaft des Landes Nordrhein Westfalen, V\u00f6lklinger Stra\u00dfe 49, 40221 D\u00fcsseldorf.","title":"Zust\u00e4ndige Aufsichtsbeh\u00f6rde"},{"location":"docs/further_docs/Impressum/#umsatzsteuer-identifikationsnummer","text":"Gem\u00e4\u00df Par. 27 a Umsatzsteuergesetz: DE 121689807","title":"Umsatzsteuer-Identifikationsnummer"},{"location":"docs/further_docs/Impressum/#inhaltliche-verantwortlichkeit","text":"Webmaster / Webredaktion: \\ Bernhard Rumpe \\ E-Mail: webmaster@se-rwth.de Die Webseiten der Zentralen Hochschulverwaltung, der Zentralen Einrichtungen, der Gruppenvertretungen, der Institute, Lehrst\u00fchle sowie Lehr- und Forschungsgebiete werden von den von diesen beauftragten Webkoordinatorinnen und Webkoordinatoren beziehungsweise deren Webmastern eigenst\u00e4ndig betreut. Details zu Fragen der Haftung sind in der Datenschutzerkl\u00e4rung nachzulesen.","title":"Inhaltliche Verantwortlichkeit"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/","text":"MontiCore Grammars for Expressions, Literals and Types - an Overview MontiCore is a language workbench. It uses grammars as primary mechanism to describe DSLs. The extended grammar format allows to compose language components by (1) inheriting , (2) extending , (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable , can be extended with handwrittten code and most importandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . The following is a library of language components that the core MontiCore project provides, mainly defined through a primary grammar plus associated Java- and Template-Files. These are available in the MontiCore core project together with short descriptions and their status ( Status of Grammars ). The list covers mainly the core grammars to be found in the MontiCore/monticore project under monticore-grammar/src/main/grammars/ in packages de.monticore de.monticore.expressions de.monticore.literals de.monticore.statements de.monticore.symbols de.monticore.types and some expression/type related grammars in extending MontiCore projects. For more langauges and language components, see here . General: List of Grammars in package de.monticore MCBasics.mc4 (stable) This grammar defines absolute basics, such as spaces, Java-like comments and Names. It should be useful in many languages. Types: List of Grammars in package de.monticore.types These grammars generally deal with type definitions and build on each other. Some snipets for type definitions: grammars some examples MCBasicTypes boolean byte short int long char float double void Person a.b.Person import a.b.Foo.*; MCCollectionTypes List<.> Set<.> Optional<.> Map<.,.> MCSimpleGenericTypes Foo<.> a.b.Bar<.,..,.> MCFullGenericTypes Foo<? extends .> Foo<? super .> MCArrayTypes Person[] int[][] SI Unit types km/h km/h<long> RegExType R\"[a-z][0-9*]\" MCBasicTypes.mc4 (stable) This grammar defines basic types. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without generics. The grammar contains types from Java, e.g., primitives, void, classes (also sometimes called \"reference types\"). MCCollectionTypes.mc4 (stable) This grammar defines four generics: List<A> , Map<A,B> , Set<A> and Optional<A> on top of basic types. These four generics correspond to a typical predefined set of generic types for example used in connection with UML class diagrams or the OCL. UML associations typically have those association multiplicities and therefore these types are of interest. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without general generics. MCSimpleGenericTypes.mc4 (stable) This grammar introduces freely defined generic types such as Blubb<A> , Bla<B,C> , Foo<Blubb<D>> These generics are covering a wide range of uses for generic types, although they don't cover type restrictions on the arguments, like in Java. MCFullGenericTypes.mc4 (stable) This grammar completes the type definitions to support the full Java type system including wildcards Blubb<? extends A> A general advice: When you are not sure that you need this kind of types, then use a simpler version from above. Type checking ist tricky. MCArrayTypes.mc4 (stable) Arrays are orthogonal to the generic extensions and thus be combined with any of the above variants. Language component MCArrayTypes provides possibilities to add arrays, such as Person[] or int[][] . SIUnitTypes4Math.mc4 (not yet publicly available) for Physical SI Units (stable) The known units s, m, kg, A, K, mol, cd from the international system of units (SI Units) and their combinations, such as km/h or mg , etc. can be used as ordinary types (instead of only numbers). The typecheck is extended to prevent e.g. assignment of a weight to a length variable or to add appropriate conversion, e.g. when a km/h -based velocity is e.g. stored in a m/s -based variable. The grammar resides in the MontiCore/SIunits project. SIUnitTypes4Computing.mc4 (not yet publicly available) for Physical SI Units (stable) Includes the types from SIUnitTypes4Math (see above), like km/h , but also allows to add a resolution, such as km/h<int> . Here SI Unit types, like km/h<.> , are used as generic type constructor that may take a number type, such as int , long , double , float as argument. The grammar resides in the MontiCore/SIunits project. RegExType.mc4 (not yet publicly available) (stable) Embedded in R\"...\" a regular expressions can be used as ordinary type to constrain the values allowed for stored variables, attributes, parameters. Types are e.g. , such as R\"[a-z]\" (single character) or R\"^([01][0-9]|2[0-3])$\" (hours). A typecheck for these types can only be executed at runtime and e.g. issue exceptions (or trigger repair functions) if violated. The static typecheck only uses String as underlying carrier type. This grammar resides in the MontiCore/RegEx (not yet publicly available) project. Symbols: List of Grammars in package de.monticore.symbols These two grammars do not provide syntax themselves, but characterize important forms of symbols, that will be used in the type and the expression grammars to define shared kinds of symbols. BasicSymbols.mc4 (stable) This grammar defines symbols for Types (of all kinds), Functions , Variables and TypeVariables . The defined symbols are of general form and can be used in functional, OO and other contexts. They do not preculde a concrete syntax and do not yet embody OO specifics. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols. OOSymbols.mc4 (stable) This grammar defines symbols for objectoriented Types , Methods , and Fields by mainly extending the symbols defined in BasicTypeSymbols . The newly defined symbols extend the general ones by typical objectoriented features, such as private, static, etc. Again they do not preculde a concrete syntax. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols in objectoriented context. Expressions: List of Grammars in package de.monticore.expressions Expressions are defined in several grammars forming a (nonlinear) hierarchy, so that developers can choose the optimal grammar they want to build on for their language and combine these with the appropriate typing infrastructure. This modularity of expressions and associated types greatly eases the reuse of type structures in languages similar to Java. Some snipets for operators defined in expressions: grammar operators and examples in this grammar CommonExp: / % + - <= >= == > < != ~. !. .?.:. && || ~. AssigementExp: ++ -- = += -= *= /= &= |= ^= >>= >>>= <<= %= BitExp: & | ^ << >> >>> OclExp: implies <=> | & forall exists let.in. .@pre .[.] .** Set{.|.} SetExp: .isin. .in. union intersect setand setor { item | specifier } OptionalOps: ?: ?<= ?>= ?< ?> ?== ?!= ?~~ ?!~ SIUnits: 5km 3,2m/s 22l 2.400J JavaClass: this .[.] (.). super .instanceof. ExpressionsBasis.mc4 (stable) This grammar defines core interfaces for expressions and imports the kinds of symbols necessary. The symbols are taken over from the TypeSymbols grammar (see below). A hierarchy of conservative extensions to this grammar realize these interfaces in various forms. CommonExpressions.mc4 (stable) This grammar defines a typical standard set of operations for expressions. This is a subset of Java as well as OCL/P, mainly for arithmetic, comparisons, variable use (v), attribute use (o.att), method call (foo(arg,arg2)) and brackets (exp). AssignmentExpressions.mc4 (stable) This grammar defines all Java expressions that have side effects. This includes assignment expressions like =, +=, etc. and suffix and prefix expressions like ++, --, etc. BitExpressions.mc4 (stable) This grammar defines a typical standard set of operations for expressions. This is a subset of Java for binary expressions like <<, >>, >>>, &, ^ and | OCLExpressions.mc4 (not yet publicly available) (stable) This grammar defines expressions typical to UMLs OCL . OCL expressions can savely be composed if with other forms of expressions given in the MontiCore core project (i.e. as conservative extension). It contains various logical operations, such as quantifiers, the let and the @pre construct, and a transitive closure for associations, as discussed in [Rum17,Rum17]. This grammar resides in the MontiCore/OCL (not yet publicly available) project. SetExpressions.mc4 (not yet publicly available) (stable) This grammar defines set expressions like set union, intersection etc. these operations are typical for a logic with set operations, like UML's OCL. These operators are usually infix and are thus more intuitive as they allow math oriented style of specification. Most of these operators are in principle executable, so it might be interesting to include them in a high level programming language (see e.g. Haskell) This grammar resides in the MontiCore/OCL (not yet publicly available) project. OptionalOperators.mc4 (not yet publicly available) (stable) This grammar defines nine operators dealing with optional values, e.g. defined by java.lang.Optional . The operators are also called Elvis operators . E.g.: val ?: 0W equals to val.isPresent ? val.get : 0W x ?>= y equals x.isPresent && x.get >= y This grammar resides in the MontiCore/OCL (not yet publicly available) project. SIUnits.mc4 (not yet publicly available) for Physical SI Units (stable) This grammar the international system of units (SI units), based on the basis units s, m, kg, A, K, mol, cd , provides a variety of derived units, and can be refined using prefixes such as m (milli), k (kilo), etc. The SI Unit grammar provides an extension to expressions, but also to the typing system, e.g. types such as km/h or km/h<long> , and literals, such as e.g. 5.3 km/h . The grammars reside in the MontiCore/SIunits project JavaClassExpressions.mc4 (stable) This grammar defines Java specific class expressions like super, this, type cast, etc. This grammar should only be included, when a mapping to Java is intended and the full power of Java should be available in the modelling language. Literals: List of Grammars in package de.monticore.literals Literals are the basic elements of expressions, such as numbers, strings, truth values. Some snipets: grammar examples of this grammar MCCommonLit 3 -3 2.17 -4 true false 'c' 3L 2.17d 2.17f 0xAF \"string\" \"str\\uAF01\\u0001\" null MCJavaLiterals 999_999 0x3F2A 0b0001_0101 0567 1.2e-7F SIUnitLiterals 5.3km/h 7mg MCLiteralsBasis.mc4 (stable) This grammar defines core interface for literals. Several conservative extensions to this grammar realize various forms of literals. MCCommonLiterals.mc4 (stable) This grammar defines the typical literals for an expression language, such as characters: 'c', Strings \"text\", booleans: \"true\", \"null\", or numbers 10, -23, 48l, 23.1f. Strings and characters use the Java-like escapes like \" \". Each defined nonterminal is extended by a conversion function getValue() of appropriate type and a retrieve function getSource() for a text representation of the literal. MCJavaLiterals.mc4 (stable) This grammar defines Java compliant literals and builds on MCCommonLiterals. The scope of this grammar is to ease the reuse of literals structures in Java-like sublanguages. The grammar contains literals from Java, e.g., Boolean, Char, String, .... Please note that Java (and this grammar) has an extended syntax e.g. for integers using underscores or other kinds of encodings. They parse e.g. 999_999, 0x3F2A, or 0b10100. Like above getValue() and getSource() allow to retrive the content as value resp. as text string. SIUnitLiterals.mc4 (not yet publicly available) for Physical SI Units (stable) Provides concrete values, such as 5.3 km/h or 7 mg for the international system of units (SI Units). The grammar resides in the MontiCore/SIunits project. Statements: List of Grammars in package de.monticore.statements Statements are the constructive part of programs: They allow to change variables, call functions, send messages etc. The following hierarchy of statement definitions should allow the developers to choose needed forms of statements and extend it by their own additional needs. The provided list of statements is inspired by Java (actually subset of Java). Some example statements: int i; int j = 2; Person p[] = { foo(3+7), p2, ...} if (.) then . else . for ( i = .; .; .) {.} while (.) . do . while (.) switch (.) { case .: .; default: .} foo(1,2,3) return . assert . : \"...\" try {.} catch (.) {.} finally {.} throw . break . continue . label: private static final native ... MCStatementsBasis.mc4 (stable) This grammar defines the core interface for statements. A hierarchy of conservative extensions to this grammar is provided below. MCCommonStatements.mc4 (stable) This grammar defines typical statements, such as method calls (which are actually expressions), assignment of variables, if, for, while, switch statements, and blocks. This embodies a complete structured statement language, however does not provide return, assert, exceptions, and low-level constructs like break. MCAssertStatements.mc4 (stable) This grammar defines exactly the assert statement as known from Java. It can be used independently of other Java statements. MCExceptionStatements.mc4 (stable) This grammar defines the exception statements. This includes Java try with catch and finally, as well as throw. MCSynchronizedStatements.mc4 (stable) This grammar defines the Java-like synchronized statement. MCLowLevelStatements.mc4 (stable) This grammar defines three low-level statements that Java provides. It contains the break and continue statements and the possibility to label a statement. MCReturnStatements.mc4 (stable) This grammar defines the Java-like return statement. MCFullJavaStatements.mc4 (stable) This grammar defines all Java statements. This is neither a generalized approximation nor a restricted overapproximation, but exact. Further grammars in package de.monticore several other grammars are also available: RegularExpressions.mc4 (not yet publicly available) (stable) This grammar defines regular expressions (RegEx) as used in Java (see e.g. java.util.regex.Pattern ). It provides common regex tokens such as character classes, e.g., lowercase letters ( [a-z] ), the letters a, b, and c ( [abc] ) anchors, e.g., start of line ( ^ ), end of line ( $ ), word boundary ( \b ), quantifiers, e.g., zero or one ( ? ), zero or more ( * ), exactly 3 ( {3} ), RegEx also supports to capture groups and referencing these captured groups in replacements. For example, ^([01][0-9]|2[0-3]):[0-5][0-9]$ matches all valid timestamps in HH:MM format. The main nonterminal RegularExpression is not part of the expression hierarchy and thus regular expressions are not used as ordinary values. Instead the nonterminal RegularExpression is can be used in aother places of a language e.g. we do that as additional restriction for String values in input/output channels in architectural langages. This grammar resides in the MontiCore/RegEx (not yet publicly available) project Cardinality.mc4 (stable) This grammar defines UML Cardinalities of forms * , [n..m] or [n..*] . Completeness.mc4 (stable) This grammar defines completeness information in UML like ... , (c) , but also (...,c) . UMLModifier.mc4 (stable) The grammar contains the modifiers that UML provides. This includes public private , protected , final , abstract , local , derived , readonly , and static , but also the compact syntactic versions + , # , - , / and ? (for readonly). UML modifiers are not identical to Java modifiers (e.g. native or threadsafe are missing.) UMLStereotype.mc4 (stable) This grammars defines Stereotypes like <<val1,val2=\"text\",...>> Methods contains(name), getValue(name) assist Stereotype retrieval. Values may only be of type String. The real value unfortunately in UML is only encoded as String. We suggest to use a tagging infrastructure that even allows to type the possible forms of tags. MCCommon.mc4 (stable) This grammar composes typical UML like grammar components. This includes Cardinality, Completeness, UMLModifier, and UMLStereotype. JavaLight.mc4 (stable) int age = 3+x; List<Person> myParents; @Override public int print(String name, Set<Person> p) { int a = 2 + name.length(); if(a < p.size()) { System.out.println(\"Hello \" + name); } return a; } JavaLight is a subset of Java that MontiCore itself uses as intermediate language for the code generation process. JavaLight doesn't provide all forms of classes (e.g. inner classes) and reduces the type system to normal generic types. However, that is sufficient for representation of all generated pieces of code that MontiCore wants to make. Included are: the full Java expressions (without anonymous classes), the relevant Java statements, declaration of methods, constructors, constants, interface methods, and annotations. JavaLight composes from CommonExpressions , AssignmentExpressions , JavaClassExpressions , MCCommonStatements , MCBasicTypes , and OOSymbols . JavaLight can be used for other generator tools as well, especially as its core templates are reusable and new templates for specific method bodies can be added using MontiCore's Hook-Mechanisms. Examples for Grammars under monticore-grammar/src/main/examples These can also be used if someone is interested: StringLiterals.mc4 MCHexNumbers.mc4 MCNumbers.mc4 Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"General"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#monticore-grammars-for-expressions-literals-and-types-an-overview","text":"MontiCore is a language workbench. It uses grammars as primary mechanism to describe DSLs. The extended grammar format allows to compose language components by (1) inheriting , (2) extending , (3) embedding and (4) aggregating grammars (see the reference manual for details). From the grammars a lot of infrastructructure is generated, that is as well composable , can be extended with handwrittten code and most importandly, these extensions and the grammar composition are compatible, which leads to optimal forms of reuse . The following is a library of language components that the core MontiCore project provides, mainly defined through a primary grammar plus associated Java- and Template-Files. These are available in the MontiCore core project together with short descriptions and their status ( Status of Grammars ). The list covers mainly the core grammars to be found in the MontiCore/monticore project under monticore-grammar/src/main/grammars/ in packages de.monticore de.monticore.expressions de.monticore.literals de.monticore.statements de.monticore.symbols de.monticore.types and some expression/type related grammars in extending MontiCore projects. For more langauges and language components, see here .","title":"MontiCore Grammars for Expressions, Literals and Types - an Overview"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#general-list-of-grammars-in-package-demonticore","text":"","title":"General: List of Grammars in package de.monticore"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcbasicsmc4-stable","text":"This grammar defines absolute basics, such as spaces, Java-like comments and Names. It should be useful in many languages.","title":"MCBasics.mc4  (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#types-list-of-grammars-in-package-demonticoretypes","text":"These grammars generally deal with type definitions and build on each other. Some snipets for type definitions: grammars some examples MCBasicTypes boolean byte short int long char float double void Person a.b.Person import a.b.Foo.*; MCCollectionTypes List<.> Set<.> Optional<.> Map<.,.> MCSimpleGenericTypes Foo<.> a.b.Bar<.,..,.> MCFullGenericTypes Foo<? extends .> Foo<? super .> MCArrayTypes Person[] int[][] SI Unit types km/h km/h<long> RegExType R\"[a-z][0-9*]\"","title":"Types: List of Grammars in package de.monticore.types"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcbasictypesmc4-stable","text":"This grammar defines basic types. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without generics. The grammar contains types from Java, e.g., primitives, void, classes (also sometimes called \"reference types\").","title":"MCBasicTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccollectiontypesmc4-stable","text":"This grammar defines four generics: List<A> , Map<A,B> , Set<A> and Optional<A> on top of basic types. These four generics correspond to a typical predefined set of generic types for example used in connection with UML class diagrams or the OCL. UML associations typically have those association multiplicities and therefore these types are of interest. This eases the reuse of type structures in languages similar to Java, that are somewhat simplified, e.g. without general generics.","title":"MCCollectionTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcsimplegenerictypesmc4-stable","text":"This grammar introduces freely defined generic types such as Blubb<A> , Bla<B,C> , Foo<Blubb<D>> These generics are covering a wide range of uses for generic types, although they don't cover type restrictions on the arguments, like in Java.","title":"MCSimpleGenericTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcfullgenerictypesmc4-stable","text":"This grammar completes the type definitions to support the full Java type system including wildcards Blubb<? extends A> A general advice: When you are not sure that you need this kind of types, then use a simpler version from above. Type checking ist tricky.","title":"MCFullGenericTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcarraytypesmc4-stable","text":"Arrays are orthogonal to the generic extensions and thus be combined with any of the above variants. Language component MCArrayTypes provides possibilities to add arrays, such as Person[] or int[][] .","title":"MCArrayTypes.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunittypes4mathmc4-not-yet-publicly-available-for-physical-si-units-stable","text":"The known units s, m, kg, A, K, mol, cd from the international system of units (SI Units) and their combinations, such as km/h or mg , etc. can be used as ordinary types (instead of only numbers). The typecheck is extended to prevent e.g. assignment of a weight to a length variable or to add appropriate conversion, e.g. when a km/h -based velocity is e.g. stored in a m/s -based variable. The grammar resides in the MontiCore/SIunits project.","title":"SIUnitTypes4Math.mc4 (not yet publicly available) for Physical SI Units (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunittypes4computingmc4-not-yet-publicly-available-for-physical-si-units-stable","text":"Includes the types from SIUnitTypes4Math (see above), like km/h , but also allows to add a resolution, such as km/h<int> . Here SI Unit types, like km/h<.> , are used as generic type constructor that may take a number type, such as int , long , double , float as argument. The grammar resides in the MontiCore/SIunits project.","title":"SIUnitTypes4Computing.mc4 (not yet publicly available) for Physical SI Units (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#regextypemc4-not-yet-publicly-available-stable","text":"Embedded in R\"...\" a regular expressions can be used as ordinary type to constrain the values allowed for stored variables, attributes, parameters. Types are e.g. , such as R\"[a-z]\" (single character) or R\"^([01][0-9]|2[0-3])$\" (hours). A typecheck for these types can only be executed at runtime and e.g. issue exceptions (or trigger repair functions) if violated. The static typecheck only uses String as underlying carrier type. This grammar resides in the MontiCore/RegEx (not yet publicly available) project.","title":"RegExType.mc4 (not yet publicly available) (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#symbols-list-of-grammars-in-package-demonticoresymbols","text":"These two grammars do not provide syntax themselves, but characterize important forms of symbols, that will be used in the type and the expression grammars to define shared kinds of symbols.","title":"Symbols: List of Grammars in package de.monticore.symbols"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#basicsymbolsmc4-stable","text":"This grammar defines symbols for Types (of all kinds), Functions , Variables and TypeVariables . The defined symbols are of general form and can be used in functional, OO and other contexts. They do not preculde a concrete syntax and do not yet embody OO specifics. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols.","title":"BasicSymbols.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#oosymbolsmc4-stable","text":"This grammar defines symbols for objectoriented Types , Methods , and Fields by mainly extending the symbols defined in BasicTypeSymbols . The newly defined symbols extend the general ones by typical objectoriented features, such as private, static, etc. Again they do not preculde a concrete syntax. Remark: This grammar is not intended to define concrete or abstract syntax, but the infrastructure for symbols in objectoriented context.","title":"OOSymbols.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#expressions-list-of-grammars-in-package-demonticoreexpressions","text":"Expressions are defined in several grammars forming a (nonlinear) hierarchy, so that developers can choose the optimal grammar they want to build on for their language and combine these with the appropriate typing infrastructure. This modularity of expressions and associated types greatly eases the reuse of type structures in languages similar to Java. Some snipets for operators defined in expressions: grammar operators and examples in this grammar CommonExp: / % + - <= >= == > < != ~. !. .?.:. && || ~. AssigementExp: ++ -- = += -= *= /= &= |= ^= >>= >>>= <<= %= BitExp: & | ^ << >> >>> OclExp: implies <=> | & forall exists let.in. .@pre .[.] .** Set{.|.} SetExp: .isin. .in. union intersect setand setor { item | specifier } OptionalOps: ?: ?<= ?>= ?< ?> ?== ?!= ?~~ ?!~ SIUnits: 5km 3,2m/s 22l 2.400J JavaClass: this .[.] (.). super .instanceof.","title":"Expressions: List of Grammars in package de.monticore.expressions"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#expressionsbasismc4-stable","text":"This grammar defines core interfaces for expressions and imports the kinds of symbols necessary. The symbols are taken over from the TypeSymbols grammar (see below). A hierarchy of conservative extensions to this grammar realize these interfaces in various forms.","title":"ExpressionsBasis.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#commonexpressionsmc4-stable","text":"This grammar defines a typical standard set of operations for expressions. This is a subset of Java as well as OCL/P, mainly for arithmetic, comparisons, variable use (v), attribute use (o.att), method call (foo(arg,arg2)) and brackets (exp).","title":"CommonExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#assignmentexpressionsmc4-stable","text":"This grammar defines all Java expressions that have side effects. This includes assignment expressions like =, +=, etc. and suffix and prefix expressions like ++, --, etc.","title":"AssignmentExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#bitexpressionsmc4-stable","text":"This grammar defines a typical standard set of operations for expressions. This is a subset of Java for binary expressions like <<, >>, >>>, &, ^ and |","title":"BitExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#oclexpressionsmc4-not-yet-publicly-available-stable","text":"This grammar defines expressions typical to UMLs OCL . OCL expressions can savely be composed if with other forms of expressions given in the MontiCore core project (i.e. as conservative extension). It contains various logical operations, such as quantifiers, the let and the @pre construct, and a transitive closure for associations, as discussed in [Rum17,Rum17]. This grammar resides in the MontiCore/OCL (not yet publicly available) project.","title":"OCLExpressions.mc4 (not yet publicly available) (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#setexpressionsmc4-not-yet-publicly-available-stable","text":"This grammar defines set expressions like set union, intersection etc. these operations are typical for a logic with set operations, like UML's OCL. These operators are usually infix and are thus more intuitive as they allow math oriented style of specification. Most of these operators are in principle executable, so it might be interesting to include them in a high level programming language (see e.g. Haskell) This grammar resides in the MontiCore/OCL (not yet publicly available) project.","title":"SetExpressions.mc4 (not yet publicly available) (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#optionaloperatorsmc4-not-yet-publicly-available-stable","text":"This grammar defines nine operators dealing with optional values, e.g. defined by java.lang.Optional . The operators are also called Elvis operators . E.g.: val ?: 0W equals to val.isPresent ? val.get : 0W x ?>= y equals x.isPresent && x.get >= y This grammar resides in the MontiCore/OCL (not yet publicly available) project.","title":"OptionalOperators.mc4 (not yet publicly available) (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunitsmc4-not-yet-publicly-available-for-physical-si-units-stable","text":"This grammar the international system of units (SI units), based on the basis units s, m, kg, A, K, mol, cd , provides a variety of derived units, and can be refined using prefixes such as m (milli), k (kilo), etc. The SI Unit grammar provides an extension to expressions, but also to the typing system, e.g. types such as km/h or km/h<long> , and literals, such as e.g. 5.3 km/h . The grammars reside in the MontiCore/SIunits project","title":"SIUnits.mc4 (not yet publicly available) for Physical SI Units (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#javaclassexpressionsmc4-stable","text":"This grammar defines Java specific class expressions like super, this, type cast, etc. This grammar should only be included, when a mapping to Java is intended and the full power of Java should be available in the modelling language.","title":"JavaClassExpressions.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#literals-list-of-grammars-in-package-demonticoreliterals","text":"Literals are the basic elements of expressions, such as numbers, strings, truth values. Some snipets: grammar examples of this grammar MCCommonLit 3 -3 2.17 -4 true false 'c' 3L 2.17d 2.17f 0xAF \"string\" \"str\\uAF01\\u0001\" null MCJavaLiterals 999_999 0x3F2A 0b0001_0101 0567 1.2e-7F SIUnitLiterals 5.3km/h 7mg","title":"Literals: List of Grammars in package de.monticore.literals"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcliteralsbasismc4-stable","text":"This grammar defines core interface for literals. Several conservative extensions to this grammar realize various forms of literals.","title":"MCLiteralsBasis.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonliteralsmc4-stable","text":"This grammar defines the typical literals for an expression language, such as characters: 'c', Strings \"text\", booleans: \"true\", \"null\", or numbers 10, -23, 48l, 23.1f. Strings and characters use the Java-like escapes like \" \". Each defined nonterminal is extended by a conversion function getValue() of appropriate type and a retrieve function getSource() for a text representation of the literal.","title":"MCCommonLiterals.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcjavaliteralsmc4-stable","text":"This grammar defines Java compliant literals and builds on MCCommonLiterals. The scope of this grammar is to ease the reuse of literals structures in Java-like sublanguages. The grammar contains literals from Java, e.g., Boolean, Char, String, .... Please note that Java (and this grammar) has an extended syntax e.g. for integers using underscores or other kinds of encodings. They parse e.g. 999_999, 0x3F2A, or 0b10100. Like above getValue() and getSource() allow to retrive the content as value resp. as text string.","title":"MCJavaLiterals.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#siunitliteralsmc4-not-yet-publicly-available-for-physical-si-units-stable","text":"Provides concrete values, such as 5.3 km/h or 7 mg for the international system of units (SI Units). The grammar resides in the MontiCore/SIunits project.","title":"SIUnitLiterals.mc4 (not yet publicly available) for Physical SI Units (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#statements-list-of-grammars-in-package-demonticorestatements","text":"Statements are the constructive part of programs: They allow to change variables, call functions, send messages etc. The following hierarchy of statement definitions should allow the developers to choose needed forms of statements and extend it by their own additional needs. The provided list of statements is inspired by Java (actually subset of Java). Some example statements: int i; int j = 2; Person p[] = { foo(3+7), p2, ...} if (.) then . else . for ( i = .; .; .) {.} while (.) . do . while (.) switch (.) { case .: .; default: .} foo(1,2,3) return . assert . : \"...\" try {.} catch (.) {.} finally {.} throw . break . continue . label: private static final native ...","title":"Statements: List of Grammars in package de.monticore.statements"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcstatementsbasismc4-stable","text":"This grammar defines the core interface for statements. A hierarchy of conservative extensions to this grammar is provided below.","title":"MCStatementsBasis.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonstatementsmc4-stable","text":"This grammar defines typical statements, such as method calls (which are actually expressions), assignment of variables, if, for, while, switch statements, and blocks. This embodies a complete structured statement language, however does not provide return, assert, exceptions, and low-level constructs like break.","title":"MCCommonStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcassertstatementsmc4-stable","text":"This grammar defines exactly the assert statement as known from Java. It can be used independently of other Java statements.","title":"MCAssertStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcexceptionstatementsmc4-stable","text":"This grammar defines the exception statements. This includes Java try with catch and finally, as well as throw.","title":"MCExceptionStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcsynchronizedstatementsmc4-stable","text":"This grammar defines the Java-like synchronized statement.","title":"MCSynchronizedStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mclowlevelstatementsmc4-stable","text":"This grammar defines three low-level statements that Java provides. It contains the break and continue statements and the possibility to label a statement.","title":"MCLowLevelStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcreturnstatementsmc4-stable","text":"This grammar defines the Java-like return statement.","title":"MCReturnStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mcfulljavastatementsmc4-stable","text":"This grammar defines all Java statements. This is neither a generalized approximation nor a restricted overapproximation, but exact.","title":"MCFullJavaStatements.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#further-grammars-in-package-demonticore","text":"several other grammars are also available:","title":"Further grammars in package de.monticore"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#regularexpressionsmc4-not-yet-publicly-available-stable","text":"This grammar defines regular expressions (RegEx) as used in Java (see e.g. java.util.regex.Pattern ). It provides common regex tokens such as character classes, e.g., lowercase letters ( [a-z] ), the letters a, b, and c ( [abc] ) anchors, e.g., start of line ( ^ ), end of line ( $ ), word boundary ( \b ), quantifiers, e.g., zero or one ( ? ), zero or more ( * ), exactly 3 ( {3} ), RegEx also supports to capture groups and referencing these captured groups in replacements. For example, ^([01][0-9]|2[0-3]):[0-5][0-9]$ matches all valid timestamps in HH:MM format. The main nonterminal RegularExpression is not part of the expression hierarchy and thus regular expressions are not used as ordinary values. Instead the nonterminal RegularExpression is can be used in aother places of a language e.g. we do that as additional restriction for String values in input/output channels in architectural langages. This grammar resides in the MontiCore/RegEx (not yet publicly available) project","title":"RegularExpressions.mc4 (not yet publicly available) (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#cardinalitymc4-stable","text":"This grammar defines UML Cardinalities of forms * , [n..m] or [n..*] .","title":"Cardinality.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#completenessmc4-stable","text":"This grammar defines completeness information in UML like ... , (c) , but also (...,c) .","title":"Completeness.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#umlmodifiermc4-stable","text":"The grammar contains the modifiers that UML provides. This includes public private , protected , final , abstract , local , derived , readonly , and static , but also the compact syntactic versions + , # , - , / and ? (for readonly). UML modifiers are not identical to Java modifiers (e.g. native or threadsafe are missing.)","title":"UMLModifier.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#umlstereotypemc4-stable","text":"This grammars defines Stereotypes like <<val1,val2=\"text\",...>> Methods contains(name), getValue(name) assist Stereotype retrieval. Values may only be of type String. The real value unfortunately in UML is only encoded as String. We suggest to use a tagging infrastructure that even allows to type the possible forms of tags.","title":"UMLStereotype.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#mccommonmc4-stable","text":"This grammar composes typical UML like grammar components. This includes Cardinality, Completeness, UMLModifier, and UMLStereotype.","title":"MCCommon.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#javalightmc4-stable","text":"int age = 3+x; List<Person> myParents; @Override public int print(String name, Set<Person> p) { int a = 2 + name.length(); if(a < p.size()) { System.out.println(\"Hello \" + name); } return a; } JavaLight is a subset of Java that MontiCore itself uses as intermediate language for the code generation process. JavaLight doesn't provide all forms of classes (e.g. inner classes) and reduces the type system to normal generic types. However, that is sufficient for representation of all generated pieces of code that MontiCore wants to make. Included are: the full Java expressions (without anonymous classes), the relevant Java statements, declaration of methods, constructors, constants, interface methods, and annotations. JavaLight composes from CommonExpressions , AssignmentExpressions , JavaClassExpressions , MCCommonStatements , MCBasicTypes , and OOSymbols . JavaLight can be used for other generator tools as well, especially as its core templates are reusable and new templates for specific method bodies can be added using MontiCore's Hook-Mechanisms.","title":"JavaLight.mc4 (stable)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#examples-for-grammars-under-monticore-grammarsrcmainexamples","text":"These can also be used if someone is interested: StringLiterals.mc4 MCHexNumbers.mc4 MCNumbers.mc4","title":"Examples for Grammars under monticore-grammar/src/main/examples"},{"location":"monticore-grammar/src/main/grammars/de/monticore/Grammars/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/","text":"JavaLight The JavaLight language defines a subset of the Java programming language. The JavaLight language is dedicated for embedding Java language elementsin arbitrary DSLs. It is therfore defined in a compositional style, i.e. for black box reuse (without need for copy-paste). The JavaLight language introduces * all forms of attribute declarations , * all forms of method declarations (including constructors ), * all forms of Java expressions (including those with side effects, such as i++ , but without anonymous classes), * almost all Java statements , with the exception of statements for exception handling, continue- and break-statement, and synchronization, which are omitted because there are many DSLs, where these are of no use; * and it allows to import usable types, method, and attribute symbols, which may be predefined or imported from of Java-like models. Example int age = 3+x; List<Person> myParents; @Override public int print(String name, Set<Person> p) { int a = 2 + name.length(); if(a < p.size()) { System.out.println(\"Hello \" + name); } return a; } The example shows a Java method with one parameter and three statements. Expressions are supported in all their forms. Grammar The main grammar file is de.monticore.JavaLight (not yet publicly available) . It deals with the definition of the method and constructor signatures , and the annotations , while it reuses MontiCore's library components AssignmentExpressions , JavaClassExpressions , MCCommonStatements , and MCArrayStatements for expressions and statements. Extension of JavaLight JavaLight is designed for easy black-box reuse . It can be extended by domain specific constructs, such as 1. special statements for message processing ( c?x; c!3+x ), 2. statements for testing such as Hoare-like asserts or pre/postconditions, or 3. additional logical or otherwise interesting expression operators ( forall x in Set: ). 4. The omitted Java-special statements, such as eception handling, can also be addded through a predefined language library component. JavaLight is fully compatible with various expression language components that MontiCore's library provides. These extensions can simply be added by MontiCore's language composition mechanism (see Handbook ). Embedding of JavaLight Expression or Statement JavaLight's expressions can be embedded as expression sublanguage in any other interesting domain specific language, such as Automata, Activity Diagrams, etc. (even MontiCore's primary language uses this). The statements can also be embedded as sublanguage e.g. as actions in StateCharts. JavaLight is a strict subset of the Java programming language and thus can be mapped directly to itself when generating code for Java. Parser JavaLight is a component grammar. To retrieve a parser it is to be embedded into a full grammar. Symboltable and Symbol classes JavaLight introduces the JavaMethodSymbol extending the existing MethodSymbol for general object-oriented types. The JavaMethodSymbol class carries the additional attributes: annotations, exceptions, and Booleans for isEllipsisParameterMethod , isFinal , isAbstract , isSynchronized , isNative , and isStrictfp . Symbols (imported and exported) Import: the following symbols can be imported from outside, when the symbol table in the embedding language provides these symbols: VariableSymbol for attributes and otherwise accessible variables. MethodSymbol for method and constructor calls (this includes also JavaMethodSymbol ). TypeSymbols for using types, e.g., defined via classes, interfaces, and enums. Symbol definition and export: It is possible to define new symbols, for attributes, methods, and constructors. The provided symbol table will include them as VariableSymbol for attributes MethodSymbol for methods and constructors and thus will make the accessibility of these symbols available outside the JavaLight sub-models. Functionality As usual functionality is implemented in a compositional form, which means that in a composed language these functions should be largely reusable as pre-compiled black-boxes. Context Conditions JavaLight defines the following CoCos: * ConstructorFormalParametersDifferentName checks if all input parameters of a constructor have distinct names. * ConstructorModifiersValid checks that a constructor is not marked as abstract , final , static , or native . * ConstructorNoAccessModifierPair checks that no duplicate visibility occurs for a constructor. * ConstructorNoDuplicateModifier checks that no duplicate modifier occurs for a constructor. * MethodAbstractAndOtherModifiers checks that an abstract method is not marked as private , static , final , native , or synchronized . * MethodBodyAbsence ensures that a method body may only be absent for abstract or native methods. * MethodBodyPresence checks that a method with a present method body is neither abstract nor native . * MethodExceptionThrows ensures that thrown exceptions are of type java.lang.Throwable . * MethodFormalParametersDifferentName checks if all input parameters of a method have distinct names. * MethodNoDuplicateModifier checks that no duplicate modifier occurs for a method. * MethodNoNativeAndStrictfp checks that method is not marked as native and strictfp . The CoCos of embedded languages, such as statements and expressions are defined there and reused as black-boxes. PrettyPrinter The basic pretty printer for JavaLight is de.monticore.prettyprint.JavaLightPrettyPrinter (not yet publicly available) When the expression language is used as high-level language, it might make sense to map attribute access to get-functions respectively also use set-functions for modification. This can be done using a more elaborated pretty printer. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore License definition","title":"JavaLight"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#javalight","text":"The JavaLight language defines a subset of the Java programming language. The JavaLight language is dedicated for embedding Java language elementsin arbitrary DSLs. It is therfore defined in a compositional style, i.e. for black box reuse (without need for copy-paste). The JavaLight language introduces * all forms of attribute declarations , * all forms of method declarations (including constructors ), * all forms of Java expressions (including those with side effects, such as i++ , but without anonymous classes), * almost all Java statements , with the exception of statements for exception handling, continue- and break-statement, and synchronization, which are omitted because there are many DSLs, where these are of no use; * and it allows to import usable types, method, and attribute symbols, which may be predefined or imported from of Java-like models.","title":"JavaLight"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#example","text":"int age = 3+x; List<Person> myParents; @Override public int print(String name, Set<Person> p) { int a = 2 + name.length(); if(a < p.size()) { System.out.println(\"Hello \" + name); } return a; } The example shows a Java method with one parameter and three statements. Expressions are supported in all their forms.","title":"Example"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#grammar","text":"The main grammar file is de.monticore.JavaLight (not yet publicly available) . It deals with the definition of the method and constructor signatures , and the annotations , while it reuses MontiCore's library components AssignmentExpressions , JavaClassExpressions , MCCommonStatements , and MCArrayStatements for expressions and statements.","title":"Grammar"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#extension-of-javalight","text":"JavaLight is designed for easy black-box reuse . It can be extended by domain specific constructs, such as 1. special statements for message processing ( c?x; c!3+x ), 2. statements for testing such as Hoare-like asserts or pre/postconditions, or 3. additional logical or otherwise interesting expression operators ( forall x in Set: ). 4. The omitted Java-special statements, such as eception handling, can also be addded through a predefined language library component. JavaLight is fully compatible with various expression language components that MontiCore's library provides. These extensions can simply be added by MontiCore's language composition mechanism (see Handbook ).","title":"Extension of JavaLight"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#embedding-of-javalight-expression-or-statement","text":"JavaLight's expressions can be embedded as expression sublanguage in any other interesting domain specific language, such as Automata, Activity Diagrams, etc. (even MontiCore's primary language uses this). The statements can also be embedded as sublanguage e.g. as actions in StateCharts. JavaLight is a strict subset of the Java programming language and thus can be mapped directly to itself when generating code for Java.","title":"Embedding of JavaLight Expression or Statement"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#parser","text":"JavaLight is a component grammar. To retrieve a parser it is to be embedded into a full grammar.","title":"Parser"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#symboltable-and-symbol-classes","text":"JavaLight introduces the JavaMethodSymbol extending the existing MethodSymbol for general object-oriented types. The JavaMethodSymbol class carries the additional attributes: annotations, exceptions, and Booleans for isEllipsisParameterMethod , isFinal , isAbstract , isSynchronized , isNative , and isStrictfp .","title":"Symboltable and Symbol classes"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#symbols-imported-and-exported","text":"Import: the following symbols can be imported from outside, when the symbol table in the embedding language provides these symbols: VariableSymbol for attributes and otherwise accessible variables. MethodSymbol for method and constructor calls (this includes also JavaMethodSymbol ). TypeSymbols for using types, e.g., defined via classes, interfaces, and enums. Symbol definition and export: It is possible to define new symbols, for attributes, methods, and constructors. The provided symbol table will include them as VariableSymbol for attributes MethodSymbol for methods and constructors and thus will make the accessibility of these symbols available outside the JavaLight sub-models.","title":"Symbols (imported and exported)"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#functionality","text":"As usual functionality is implemented in a compositional form, which means that in a composed language these functions should be largely reusable as pre-compiled black-boxes.","title":"Functionality"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#context-conditions","text":"JavaLight defines the following CoCos: * ConstructorFormalParametersDifferentName checks if all input parameters of a constructor have distinct names. * ConstructorModifiersValid checks that a constructor is not marked as abstract , final , static , or native . * ConstructorNoAccessModifierPair checks that no duplicate visibility occurs for a constructor. * ConstructorNoDuplicateModifier checks that no duplicate modifier occurs for a constructor. * MethodAbstractAndOtherModifiers checks that an abstract method is not marked as private , static , final , native , or synchronized . * MethodBodyAbsence ensures that a method body may only be absent for abstract or native methods. * MethodBodyPresence checks that a method with a present method body is neither abstract nor native . * MethodExceptionThrows ensures that thrown exceptions are of type java.lang.Throwable . * MethodFormalParametersDifferentName checks if all input parameters of a method have distinct names. * MethodNoDuplicateModifier checks that no duplicate modifier occurs for a method. * MethodNoNativeAndStrictfp checks that method is not marked as native and strictfp . The CoCos of embedded languages, such as statements and expressions are defined there and reused as black-boxes.","title":"Context Conditions"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#prettyprinter","text":"The basic pretty printer for JavaLight is de.monticore.prettyprint.JavaLightPrettyPrinter (not yet publicly available) When the expression language is used as high-level language, it might make sense to map attribute access to get-functions respectively also use set-functions for modification. This can be done using a more elaborated pretty printer.","title":"PrettyPrinter"},{"location":"monticore-grammar/src/main/grammars/de/monticore/JavaLight/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore License definition","title":"Further Information"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/","text":"MontiCore - Expression-Language Modules MC-Expressions are used to formulate mathematical and programmatic expressions of a set of literals. To achieve this, a system of modular and pluggable grammar parts are developed. Given Expression languages in MontiCore Currently, there are five expression languages. These are ExpressionsBasis (basis for all of the expression languages, supports names and literals) AssignmentExpressions (extends ExpressionsBasis, basic assignments) CommonExpressions (extends ExpressionsBasis, common expressions like + and -) BitExpressions (extends ExpressionsBasis, bit expressions like & or <<) JavaClassExpressions (extends CommonExpressions, adds Java expressions like new) Two further expression languages are defined in the OCL project: OCL-SetExpressions (extends ExpressionsBasis, ideal for working with sets) OCL-OCLExpressions (extends ExpressionsBasis, introduces OCL to MontiCore) Furthermore, composite SI unit expressions are defined in the SI Units project: * SI Units (can be used to parse primitive units as well as their products, quotients, and powers) Using Expressions If you want to use one (or more) of the given expression languages in your language, then all you have to do is extend it (or them) in your grammar. You are free to use any of them now. Creating your own Expression language There are some expressions you need desperately and that are not covered in the given expression languages? Create a new grammar that extends at least ExpressionsBasis. In this grammar, you can add your own expressions. These expressions must implement the interface Expression in the ExpressionsBasis grammar. To include these expressions in your language, just extend the new grammar in your language. See here for an example. Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Expressions"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#monticore-expression-language-modules","text":"MC-Expressions are used to formulate mathematical and programmatic expressions of a set of literals. To achieve this, a system of modular and pluggable grammar parts are developed.","title":"MontiCore - Expression-Language Modules"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#given-expression-languages-in-monticore","text":"Currently, there are five expression languages. These are ExpressionsBasis (basis for all of the expression languages, supports names and literals) AssignmentExpressions (extends ExpressionsBasis, basic assignments) CommonExpressions (extends ExpressionsBasis, common expressions like + and -) BitExpressions (extends ExpressionsBasis, bit expressions like & or <<) JavaClassExpressions (extends CommonExpressions, adds Java expressions like new) Two further expression languages are defined in the OCL project: OCL-SetExpressions (extends ExpressionsBasis, ideal for working with sets) OCL-OCLExpressions (extends ExpressionsBasis, introduces OCL to MontiCore) Furthermore, composite SI unit expressions are defined in the SI Units project: * SI Units (can be used to parse primitive units as well as their products, quotients, and powers)","title":"Given Expression languages in MontiCore"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#using-expressions","text":"If you want to use one (or more) of the given expression languages in your language, then all you have to do is extend it (or them) in your grammar. You are free to use any of them now.","title":"Using Expressions"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#creating-your-own-expression-language","text":"There are some expressions you need desperately and that are not covered in the given expression languages? Create a new grammar that extends at least ExpressionsBasis. In this grammar, you can add your own expressions. These expressions must implement the interface Expression in the ExpressionsBasis grammar. To include these expressions in your language, just extend the new grammar in your language. See here for an example.","title":"Creating your own Expression language"},{"location":"monticore-grammar/src/main/grammars/de/monticore/expressions/Expressions/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/","text":"MontiCore - Literals Literals are the basis to parse Numbers, Strings and other atomic language elements. Modularization works as follows. 'MCLiteralBasis' defines the root nonterminal 'Literal', but no terminals with literal terms. Concrete terminal symbols are defined in MCCommonLiterals and MCJavaLiterals and can be included into a concrete language as desired. Grammar MCCommonLiterals.mc4 This Grammar includes rules to parse: 'null' - NullLiteral 'true' & 'false' - BooleanLiteral 'a', ... , 'Z' - CharLiteral '\"...\"' - StringLiteral '123' - NatLiteral '-13' - SignedNatLiteral '6L', '6l' - BasicLongLiteral '-6L', '-6l', '6L', '6l' - SignedBasicLongLiteral '1.2F', '1.2f' - BasicFloatLiteral '-1.2F', '-1.2f', '1.2F', '1.2f' - SignedBasicFloatLiteral Grammar MCJavaLiterals.mc4 This Grammar extends MCCommonLiterals.mc4 and includes rules to parse: '123','0734', '1001001', '0x1a' - IntLiteral '2L', '0734l', '1001001L', '0x1al' - LongLiteral '1.23F', '1.23E4f' - FloatLiteral '1.23', '1.23d', '1.23E4D' - DoubleLiteral Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Literals"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#monticore-literals","text":"Literals are the basis to parse Numbers, Strings and other atomic language elements. Modularization works as follows. 'MCLiteralBasis' defines the root nonterminal 'Literal', but no terminals with literal terms. Concrete terminal symbols are defined in MCCommonLiterals and MCJavaLiterals and can be included into a concrete language as desired.","title":"MontiCore - Literals"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#grammar-mccommonliteralsmc4","text":"This Grammar includes rules to parse: 'null' - NullLiteral 'true' & 'false' - BooleanLiteral 'a', ... , 'Z' - CharLiteral '\"...\"' - StringLiteral '123' - NatLiteral '-13' - SignedNatLiteral '6L', '6l' - BasicLongLiteral '-6L', '-6l', '6L', '6l' - SignedBasicLongLiteral '1.2F', '1.2f' - BasicFloatLiteral '-1.2F', '-1.2f', '1.2F', '1.2f' - SignedBasicFloatLiteral","title":"Grammar MCCommonLiterals.mc4"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#grammar-mcjavaliteralsmc4","text":"This Grammar extends MCCommonLiterals.mc4 and includes rules to parse: '123','0734', '1001001', '0x1a' - IntLiteral '2L', '0734l', '1001001L', '0x1al' - LongLiteral '1.23F', '1.23E4f' - FloatLiteral '1.23', '1.23d', '1.23E4D' - DoubleLiteral","title":"Grammar MCJavaLiterals.mc4"},{"location":"monticore-grammar/src/main/grammars/de/monticore/literals/Literals/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/","text":"MontiCore - Types Type systems are available in a variety of (programming) languages and facilitate programming because typing errors can already be detected at compile time. To express type usages a language component hierarchy for modeling types was developed for MontiCore-based languages. It consists of five language components MCBasicTypes , MCCollectionTypes , MCSimpleGenericTypes , MCFullGenericTypes , and MCArrayTypes . MCBasicTypes The most basic language component is MCBasicTypes , which provides the central interface nonterminal MCType . Besides this interface nonterminal, this language component provides nonterminals that enable modeling primitive types and qualified as well as non-qualified types. Furthermore, it provides a return type, which can be an MCType or void . These nonterminals are bundled as it provides a relativity small yet useful collection of types for modeling. When using this language component, types such as int , Person , or java.lang.String are expressible. MCCollectionTypes The MCCollectionTypes language component builds upon the basic types language component and enables to model four kinds of generics: Set , List , Map , and Optional . These generics cannot be nested as the purpose of this language component is to provide some commonly used collection types but limit their functionality such that it is useful for high-level models. Using this language component, types such as List<Integer> , Set<char> , or Map<java.lang.String, Person> are expressible. MCSimpleGenericTypes The language component MCSimpleGenericTypes extends the language component MCCollectionTypes and extends the expressible types with custom generics of arbitrary classes with arbitrary arguments. When using this language component, types such as Person<String> or Map<Person<String>, Integer> are expressible. Please note that these types still do not cover all possible types from Java, as Java additionally supports inner types of generic types, which is not expressible using the language component SimpleGenericTypes , e.g., types such as a.b.C<D>.E.F<G>.H are not expressible. MCFullGenericTypes The language component MCFullGenericTypes extends the language component MCSimpleGenericTypes and extends the expressible types with inner generics types of arbitrary classes with arbitrary arguments including wild card types. When using this language component, types such as Person<?> , Map<Person<String>, ? extends Person> or a.b.C<D>.E.F<G>.H are expressible. MCArrayTypes Arrays are orthogonal to the generic extensions. Thus they can be combined with any of the above variants. Language component MCArrayTypes provides possibilities to add arrays, such as Person[] or int[][] . Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Types"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#monticore-types","text":"Type systems are available in a variety of (programming) languages and facilitate programming because typing errors can already be detected at compile time. To express type usages a language component hierarchy for modeling types was developed for MontiCore-based languages. It consists of five language components MCBasicTypes , MCCollectionTypes , MCSimpleGenericTypes , MCFullGenericTypes , and MCArrayTypes .","title":"MontiCore - Types"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcbasictypes","text":"The most basic language component is MCBasicTypes , which provides the central interface nonterminal MCType . Besides this interface nonterminal, this language component provides nonterminals that enable modeling primitive types and qualified as well as non-qualified types. Furthermore, it provides a return type, which can be an MCType or void . These nonterminals are bundled as it provides a relativity small yet useful collection of types for modeling. When using this language component, types such as int , Person , or java.lang.String are expressible.","title":"MCBasicTypes"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mccollectiontypes","text":"The MCCollectionTypes language component builds upon the basic types language component and enables to model four kinds of generics: Set , List , Map , and Optional . These generics cannot be nested as the purpose of this language component is to provide some commonly used collection types but limit their functionality such that it is useful for high-level models. Using this language component, types such as List<Integer> , Set<char> , or Map<java.lang.String, Person> are expressible.","title":"MCCollectionTypes"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcsimplegenerictypes","text":"The language component MCSimpleGenericTypes extends the language component MCCollectionTypes and extends the expressible types with custom generics of arbitrary classes with arbitrary arguments. When using this language component, types such as Person<String> or Map<Person<String>, Integer> are expressible. Please note that these types still do not cover all possible types from Java, as Java additionally supports inner types of generic types, which is not expressible using the language component SimpleGenericTypes , e.g., types such as a.b.C<D>.E.F<G>.H are not expressible.","title":"MCSimpleGenericTypes"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcfullgenerictypes","text":"The language component MCFullGenericTypes extends the language component MCSimpleGenericTypes and extends the expressible types with inner generics types of arbitrary classes with arbitrary arguments including wild card types. When using this language component, types such as Person<?> , Map<Person<String>, ? extends Person> or a.b.C<D>.E.F<G>.H are expressible.","title":"MCFullGenericTypes"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#mcarraytypes","text":"Arrays are orthogonal to the generic extensions. Thus they can be combined with any of the above variants. Language component MCArrayTypes provides possibilities to add arrays, such as Person[] or int[][] .","title":"MCArrayTypes"},{"location":"monticore-grammar/src/main/grammars/de/monticore/types/Types/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/","text":"In MontiCore, the TypeCheck is used to calculate the SymTypeExpression of a set of expressions, types and literals. This is made possible by traversing the AST of an expression, type or literal, calculating the SymTypeExpression of its subexpressions, -types or -literals and combining them to the SymTypeExpression of the main expression, type or literal. Given infrastructure in MontiCore TypeCheck (facade for using the TypeCheck) DeriveSymTypeOfExpression (calculate a SymTypeExpression for the expressions in the grammar ExpressionsBasis) DeriveSymTypeOfCommonExpressions (calculate a SymTypeExpression for the expressions in the grammar CommonExpressions) DeriveSymTypeOfAssignmentExpressions (calculate a SymTypeExpression for the expressions in the grammar AssignmentExpressions) DeriveSymTypeOfBitExpressions (calculate a SymTypeExpression for the expressions in the grammar BitExpressions) DeriveSymTypeOfLiterals (calculate a SymTypeExpression for the literals in the grammar LiteralsBasis) DeriveSymTypeOfMCCommonLiterals (calculate a SymTypeExpression for the literals in the grammar MCCommonLiterals) DeriveSymTypeOfMCJavaLiterals (calculate a SymTypeExpression for the literals in the grammar MCJavaLiterals) SynthesizeSymTypeFromMCBasicTypes (calculate a SymTypeExpression for the types in the grammar MCBasicTypes) SynthesizeSymTypeFromMCCollectionTypes (calculate a SymTypeExpression for the types in the grammar MCCollectionTypes) SynthesizeSymTypeFromMCSimpleGenericTypes (calculate a SymTypeExpression for the types in the grammar MCSimpleGenericTypes) SynthesizeSymTypeFromMCFullGenericTypes (calculate a SymTypeExpression for the types in the grammar MCFullGenericTypes) BasicSymbols (defines the symbols needed for the symboltable) OOSymbols (specialization of the BasicSymbols for object-oriented languages) SymTypeExpression (result of the TypeCheck, represents type usage) SymTypeArray (subclass of SymTypeExpression, represents arrays) SymTypeConstant (subclass of SymTypeExpression, represents primitive types) SymTypeOfGenerics (subclass of SymTypeExpression, represents generic types) SymTypeOfObject (subclass of SymTypeExpression, represents non-primitive types without type arguments) SymTypeVariable (subclass of SymTypeExpression, represents type variables) SymTypeOfNull (subclass of SymTypeExpression, represents the null type) SymTypeVoid (subclass of SymTypeExpression, represents the void type) SymTypeOfWildcard (subclass of SymTypeExpression, represents wildcard types) SymTypeExpressionFactory (factory for creating the subclasses of SymTypeExpression) What is the difference between TypeSymbols and SymTypeExpressions? The TypeCheck uses the TypeSymbols of the BasicSymbols grammar and the handwritten SymTypeExpressions. While they are very similar, there is a big difference between them and when to use them. The TypeSymbols represent a type definition (example in Java: class List ) while the SymTypeExpressions represent a type usage (example in Java: List ). There is only one type definition, but there can be many type usages. The SymTypeExpression knows its corresponding TypeSymbol (like the type usage knows its definition) and can refer to its methods and fields. So when talking about a type definition, a type symbol, which can be stored and is present only once in the symboltable, has to be used. A SymTypeExpression is not stored in the symboltable, but refers to the definition of its type (its corresponding TypeSymbol) in the symboltable. Thus, a SymTypeExpression can be used multiple times and represents the usage of a type. The TypeCheck facade The TypeCheck class of MontiCore is used as a facade to make TypeChecking easier for the user. It needs a Derive-Class and/or a Synthesize-Class to be instantiated. Here is a list of the methods and functions of the TypeCheck. * SymTypeExpression typeOf(ASTExpression expr) (uses the Derive-Class to derive a SymTypeExpression from an ASTExpression) * SymTypeExpression typeOf(ASTLiteral lit) (uses the Derive-Class to derive a SymTypeExpression from an ASTLiteral) * SymTypeExpression symTypeFromAST(ASTType type) (uses the Synthesize-Class to derive a SymTypeExpression from an ASTType) * static boolean compatible(SymTypeExpression left, SymTypeExpression right) (checks if the type of the right SymTypeExpression would be assignable to a variable with the type of the left SymTypeExpression) * static boolean isSubTypeOf(SymTypeExpression sub, SymTypeExpression sup) (checks if the type of sub is a subtype of the type of sup) * static boolean isInt(SymTypeExpression sym) (there are methods like this for all primitive types, checks if the SymTypeExpression represents the type 'int') How does the TypeCheck work? The TypeCheck can be used to derive a SymTypeExpression from an expression or type. For example, when using an ASTPlusExpression '3+4', the TypeCheck returns a SymTypeExpression representing the type 'int'. You can use the ASTPlusExpression as a parameter for the method typeOf of the TypeCheck facade. This method delegates the calculation to your Derive-Class. First it derives the SymTypeExpression of the subexpressions '3' and '4' (the LiteralExpressions used in the PlusExpression) and then it calculates the SymTypeExpression of the whole PlusExpression by combining the SymTypeExpressions of its subexpressions in the context of the '+' operator. In general, the derivation of SymTypeExpressions for expressions first calculates the SymTypeExpressions of its subexpressions and (depending on the results) then combines these SymTypeExpression adequately to one SymTypeExpression for the whole expression. Deriving the SymTypeExpression of a type is often easier than deriving the SymTypeExpression of an expression. The ASTMCPrimitiveType 'int' will result in a SymTypeExpression 'int', the ASTMCBasicGenericType 'java.util.Map ' will result in a SymTypeExpression 'java.util.Map '. The derivation of types is very similar to the derivation of expressions with regard to subtypes and subexpressions. If a type has subtypes (like type arguments), then the SymTypeExpressions representing these subtypes will be calculated first. They can be used to put together the SymTypeExpression of the whole type. Because both types and expressions are converted into SymTypeExpressions, you can compare them. This is useful in the next example: int a = \"Hello\"; The SymTypeExpression derived from the ASTPrimitiveType 'int' will be 'int', the SymTypeExpression derived from the ASTLiteralExpression \"Hello\" will be 'String'. In a CoCo, you can check if they are compatible by using the function 'compatible' of the TypeCheck facade. I want to write a CoCo for my language that uses the TypeCheck - How? You can use the TypeCheck facade. The facade needs a Derive-Class (for expressions and literals) and/or a Synthesize-Class (for types) and calculates the SymTypeExpression of your given expressions/literals/types. Create a DelegatorVisitor which combines all expression grammars and literal grammars used by your language. The DelegatorVisitor needs to implement the Interface IDerive. Use this Delegator as Derive-Class in the TypeCheck facade. The Synthesize-Class depends on the types grammar you use (see above-mentioned classes). For an example of the Delegator-Visitor see here . If you want to create a Derive-Class for your expression/literal grammar, you have to extend the Derive-Class of the supergrammar and implement the standard visitor of your language. There you can override the traverse methods for your expressions/literals so that it calculates the SymTypeExpression of the expression/literal (see implementation in one of the above-mentioned classes). You can add your visitor to the DelegatorVisitor later on. For an example of the Derive-Class for one language see here . For an example of the Synthesize-Class for one language see here Writing a CoCo to check the correctness of your type/expression/literal should be easy now that you have the TypeCheck facade to use. Just use the correct Derive-Class and/or the correct Synthesize-Class as parameters and check if the SymTypeExpression of your expression or type is correctly calculated. Example for a CoCo: @Override public void check(ASTExpression expr){ YourDeriveClass deriveClass = new YourDeriveClass(...); //instance of your Derive-Class YourSynthesizeClass synthesizeClass = new YourSynthesizeClass(...); //instance of your Synthesize-Class TypeCheck check = new TypeCheck(synthesizeClass,deriveClass); //instance of the TypeCheck-facade, parameters are your Synthesize-Class and your Derive-Class if(!\"double\".equals(check.typeOf(expr).print())){ //test if your expression is of the correct type (here: double) Log.error(...); //your specified error message } } An example for the case that a plus expression needs to return 'int' can be found here . Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"TypeCheck"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#given-infrastructure-in-monticore","text":"TypeCheck (facade for using the TypeCheck) DeriveSymTypeOfExpression (calculate a SymTypeExpression for the expressions in the grammar ExpressionsBasis) DeriveSymTypeOfCommonExpressions (calculate a SymTypeExpression for the expressions in the grammar CommonExpressions) DeriveSymTypeOfAssignmentExpressions (calculate a SymTypeExpression for the expressions in the grammar AssignmentExpressions) DeriveSymTypeOfBitExpressions (calculate a SymTypeExpression for the expressions in the grammar BitExpressions) DeriveSymTypeOfLiterals (calculate a SymTypeExpression for the literals in the grammar LiteralsBasis) DeriveSymTypeOfMCCommonLiterals (calculate a SymTypeExpression for the literals in the grammar MCCommonLiterals) DeriveSymTypeOfMCJavaLiterals (calculate a SymTypeExpression for the literals in the grammar MCJavaLiterals) SynthesizeSymTypeFromMCBasicTypes (calculate a SymTypeExpression for the types in the grammar MCBasicTypes) SynthesizeSymTypeFromMCCollectionTypes (calculate a SymTypeExpression for the types in the grammar MCCollectionTypes) SynthesizeSymTypeFromMCSimpleGenericTypes (calculate a SymTypeExpression for the types in the grammar MCSimpleGenericTypes) SynthesizeSymTypeFromMCFullGenericTypes (calculate a SymTypeExpression for the types in the grammar MCFullGenericTypes) BasicSymbols (defines the symbols needed for the symboltable) OOSymbols (specialization of the BasicSymbols for object-oriented languages) SymTypeExpression (result of the TypeCheck, represents type usage) SymTypeArray (subclass of SymTypeExpression, represents arrays) SymTypeConstant (subclass of SymTypeExpression, represents primitive types) SymTypeOfGenerics (subclass of SymTypeExpression, represents generic types) SymTypeOfObject (subclass of SymTypeExpression, represents non-primitive types without type arguments) SymTypeVariable (subclass of SymTypeExpression, represents type variables) SymTypeOfNull (subclass of SymTypeExpression, represents the null type) SymTypeVoid (subclass of SymTypeExpression, represents the void type) SymTypeOfWildcard (subclass of SymTypeExpression, represents wildcard types) SymTypeExpressionFactory (factory for creating the subclasses of SymTypeExpression)","title":"Given infrastructure in MontiCore"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#what-is-the-difference-between-typesymbols-and-symtypeexpressions","text":"The TypeCheck uses the TypeSymbols of the BasicSymbols grammar and the handwritten SymTypeExpressions. While they are very similar, there is a big difference between them and when to use them. The TypeSymbols represent a type definition (example in Java: class List ) while the SymTypeExpressions represent a type usage (example in Java: List ). There is only one type definition, but there can be many type usages. The SymTypeExpression knows its corresponding TypeSymbol (like the type usage knows its definition) and can refer to its methods and fields. So when talking about a type definition, a type symbol, which can be stored and is present only once in the symboltable, has to be used. A SymTypeExpression is not stored in the symboltable, but refers to the definition of its type (its corresponding TypeSymbol) in the symboltable. Thus, a SymTypeExpression can be used multiple times and represents the usage of a type.","title":"What is the difference between TypeSymbols and SymTypeExpressions?"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#the-typecheck-facade","text":"The TypeCheck class of MontiCore is used as a facade to make TypeChecking easier for the user. It needs a Derive-Class and/or a Synthesize-Class to be instantiated. Here is a list of the methods and functions of the TypeCheck. * SymTypeExpression typeOf(ASTExpression expr) (uses the Derive-Class to derive a SymTypeExpression from an ASTExpression) * SymTypeExpression typeOf(ASTLiteral lit) (uses the Derive-Class to derive a SymTypeExpression from an ASTLiteral) * SymTypeExpression symTypeFromAST(ASTType type) (uses the Synthesize-Class to derive a SymTypeExpression from an ASTType) * static boolean compatible(SymTypeExpression left, SymTypeExpression right) (checks if the type of the right SymTypeExpression would be assignable to a variable with the type of the left SymTypeExpression) * static boolean isSubTypeOf(SymTypeExpression sub, SymTypeExpression sup) (checks if the type of sub is a subtype of the type of sup) * static boolean isInt(SymTypeExpression sym) (there are methods like this for all primitive types, checks if the SymTypeExpression represents the type 'int')","title":"The TypeCheck facade"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#how-does-the-typecheck-work","text":"The TypeCheck can be used to derive a SymTypeExpression from an expression or type. For example, when using an ASTPlusExpression '3+4', the TypeCheck returns a SymTypeExpression representing the type 'int'. You can use the ASTPlusExpression as a parameter for the method typeOf of the TypeCheck facade. This method delegates the calculation to your Derive-Class. First it derives the SymTypeExpression of the subexpressions '3' and '4' (the LiteralExpressions used in the PlusExpression) and then it calculates the SymTypeExpression of the whole PlusExpression by combining the SymTypeExpressions of its subexpressions in the context of the '+' operator. In general, the derivation of SymTypeExpressions for expressions first calculates the SymTypeExpressions of its subexpressions and (depending on the results) then combines these SymTypeExpression adequately to one SymTypeExpression for the whole expression. Deriving the SymTypeExpression of a type is often easier than deriving the SymTypeExpression of an expression. The ASTMCPrimitiveType 'int' will result in a SymTypeExpression 'int', the ASTMCBasicGenericType 'java.util.Map ' will result in a SymTypeExpression 'java.util.Map '. The derivation of types is very similar to the derivation of expressions with regard to subtypes and subexpressions. If a type has subtypes (like type arguments), then the SymTypeExpressions representing these subtypes will be calculated first. They can be used to put together the SymTypeExpression of the whole type. Because both types and expressions are converted into SymTypeExpressions, you can compare them. This is useful in the next example: int a = \"Hello\"; The SymTypeExpression derived from the ASTPrimitiveType 'int' will be 'int', the SymTypeExpression derived from the ASTLiteralExpression \"Hello\" will be 'String'. In a CoCo, you can check if they are compatible by using the function 'compatible' of the TypeCheck facade.","title":"How does the TypeCheck work?"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#i-want-to-write-a-coco-for-my-language-that-uses-the-typecheck-how","text":"You can use the TypeCheck facade. The facade needs a Derive-Class (for expressions and literals) and/or a Synthesize-Class (for types) and calculates the SymTypeExpression of your given expressions/literals/types. Create a DelegatorVisitor which combines all expression grammars and literal grammars used by your language. The DelegatorVisitor needs to implement the Interface IDerive. Use this Delegator as Derive-Class in the TypeCheck facade. The Synthesize-Class depends on the types grammar you use (see above-mentioned classes). For an example of the Delegator-Visitor see here . If you want to create a Derive-Class for your expression/literal grammar, you have to extend the Derive-Class of the supergrammar and implement the standard visitor of your language. There you can override the traverse methods for your expressions/literals so that it calculates the SymTypeExpression of the expression/literal (see implementation in one of the above-mentioned classes). You can add your visitor to the DelegatorVisitor later on. For an example of the Derive-Class for one language see here . For an example of the Synthesize-Class for one language see here Writing a CoCo to check the correctness of your type/expression/literal should be easy now that you have the TypeCheck facade to use. Just use the correct Derive-Class and/or the correct Synthesize-Class as parameters and check if the SymTypeExpression of your expression or type is correctly calculated. Example for a CoCo: @Override public void check(ASTExpression expr){ YourDeriveClass deriveClass = new YourDeriveClass(...); //instance of your Derive-Class YourSynthesizeClass synthesizeClass = new YourSynthesizeClass(...); //instance of your Synthesize-Class TypeCheck check = new TypeCheck(synthesizeClass,deriveClass); //instance of the TypeCheck-facade, parameters are your Synthesize-Class and your Derive-Class if(!\"double\".equals(check.typeOf(expr).print())){ //test if your expression is of the correct type (here: double) Log.error(...); //your specified error message } } An example for the case that a plus expression needs to return 'int' can be found here .","title":"I want to write a CoCo for my language that uses the TypeCheck - How?"},{"location":"monticore-grammar/src/main/java/de/monticore/types/check/TypeCheck/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/","text":"Documentation of the Symbol Table Infrastructure Conceptual Model of Symbol Tables What is a symbol? What is a symbol kind? What is a scope? What are properties of scopes? What is symbol resolution? Define the Symbol Table of a Language via its Grammar Indicate that a nonterminal defines a symbol Indicate that a nonterminal spans a scope Indicate that a nonterminal uses the name of a symbol Runtime Environment for Symbol Table Infrastructure This section explains classes and interfaces that are part of the MontiCore runtime environment. Symbol Table Infrastructure Interfaces Most of the interfaces of the MontiCore runtime enviroenment are super types of generated classes or interfaces that are explained here . IScope Interface This interface is the super type of the generated scope interfaces and thus, it is also transitive of global scope interfaces and artifact scope interfaces. IScope contains signatures for methods realizing the scope's connection to its environment (i.e., AST classes, sub scopes, enclosing scopes). Generated, language-specific scope interfaces refine the types of these methods. IArtifactScope Interface The IArtifactScope interface is an interface that all generated language-specific artifact scope interfaces extend. It provides an abstract method for obtaining an artifact scope's package as String. All further methods have either language-specific arguments or return types and are, thus, introduced in the language-specific artifact scope interfaces. IGlobalScope Interface The IGlobalScope interface is an interface that all generated language-specific global scope interfaces extend. It provides an abstract method for obtaining the global scope's Modelpath. All further methods have either language-specific arguments or return types and are, thus, introduced in the language-specific global scope interfaces. ISymbol Interface The ISymbol interface is an interface that all generated language-specific symbol classes implement. It provides the signatures for methods to obtaining the symbol's name, its package, its fully-qualified name, and its enclosing scope, and its AST node. Further, the interface contains the signatures of methods for getting and setting the access modifier of the symbol and default implementations for getting the source position of the symbol. It also includes a static method for sorting a collection of symbols by their source position, which is handy for realizing the semantics of ordered scopes. All further methods have either language-specific arguments or return types and are, thus, introduced in the specific symbol classes. ISymbolPredicate Interface An ISymbolPredicate is a predicate of a symbol and is used for filtering the results of symbol resolution. This is explained in more detail in [HR17] . The MontiCore runtime contains the class IncludesAccessModifierSymbolPredicate , which is an implementation of a symbol predicate for filtering symbols based on their access modifier. IScopeSpanningSymbol Interface The IScopeSpanningSymbol interface extends the interface ISymbol and adds a method signature for obtaining the scope that this symbol spans. Symbols that span a scope (which is the case, e.g., if the respective nonterminal in the grammar is annotated with both the keywords symbol and scope ) implement this interface instead of the ISymbol interface. Modifiers The modifiers contained in the MontiCore runtime implement the interface AccessModifier , which again is a Modifier . Out of the box, MontiCore supports the two access modifier implementations BasicAccessModifier and NoAccessModifier . Further, more sophisticated access modifiers have to be engineered individually, dedicated to their use for a specific modeling language. JSON Infrastructure for Symbol Table Serialization The MontiCore runtime contains classes that are required for serializing and deserializing symbol tables to Json-encoded Strings. The following explains these in short: JsonPrinter Class The class JsonPrinter wraps the concrete syntax of Json. It is an API for building Json-encoded String via a series of method calls. JsonParser Class The class JsonParser parses a Json-encoded String into an instance of the Json abstract syntax model . The central method of this class is the static method JsonElement parse(String s) . Json Parsing Infrastructure Besides the JsonParser class, the MontiCore runtime contains more classes required for translating JSON-encoded Strings into instances of the Json abstract syntax model . The class JsonLexer lexes an input String into a sequence of JsonToken instances. JsonToken instances realizes tokens that have a certain kind in form of a value from the enumeration JsonTokenKind . The NumberLexer is able to lex all kinds of valid numbers encoded in Json. Json Model The MontiCore runtime contains a model of the abstract syntax of JSON that is used by the JsonParser and the JsonPrinter for serialization of symbol tables. Individual classes exist for the different abstract syntax types of JSON. JsonDeSers Class The class JsonDeSers contains constants and static methods that support the generated language-specific symbol and scope DeSer classes. Generated Symbol Table Infrastructure MontiCore generates large parts of the symbol table infrastructure that is strongly typed for each MontiCore language. The following gives a short and technical introduction of each of these generated classes, interfaces, and enums. The concepts behind each of these infrastructure part if explained in the MontiCore Reference Manual [HR17] . Infrastructure Generated per Language This section explains all parts of the symbol table infrastructure that MontiCore generates once per language. For scopes, artifact scopes, and global scopes, MontiCore separated classes and interfaces. The interfaces follow the (multiple) inheritance of the grammars and realized most behavior in form of default method implementations. The classes implement the interface and manage access to attributes. Scope Interface For each language, MontiCore generates a scope interface. The scope interface prescribes all public methods of the scope class and realized some methods as default implementations. The hierarchy of MontiCore grammars is also reflected in the hierarchy of scope interfaces. To realize the multiple inheritance of MontiCore in Java, the scope interface is separated from the scope class. If a language inherits from one or more grammars, the scope interface of the language extends all scope interfaces of the inherited languages. Otherwise, if a language does not inherit from any language, the scope interface extends the IScope interface from the MontiCore runtime. Scope Class The scope class is generated for each MontiCore language. It implements the scope interface of the language and realizes scope attributes as well as method implementations that realize direct access to scope attributes. Scope Builder Class MontiCore generated builder classes for each scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the scope class can be initialized and a new instance of the scope can be created. We highly recommend instantiating scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages. ArtifactScope Interface The artifact scope interface is generated once for each MontiCore language. It extends the scope interface of the language and the artifact scope interface of the MontiCore runtime. Artifact scopes are instantiated once for each processed artifact and, conceptually, slightly differ from scopes established within a model. To this end, their realization overrides some methods of the scope interface with a special behavior and adds new methods. ArtifactScope Class MontiCore generates a single artifact scope class for each language that extends the scope class of the language and implements the artifact scope interface of the language. ArtifactScope Builder Class MontiCore generated builder classes for each artifact scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the artifact scope class can be initialized and a new instance of the artifact scope can be created. We highly recommend instantiating artifact scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages. GlobalScope Interface Similar to artifact scope interfaces, global scope interfaces extends the scope interface of the language. Additionally, they implement the global scope interfaces of their parent languages or the IGlobalScope of the MontiCore runtime if the languages do not inherit from another language. GlobalScope Class The global scope class is generated for each MontiCore language and realizes the concrete global scope of a language. It extends the scope class and implements the global scope iterface of the language. GlobalScope Builder Class MontiCore generated builder classes for each global scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the global scope class can be initialized and a new instance of the global scope can be created. We highly recommend instantiating global scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages. SymbolTableCreator Interface TODO: SymbolTableCreator Interface is about to be changed SymbolTableCreator Class TODO: SymbolTableCreator Class is about to be changed Common Symbol Interface The common symbol interface of a language extends the MontiCore runtime class ISymbol and provides methods for the connection to the enclosing scope and the visitor of the language. As these are specifically typed for each language, the common symbol interface is generated. All symbol classes of a language implement the common symbol interface. SymbolTablePrinter The symbol table printer traverses the scope tree of an artifact using a visitor and serializes it in form of a JSON-encoded String. Traversal typically begins with an artifact scope. In each scope, the local symbols are visited and serialized. If a symbol spans a scope, the spanned scope is visited while visiting the symbol. It, therefore, realizes traversal of the scope tree along the enclosingScope <-> localSymbols and the symbol <-> spannedScope associations. Symbol table printers are used by ScopeDeSers and SymbolDeSers. For language composition, the symbol table printers of individual languages are combined with a delegator visitor in the DeSer classes. ScopeDeSer The scope deser class provides methods realizing the loading and storing of scope objects of a language. Besides this, it realizes the deserialization of scopes. The deserialization of symbols within this scope is delegated to the respective symbol DeSers and serialization of symbols and scopes is delegated to the symbol table printer. The reason for this separation is that employing a visitor is suitable for serialization, but not for deserialization. The latter would visit elements of the abstract syntax of JSON, such as a Json object, and would require a large number of case distinctions within handling different objects that can be serialized as a Json object. Combining the visitor-based serialization and the deserialization into a single class would be inefficient in terms of compilation time. Generated per Symbol This section explains parts of the symbol table infrastructure that MontiCore generates once for each symbol of a language. Symbol Class For each symbol of the language, MontiCore generates a symbol class that implements the common symbol interface of the language. The symbol class realizes symbols of a certain kind. For example, the class StateSymbol realizes the kind StateSymbol and objects of this class are concrete symbols. A symbol kind can inherit from at most one other symbol kind. This is reflected in the symbol classes by extending the class of the super kind. Symbol Builder Class MontiCore generated builder classes for each symbol. The instances of the builders are available through the language's mill. With the builder, the attributes of the symbol class can be initialized and a new instance of the symbol can be created. We highly recommend instantiating symbol classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages, e.g., in case the symbol production is overridden in the grammar. Symbol DeSer The symbol DeSer classes are generated for each symbol and realize serialization and deserialization of symbols of a certain kind. The serialization is visitor-based and, thus, delegated to the symbol table printer. Symbol DeSers are used by scope DeSers to realize the deserialization of symbols and as such, are reused for all languages that inherit from the current language. As serialization and deserialization of individual symbols is rarely triggered manually, no load and store methods exist in symbol DeSer classes. Symbol Surrogate Class Symbol surrogate classes extend the generated symbol classes and realize lazy loading of symbls of this kind. Surrogates have a delegate of the symbol class that is empty during initialization of the surrogate., where only the enclosing scope and the name are set. They further define a method for resolving the symbol with the on demand. Symbol surrogates must only be if both of the following two conditions are met: 1. If on type level, a symbol has an attribute of another symbol, the attribute may be initialized with the surrogate as the symbol's subtype. 2. If on instance level, the symbol definition of the Surrogates must never be used to simplify instantiation of local symbols, i.e., of symbols that are contained in a single model for which the symbol table currently is build. In this case, it is always possible to split symbol table creation into multiple phases: In the first phase, all symbol definitions instantiate symbol class objects, for which the symbol attributes are not instantiated yet. In a later phase, the symbol attributes are filled with values. Symbol Surrogate Builder MontiCore generated builder classes for each symbol surrogate. The instances of the builders are available through the language's mill. With the builder, the attributes of the symbol surrogate class can be initialized and a new instance of the symbol surrogate can be created. Resolvers MontiCore generates a resolver interface for each symbol kind of a language. Resolvers have a method for resolving adapted symbol kinds. Language engineers can develop concrete resolving delegates that implement a resolver interface. Such classes can be added to the global scope of a language to integrate resolving for adapted symbols into the resolution process. For example, an automata language defines the generated resolver interface IStateSymbolResolver . This interface can be used by language engineers to implement a CDClass2StateResolver class implementing the interface that resolves, for example, for symbols of a CD class whenever resolving for state symbols is invoked. The result of this is typically an adapter symbol, which adapts the foreign symbol (e.g., CDClassSymbol) to the expected symbol (e.g., StateSymbol). Further Information Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Symboltable"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#documentation-of-the-symbol-table-infrastructure","text":"","title":"Documentation of the Symbol Table Infrastructure"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#conceptual-model-of-symbol-tables","text":"What is a symbol? What is a symbol kind? What is a scope? What are properties of scopes? What is symbol resolution?","title":"Conceptual Model of Symbol Tables"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#define-the-symbol-table-of-a-language-via-its-grammar","text":"Indicate that a nonterminal defines a symbol Indicate that a nonterminal spans a scope Indicate that a nonterminal uses the name of a symbol","title":"Define the Symbol Table of a Language via its Grammar"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#runtime-environment-for-symbol-table-infrastructure","text":"This section explains classes and interfaces that are part of the MontiCore runtime environment.","title":"Runtime Environment for Symbol Table Infrastructure"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-table-infrastructure-interfaces","text":"Most of the interfaces of the MontiCore runtime enviroenment are super types of generated classes or interfaces that are explained here .","title":"Symbol Table Infrastructure Interfaces"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iscope-interface","text":"This interface is the super type of the generated scope interfaces and thus, it is also transitive of global scope interfaces and artifact scope interfaces. IScope contains signatures for methods realizing the scope's connection to its environment (i.e., AST classes, sub scopes, enclosing scopes). Generated, language-specific scope interfaces refine the types of these methods.","title":"IScope Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iartifactscope-interface","text":"The IArtifactScope interface is an interface that all generated language-specific artifact scope interfaces extend. It provides an abstract method for obtaining an artifact scope's package as String. All further methods have either language-specific arguments or return types and are, thus, introduced in the language-specific artifact scope interfaces.","title":"IArtifactScope Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iglobalscope-interface","text":"The IGlobalScope interface is an interface that all generated language-specific global scope interfaces extend. It provides an abstract method for obtaining the global scope's Modelpath. All further methods have either language-specific arguments or return types and are, thus, introduced in the language-specific global scope interfaces.","title":"IGlobalScope Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#isymbol-interface","text":"The ISymbol interface is an interface that all generated language-specific symbol classes implement. It provides the signatures for methods to obtaining the symbol's name, its package, its fully-qualified name, and its enclosing scope, and its AST node. Further, the interface contains the signatures of methods for getting and setting the access modifier of the symbol and default implementations for getting the source position of the symbol. It also includes a static method for sorting a collection of symbols by their source position, which is handy for realizing the semantics of ordered scopes. All further methods have either language-specific arguments or return types and are, thus, introduced in the specific symbol classes.","title":"ISymbol Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#isymbolpredicate-interface","text":"An ISymbolPredicate is a predicate of a symbol and is used for filtering the results of symbol resolution. This is explained in more detail in [HR17] . The MontiCore runtime contains the class IncludesAccessModifierSymbolPredicate , which is an implementation of a symbol predicate for filtering symbols based on their access modifier.","title":"ISymbolPredicate Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#iscopespanningsymbol-interface","text":"The IScopeSpanningSymbol interface extends the interface ISymbol and adds a method signature for obtaining the scope that this symbol spans. Symbols that span a scope (which is the case, e.g., if the respective nonterminal in the grammar is annotated with both the keywords symbol and scope ) implement this interface instead of the ISymbol interface.","title":"IScopeSpanningSymbol Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#modifiers","text":"The modifiers contained in the MontiCore runtime implement the interface AccessModifier , which again is a Modifier . Out of the box, MontiCore supports the two access modifier implementations BasicAccessModifier and NoAccessModifier . Further, more sophisticated access modifiers have to be engineered individually, dedicated to their use for a specific modeling language.","title":"Modifiers"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#json-infrastructure-for-symbol-table-serialization","text":"The MontiCore runtime contains classes that are required for serializing and deserializing symbol tables to Json-encoded Strings. The following explains these in short:","title":"JSON Infrastructure for Symbol Table Serialization"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#jsonprinter-class","text":"The class JsonPrinter wraps the concrete syntax of Json. It is an API for building Json-encoded String via a series of method calls.","title":"JsonPrinter Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#jsonparser-class","text":"The class JsonParser parses a Json-encoded String into an instance of the Json abstract syntax model . The central method of this class is the static method JsonElement parse(String s) .","title":"JsonParser Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#json-parsing-infrastructure","text":"Besides the JsonParser class, the MontiCore runtime contains more classes required for translating JSON-encoded Strings into instances of the Json abstract syntax model . The class JsonLexer lexes an input String into a sequence of JsonToken instances. JsonToken instances realizes tokens that have a certain kind in form of a value from the enumeration JsonTokenKind . The NumberLexer is able to lex all kinds of valid numbers encoded in Json.","title":"Json Parsing Infrastructure"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#json-model","text":"The MontiCore runtime contains a model of the abstract syntax of JSON that is used by the JsonParser and the JsonPrinter for serialization of symbol tables. Individual classes exist for the different abstract syntax types of JSON.","title":"Json Model"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#jsondesers-class","text":"The class JsonDeSers contains constants and static methods that support the generated language-specific symbol and scope DeSer classes.","title":"JsonDeSers Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#generated-symbol-table-infrastructure","text":"MontiCore generates large parts of the symbol table infrastructure that is strongly typed for each MontiCore language. The following gives a short and technical introduction of each of these generated classes, interfaces, and enums. The concepts behind each of these infrastructure part if explained in the MontiCore Reference Manual [HR17] .","title":"Generated Symbol Table Infrastructure"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#infrastructure-generated-per-language","text":"This section explains all parts of the symbol table infrastructure that MontiCore generates once per language. For scopes, artifact scopes, and global scopes, MontiCore separated classes and interfaces. The interfaces follow the (multiple) inheritance of the grammars and realized most behavior in form of default method implementations. The classes implement the interface and manage access to attributes.","title":"Infrastructure Generated per Language"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scope-interface","text":"For each language, MontiCore generates a scope interface. The scope interface prescribes all public methods of the scope class and realized some methods as default implementations. The hierarchy of MontiCore grammars is also reflected in the hierarchy of scope interfaces. To realize the multiple inheritance of MontiCore in Java, the scope interface is separated from the scope class. If a language inherits from one or more grammars, the scope interface of the language extends all scope interfaces of the inherited languages. Otherwise, if a language does not inherit from any language, the scope interface extends the IScope interface from the MontiCore runtime.","title":"Scope Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scope-class","text":"The scope class is generated for each MontiCore language. It implements the scope interface of the language and realizes scope attributes as well as method implementations that realize direct access to scope attributes.","title":"Scope Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scope-builder-class","text":"MontiCore generated builder classes for each scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the scope class can be initialized and a new instance of the scope can be created. We highly recommend instantiating scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages.","title":"Scope Builder Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#artifactscope-interface","text":"The artifact scope interface is generated once for each MontiCore language. It extends the scope interface of the language and the artifact scope interface of the MontiCore runtime. Artifact scopes are instantiated once for each processed artifact and, conceptually, slightly differ from scopes established within a model. To this end, their realization overrides some methods of the scope interface with a special behavior and adds new methods.","title":"ArtifactScope Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#artifactscope-class","text":"MontiCore generates a single artifact scope class for each language that extends the scope class of the language and implements the artifact scope interface of the language.","title":"ArtifactScope Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#artifactscope-builder-class","text":"MontiCore generated builder classes for each artifact scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the artifact scope class can be initialized and a new instance of the artifact scope can be created. We highly recommend instantiating artifact scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages.","title":"ArtifactScope Builder Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#globalscope-interface","text":"Similar to artifact scope interfaces, global scope interfaces extends the scope interface of the language. Additionally, they implement the global scope interfaces of their parent languages or the IGlobalScope of the MontiCore runtime if the languages do not inherit from another language.","title":"GlobalScope Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#globalscope-class","text":"The global scope class is generated for each MontiCore language and realizes the concrete global scope of a language. It extends the scope class and implements the global scope iterface of the language.","title":"GlobalScope Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#globalscope-builder-class","text":"MontiCore generated builder classes for each global scope class. The instances of the builders are available through the language's mill. With the builder, the attributes of the global scope class can be initialized and a new instance of the global scope can be created. We highly recommend instantiating global scope classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages.","title":"GlobalScope Builder Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symboltablecreator-interface","text":"TODO: SymbolTableCreator Interface is about to be changed","title":"SymbolTableCreator Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symboltablecreator-class","text":"TODO: SymbolTableCreator Class is about to be changed","title":"SymbolTableCreator Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#common-symbol-interface","text":"The common symbol interface of a language extends the MontiCore runtime class ISymbol and provides methods for the connection to the enclosing scope and the visitor of the language. As these are specifically typed for each language, the common symbol interface is generated. All symbol classes of a language implement the common symbol interface.","title":"Common Symbol Interface"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symboltableprinter","text":"The symbol table printer traverses the scope tree of an artifact using a visitor and serializes it in form of a JSON-encoded String. Traversal typically begins with an artifact scope. In each scope, the local symbols are visited and serialized. If a symbol spans a scope, the spanned scope is visited while visiting the symbol. It, therefore, realizes traversal of the scope tree along the enclosingScope <-> localSymbols and the symbol <-> spannedScope associations. Symbol table printers are used by ScopeDeSers and SymbolDeSers. For language composition, the symbol table printers of individual languages are combined with a delegator visitor in the DeSer classes.","title":"SymbolTablePrinter"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#scopedeser","text":"The scope deser class provides methods realizing the loading and storing of scope objects of a language. Besides this, it realizes the deserialization of scopes. The deserialization of symbols within this scope is delegated to the respective symbol DeSers and serialization of symbols and scopes is delegated to the symbol table printer. The reason for this separation is that employing a visitor is suitable for serialization, but not for deserialization. The latter would visit elements of the abstract syntax of JSON, such as a Json object, and would require a large number of case distinctions within handling different objects that can be serialized as a Json object. Combining the visitor-based serialization and the deserialization into a single class would be inefficient in terms of compilation time.","title":"ScopeDeSer"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#generated-per-symbol","text":"This section explains parts of the symbol table infrastructure that MontiCore generates once for each symbol of a language.","title":"Generated per Symbol"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-class","text":"For each symbol of the language, MontiCore generates a symbol class that implements the common symbol interface of the language. The symbol class realizes symbols of a certain kind. For example, the class StateSymbol realizes the kind StateSymbol and objects of this class are concrete symbols. A symbol kind can inherit from at most one other symbol kind. This is reflected in the symbol classes by extending the class of the super kind.","title":"Symbol Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-builder-class","text":"MontiCore generated builder classes for each symbol. The instances of the builders are available through the language's mill. With the builder, the attributes of the symbol class can be initialized and a new instance of the symbol can be created. We highly recommend instantiating symbol classes only through the builder obtained via the mill. All other forms of instantiations will prohibit reconfiguration through sublanguages, e.g., in case the symbol production is overridden in the grammar.","title":"Symbol Builder Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-deser","text":"The symbol DeSer classes are generated for each symbol and realize serialization and deserialization of symbols of a certain kind. The serialization is visitor-based and, thus, delegated to the symbol table printer. Symbol DeSers are used by scope DeSers to realize the deserialization of symbols and as such, are reused for all languages that inherit from the current language. As serialization and deserialization of individual symbols is rarely triggered manually, no load and store methods exist in symbol DeSer classes.","title":"Symbol DeSer"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-surrogate-class","text":"Symbol surrogate classes extend the generated symbol classes and realize lazy loading of symbls of this kind. Surrogates have a delegate of the symbol class that is empty during initialization of the surrogate., where only the enclosing scope and the name are set. They further define a method for resolving the symbol with the on demand. Symbol surrogates must only be if both of the following two conditions are met: 1. If on type level, a symbol has an attribute of another symbol, the attribute may be initialized with the surrogate as the symbol's subtype. 2. If on instance level, the symbol definition of the Surrogates must never be used to simplify instantiation of local symbols, i.e., of symbols that are contained in a single model for which the symbol table currently is build. In this case, it is always possible to split symbol table creation into multiple phases: In the first phase, all symbol definitions instantiate symbol class objects, for which the symbol attributes are not instantiated yet. In a later phase, the symbol attributes are filled with values.","title":"Symbol Surrogate Class"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#symbol-surrogate-builder","text":"MontiCore generated builder classes for each symbol surrogate. The instances of the builders are available through the language's mill. With the builder, the attributes of the symbol surrogate class can be initialized and a new instance of the symbol surrogate can be created.","title":"Symbol Surrogate Builder"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#resolvers","text":"MontiCore generates a resolver interface for each symbol kind of a language. Resolvers have a method for resolving adapted symbol kinds. Language engineers can develop concrete resolving delegates that implement a resolver interface. Such classes can be added to the global scope of a language to integrate resolving for adapted symbols into the resolution process. For example, an automata language defines the generated resolver interface IStateSymbolResolver . This interface can be used by language engineers to implement a CDClass2StateResolver class implementing the interface that resolves, for example, for symbols of a CD class whenever resolving for state symbols is invoked. The result of this is typically an adapter symbol, which adapts the foreign symbol (e.g., CDClassSymbol) to the expected symbol (e.g., StateSymbol).","title":"Resolvers"},{"location":"monticore-runtime/src/main/java/de/monticore/symboltable/Symboltable/#further-information","text":"Project root: MontiCore @github MontiCore documentation List of languages MontiCore Core Grammar Library Best Practices Publications about MBSE and MontiCore Licence definition","title":"Further Information"}]}